<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Oprating-system Structrues</title>
      <link href="/2024/10/23/1.operating-System-Structures/"/>
      <url>/2024/10/23/1.operating-System-Structures/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h1><h2 id="操作系统为用户提供的服务："><a href="#操作系统为用户提供的服务：" class="headerlink" title="操作系统为用户提供的服务："></a>操作系统为用户提供的服务：</h2><p><img src="/img/oprating_system/Snipaste_2023-05-07_13-10-40.png"></p><p>User interfaces：为用户提供的接口中包含了 (对于普通用户)</p><blockquote><p>GUI(图形化接口)</p><p>batch(批处理)</p><p>command line(命令行)</p></blockquote><p>system calls：系统调用(面向程序员或应用程序提供的接口)</p><blockquote><p>program execution(程序的执行)</p><p>I&#x2F;O operations(输入输出的操作)</p><p>file system(以文件的方式保存在磁盘上 常见的有 NTFS  Exf4)</p><p>communication(通信，主要指进程间通信，提供程序之间的相互对话，传递一些数据)</p><p>resource allocation(资源分配，主要指，分配硬件资源)</p><p>accounting(记账，用于记录某个程序的如使用时间等信息)</p><p>error detection(错误检查)</p><p>protection and security(提供保护和安全性)</p></blockquote><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>纠正了以前的误区(系统调用并不是API，API中访问了系统调用)</p><ul><li>系统调用提供了访问和使用操作系统所提供的服务的接口。<ul><li>系统调用的实现代码是操作系统级的</li><li>这个接口通常是面向程序员的</li></ul></li><li>API (Application Programming Interface)：指明了参数和返回值的一组函数。<ul><li>应用程序App的开发人员通过透过API间接访问了系统调用</li><li>Windows API &#x2F; POSIX API &#x2F; JAVA API</li></ul></li></ul><h2 id="双重模式"><a href="#双重模式" class="headerlink" title="双重模式"></a>双重模式</h2><ul><li>现代计算机系统有一个特殊的硬件，用于划分系统 的运行状态，至少需要两种单独运行模式：<ul><li>用户模式（user mode）：执行用户代码</li><li>内核模式（kernel mode）：执行操作系统代码</li></ul></li><li>目的：确保操作系统正确的运行</li><li>实现方式<ul><li>用一个硬件模式位来表示当前模式：0表示内核模式，1 表示用户模式。</li></ul></li></ul><p>区分用户模式和内核模式，因为有一些非常重要的指令如(定时器的设置，错误的捕捉，等特权指令)，这些指令不系统被用户随意执行(安全性)，所以这些指令只能运行由操作系统运行，故就引出了内核模式</p><h2 id="运行模式的切换"><a href="#运行模式的切换" class="headerlink" title="运行模式的切换"></a>运行模式的切换</h2><p>系统调用需要在哪种模式下执行？</p><blockquote><p>系统调用的实现是操作系统级别的提供了访问和使用操作系统所提供的服务的接口，所以系统调用运行在内核模式下</p></blockquote><p>你的应用程序运行在哪种模式下？</p><blockquote><p>运行在用户模式下</p></blockquote><p>调用API函数printf时，运行模式如何切换？</p><blockquote><p>从用户态陷入内核态，执行系统调用后返回用户态</p></blockquote><p>如图：</p><p><img src="/img/oprating_system/Snipaste_2023-05-07_14-05-04.png"></p><h2 id="系统调用的实现机制"><a href="#系统调用的实现机制" class="headerlink" title="系统调用的实现机制"></a>系统调用的实现机制</h2><ul><li>每个系统调用都有一个唯一的数字编号，被称为系统调用号。</li><li>用户代码调用API时，API中会向系统调用接口指明其所要用的系统调用号，操作系统内核中维护了一张索引表，依据这个调用号可以检索到访系统调用代码在内核中的位置。</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-07_14-08-12.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> oprating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deadlocks(死锁)</title>
      <link href="/2024/10/23/10.deadlock/"/>
      <url>/2024/10/23/10.deadlock/</url>
      
        <content type="html"><![CDATA[<h1 id="DeadLocks"><a href="#DeadLocks" class="headerlink" title="DeadLocks"></a>DeadLocks</h1><h2 id="死锁的特征"><a href="#死锁的特征" class="headerlink" title="死锁的特征"></a>死锁的特征</h2><h3 id="哲学家用餐死锁问题"><a href="#哲学家用餐死锁问题" class="headerlink" title="哲学家用餐死锁问题"></a>哲学家用餐死锁问题</h3><ul><li>当所有人同时拿到一侧的筷子时，发生永远等待现象 （即死锁）。</li><li>有若种办法可避免死锁：<ul><li>至多允许四个哲学家同时吃；</li><li>奇数号先取左手边的筷子，偶数号先取右手边的筷子； </li><li>每个哲学家取到手边的两根筷子才吃，否则一根也不取。</li></ul></li><li>进程访问资源流程：申请 ➠ 使用 ➠ 释放</li></ul><h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><ul><li>In a multiprogramming environment, several(若干) processes  may compete for a finite(有限) number of resources.</li><li>A process requests(请求) resources; if the resources are not  available(可用的) at that time, the process enters a waiting state.</li><li>Sometimes, a waiting process is never again able to  change state, because the resources it has requested are  held(占有) by other waiting processes.</li><li>This situation is called a deadlock</li></ul><h3 id="死锁与饥饿"><a href="#死锁与饥饿" class="headerlink" title="死锁与饥饿"></a>死锁与饥饿</h3><ul><li>饥饿：进程长时间的等待</li><li>e.g.低优先级进程总是等待高优先级所占有的进程 </li><li>死锁：循环等待资源<br><img src="/img/oprating_system/Snipaste_2023-05-11_21-56-06.png"></li></ul><h3 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h3><ul><li>互斥使用： 一个时刻，一个资源仅能被一个进程占有</li><li>不可剥夺： 除了资源占有进程主动释放资源，其它进程都不可抢夺其资源</li><li>占有和等待 ：一个进程请求资源得不到满足等待时，不释放已占有资源</li><li>循环等待(上面三个条件同时存在产生的结果)：  每一个进程分别等待它前一个进程所占有的资源</li></ul><h3 id="死锁的解决方案"><a href="#死锁的解决方案" class="headerlink" title="死锁的解决方案"></a>死锁的解决方案</h3><ul><li>死锁的防止 (Prevention)</li><li>破坏四个必要条件之一</li><li>死锁的避免 (Avoidance)<ul><li>允许四个必要条件同时存在，在并发进程中做出妥善安 排避免死锁的发生，使用安全算法</li></ul></li><li>死锁的检测和恢复 (Detection &amp; Recovery)<ul><li>允许死锁的发生，系统及时地检测死锁并解除它</li></ul></li></ul><h2 id="死锁的防止"><a href="#死锁的防止" class="headerlink" title="死锁的防止"></a>死锁的防止</h2><ul><li>互斥使用：破坏这个意味者，要使资源共享使用，不是所有的资源都是可以共享使用的，如打印机同时只允许一个人使用，故：这明显是不可行的</li><li>不可剥夺：破坏这个条件意味着，资源可以被抢夺，我们只知道CPU可以被抢夺，若共享资源是打印机呢，抢夺打印机明显是不可行的，故：不可行</li><li>占有和等待：破坏这个条件意味这，一次性拿到进程所需的所有资源，若A进程需要disk CPU 打印机 ， 当A进程要执行时，他的全部资源就已经被获取了，但是导致了资源的严重浪费，因为A进程可能要在执行的最后才使用打印机，但是A在执行的开始就已经将其占用了，这造成了资源浪费，这是可以的但是效果不太好</li><li>循环等待：<br>破坏这个条件可以的方法：由程序员自行为资源排序可以将其抽象成一个数组，将资源以一定顺序放入数组中（一般按照优先级顺序）R &#x3D; {R1,R2,R3,R4}，当要申请一个资源时必须使得全部资源都满足才可申请（当要申请R3时，R1 ，R2资源均要获取），这样解决了循环等待问题，但是这样也存在资源的浪费（当申请R3时，R1与R2可能并不是必要的）而且可操作性差，故可行但是效果不好</li></ul><h2 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h2><h3 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h3><ul><li>A state is safe if the system can allocate resources to  each process (up to its maximum) in some order and  still avoid a deadlock. More formally(正式的), a system is in a  safe state only if there exists a safe sequence(序列).</li><li>If no such sequence exists, then the system state is  said to be unsafe.</li><li>A safe state is NOT a deadlocked state.</li><li>An unsafe state MAY lead to a deadlock.</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-12_09-48-50.png"></p><h3 id="死锁的避免-1"><a href="#死锁的避免-1" class="headerlink" title="死锁的避免"></a>死锁的避免</h3><ul><li>系统对进程的每一次资源申请都进行详细的计算， 根据结果决定是分配资源还是让其等待，确保系统 始终处于安全状态，避免死锁的发生。</li><li>银行家算法（Banker’s algorithm）<ul><li>已知系统中所有资源的种类和数量</li><li>已知进程所需要的各类资源最大需求量</li><li>该算法可以计算出当前的系统状态是否安全(寻找安全序列)</li></ul></li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-12_10-09-27.png"></p><p>存在安全序列{ P1,P3,P4,P2,P0 }，系统处于安全状态。</p><p>银行家算法就是寻找一个安全分资源的序列使得，避免死锁的发生</p><ul><li>优点：允许死锁必要条件同时存在</li><li>缺点：缺乏实用价值<ul><li>进程运行前就要求知道其所需资源的最大数量</li><li>要求进程是无关(独立)的，因为分配资源的安全顺序是固定的，若考虑同步情况，可能会打乱安全序列</li><li>要求进入系统的进程个数和资源数固定（这不太现实）</li></ul></li></ul><h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><h3 id="死锁的检测与恢复"><a href="#死锁的检测与恢复" class="headerlink" title="死锁的检测与恢复"></a>死锁的检测与恢复</h3><ul><li>允许死锁发生，操作系统不断监视系统进展情况， 判断死锁是否发生</li><li>一旦死锁发生则采取专门的措施，解除死锁并以最 小的代价恢复操作系统运行</li><li>死锁检测的时机<ul><li>当很多进程等待时检测死锁（系统开销大，资源被分配却没有归还）</li><li>定时检测</li><li>系统资源利用率下降时检测死锁</li></ul></li></ul><h3 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h3><p>方框表示一类资源，里面的黑点表示该类资源的个数<br>原型表示进程<br>由进程指向资源表示进程申请资源<br>由资源指向进程表示系统分配资源给欸进程</p><h3 id="资源分配图示例："><a href="#资源分配图示例：" class="headerlink" title="资源分配图示例："></a>资源分配图示例：</h3><p><img src="/img/oprating_system/Snipaste_2023-05-12_10-29-30.png"></p><p>死锁发生在申请边</p><p>图一：p1申请R1将会等待，P2申请R2将会等待，P3没有申请资源。故P3将会执行完会归还资源R2 R4，这样P2就可执行，P2执行完归还R1,P1即可正常运行</p><p>图二：P1申请R1将等待，P2申请R2将等待，P3申请R3将等待，3个进程无一可以执行故死锁</p><p>图三：P1申请R1将等待，P2不申请资源，P3申请R2，P2完成后归还R1，P4完成后归还R2，可以正常运行</p><h3 id="死锁的解除-recovery"><a href="#死锁的解除-recovery" class="headerlink" title="死锁的解除(recovery)"></a>死锁的解除(recovery)</h3><ul><li>中止进程，强制回收资源（如我们的windows中，一个进程可能会弹出对话框说进程长时间无响应，询问是否等待还是结束进程，这可能是改进程发生了死锁现象，这里使用可能是因为操作系统只检测了进程在等待队列的时长）</li><li>剥夺资源，但不中止进程 </li><li>进程回退(roll back)</li><li>重新启动</li></ul><p>参考：<a href="https://www.bilibili.com/video/BV1bf4y147PZ">https://www.bilibili.com/video/BV1bf4y147PZ</a></p><p>光看视频而不看书是远远不够的，但是由于考试在及，没有过多的时间，暑假立flag：</p><ul><li>让自己擅长汇编语言</li><li>操作系统真象还原</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> oprating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Memory management</title>
      <link href="/2024/10/23/11.Memory%20managemnet/"/>
      <url>/2024/10/23/11.Memory%20managemnet/</url>
      
        <content type="html"><![CDATA[<h1 id="Memory-management"><a href="#Memory-management" class="headerlink" title="Memory management"></a>Memory management</h1><p>cat &#x2F;proc&#x2F;pid&#x2F;maps # 查看当前进程的各段的内存加载信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">:~<span class="variable">$sudo</span> <span class="built_in">cat</span> /proc/7/maps</span></span><br><span class="line">[sudo] password for yixuan_zhang:</span><br><span class="line">00200000-0025a000 r--p 00000000 00:16 562949953668040                    /init</span><br><span class="line">0025a000-0034f000 r-xp 00059000 00:16 562949953668040                    /init</span><br><span class="line">0034f000-00361000 rw-p 0014d000 00:16 562949953668040                    /init</span><br><span class="line">00361000-00363000 rw-p 0015e000 00:16 562949953668040                    /init</span><br><span class="line">00363000-0036a000 rw-p 00000000 00:00 0</span><br><span class="line">020b0000-020b7000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">020b7000-020b9000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7efc18300000-7efc18301000 ---p 00000000 00:00 0</span><br><span class="line">7efc18301000-7efc18316000 rw-p 00000000 00:00 0</span><br><span class="line">7efc18316000-7efc18317000 ---p 00000000 00:00 0</span><br><span class="line">7efc18317000-7efc1832c000 rw-p 00000000 00:00 0</span><br><span class="line">7ffed4d66000-7ffed4d87000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7ffed4dd8000-7ffed4ddc000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffed4ddc000-7ffed4ddd000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">起始位置     终止位置     权限 偏移量 主设备号:副设备号  文件inode号        文件路径</span></span><br></pre></td></tr></table></figure><p>cat &#x2F;proc&#x2F;pid&#x2F;status # 查看当前进程状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">:~<span class="variable">$sudo</span> <span class="built_in">cat</span> /proc/7/status</span></span><br><span class="line">Name:   init</span><br><span class="line">Umask:  0022</span><br><span class="line">State:  S (sleeping)</span><br><span class="line">Tgid:   7</span><br><span class="line">Ngid:   0</span><br><span class="line">Pid:    7</span><br><span class="line">PPid:   1</span><br><span class="line">TracerPid:      0</span><br><span class="line">Uid:    0       0       0       0</span><br><span class="line">Gid:    0       0       0       0</span><br><span class="line">FDSize: 128</span><br><span class="line">Groups:</span><br><span class="line">NStgid: 7</span><br><span class="line">NSpid:  7</span><br><span class="line">NSpgid: 7</span><br><span class="line">NSsid:  7</span><br><span class="line">VmPeak:     1812 kB</span><br><span class="line">VmSize:     1812 kB</span><br><span class="line">VmLck:         0 kB</span><br><span class="line">VmPin:         0 kB</span><br><span class="line">VmHWM:        88 kB</span><br><span class="line">VmRSS:        88 kB</span><br><span class="line">RssAnon:              88 kB</span><br><span class="line">RssFile:               0 kB</span><br><span class="line">RssShmem:              0 kB</span><br><span class="line">VmData:      312 kB</span><br><span class="line">VmStk:       132 kB</span><br><span class="line">VmExe:       980 kB</span><br><span class="line">VmLib:         4 kB</span><br><span class="line">VmPTE:        40 kB</span><br><span class="line">VmSwap:        0 kB</span><br><span class="line">HugetlbPages:          0 kB</span><br><span class="line">CoreDumping:    0</span><br><span class="line">THP_enabled:    1</span><br><span class="line">Threads:        1</span><br><span class="line">SigQ:   0/31282</span><br><span class="line">SigPnd: 0000000000000000</span><br><span class="line">ShdPnd: 0000000000000000</span><br><span class="line">SigBlk: 0000000000010000</span><br><span class="line">SigIgn: fffffffc7ff8fefe</span><br><span class="line">SigCgt: 0000000000010000</span><br><span class="line">CapInh: 0000000000000000</span><br><span class="line">CapPrm: 000001ffffffffff</span><br><span class="line">CapEff: 000001ffffffffff</span><br><span class="line">CapBnd: 000001ffffffffff</span><br><span class="line">CapAmb: 0000000000000000</span><br><span class="line">NoNewPrivs:     0</span><br><span class="line">Seccomp:        0</span><br><span class="line">Seccomp_filters:        0</span><br><span class="line">Speculation_Store_Bypass:       thread vulnerable</span><br><span class="line">Cpus_allowed:   ffff</span><br><span class="line">Cpus_allowed_list:      0-15</span><br><span class="line">Mems_allowed:   1</span><br><span class="line">Mems_allowed_list:      0</span><br><span class="line">voluntary_ctxt_switches:        1</span><br><span class="line">nonvoluntary_ctxt_switches:     0</span><br></pre></td></tr></table></figure><h2 id="内存管理目标"><a href="#内存管理目标" class="headerlink" title="内存管理目标"></a>内存管理目标</h2><h3 id="main-memory"><a href="#main-memory" class="headerlink" title="main memory"></a>main memory</h3><ul><li>Main memory is central(中心) to the operation of a modern computer  system. </li><li>Memory consists(组成) of a large array of bytes, each with its own address(每一个字节都拥有地址).</li><li>The CPU fetches(获取) instructions from memory according to the value of  the program counter(PC). These instructions may cause additional(额外的)  loading from and storing to specific(特定的) memory addresses.</li><li>A typical(典型的) instruction-execution cycle, for example, first fetches an  instruction from memory. The instruction is then decoded(解码&#x2F;译码) and may  cause operands to be fetched from memory. After the instruction has  been executed on the operands, results may be stored back in  memory.</li></ul><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><ul><li>高速缓存是一种存取速度比内存快，但容量比内存小的多的存储器，它可以加快访问物理内存的相对速度。</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-12_14-19-42.png"></p><p>现代操作系统存在三级缓存，一级缓冲又分为指令缓存和数据缓冲，每个核心内均有二级缓存，三级缓存为所有核心公有</p><h3 id="保护操作系统和用户进程"><a href="#保护操作系统和用户进程" class="headerlink" title="保护操作系统和用户进程"></a>保护操作系统和用户进程</h3><ul><li>用户进程不可以访问操作系统内存数据，以及用户进程空间之间不能互相影响<ul><li>通过硬件实现，因为操作系统一般不干预CPU对内存的访问</li><li>base register：基址寄存器，保存一个进程加载到内存空间的起始地址</li><li>limit register：限长寄存器，保存这个进程所占空间的长度</li><li>上述两个寄存器的值只能被操作系统的特权指令加载，通过这两个寄存器可以确定一个进程的起始地址和结束地址，若访问地址不在这一区间内，操作系统将拒绝访问</li></ul></li></ul><h2 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h2><h3 id="地址空间和地址转换"><a href="#地址空间和地址转换" class="headerlink" title="地址空间和地址转换"></a>地址空间和地址转换</h3><ul><li>逻辑地址：面向程序的地址，总是从0开始编址，每 一条指令的逻辑地址就是与第1条指令之间的相对偏移，因此逻辑地址也叫相对地址或虚拟地址。</li><li>物理地址：内存单元看到的实际地址，也称为绝对地址</li><li>所有逻辑地址的集合称为逻辑地址空间，这些逻辑地址对应的所有物理地址集合称为物理地址空间。</li><li>地址转换：由逻辑地址转换成物理地址。</li></ul><h3 id="内存管理单元MMU"><a href="#内存管理单元MMU" class="headerlink" title="内存管理单元MMU"></a>内存管理单元MMU</h3><p>程序在编译时以及加载时均采用逻辑地址（加载时不计算地址，在运行时计算真实地址），只有在运行时才使用真实地址</p><ul><li>Memory-Management Unit完成逻辑地址到物理地址运行时的转换工作。</li><li>在加载时将加载首地址存放在，重定位寄存器（relocation register）或基址寄存器</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-12_14-59-39.png"></p><p>这解决了进程内存无法移动的问题，只需要将进程对应的重定位寄存器中的修改即可修改进程的加载位置</p><h2 id="contiguous-连续的-memory-allocation"><a href="#contiguous-连续的-memory-allocation" class="headerlink" title="contiguous(连续的) memory allocation"></a>contiguous(连续的) memory allocation</h2><h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><ul><li>In contiguous memory allocation, each process is  contained in a single section of memory that is  contiguous(相近的) to the section containing the next  process.</li><li>进程内部地址是连续的，进程与进程间是连续的</li></ul><h3 id="FIXED-SIZED-PARTITION-固定大小分区"><a href="#FIXED-SIZED-PARTITION-固定大小分区" class="headerlink" title="FIXED-SIZED PARTITION 固定大小分区"></a>FIXED-SIZED PARTITION 固定大小分区</h3><ul><li>Memory is divided(划分) to several(数个) fixed-sized(固定大小的) partitions(分区).  Each partition may contain exactly(恰好) one process.</li></ul><p>存在一张内存分区表，用于查看分区是否被占用</p><p><img src="/img/oprating_system/Snipaste_2023-05-12_15-40-27.png"></p><p>当 P1所占用的内存为 6K 那么P1 将加载到 编号为 1 的分区中，此时 1号 分区的 occuiped 将变为 1 表示已经占用，这意味为 1号 分区将不允许有其他进程占用，剩余的 2k 将会浪费掉。浪费掉的空间被称为碎片。这是一种非常早期的分区方案。</p><h3 id="Variable-partition-可变分区"><a href="#Variable-partition-可变分区" class="headerlink" title="Variable partition 可变分区"></a>Variable partition 可变分区</h3><ul><li>In the variable-partition scheme, the operating system(方案)  keeps two tables indicating(表明) which parts of memory  are available and which are occupied.（这两张表指的是占用表和空闲表）</li><li>Initially(初始时), all memory is available for user processes  and is considered(看作) one large block of available  memory, a hole.</li><li>Eventually,(最终) as you will see, memory contains a set of  holes of various sizes(不同大小)</li></ul><p>由于进程的加载与释放这势必会导致内存中出现一系列的孔洞，当相邻两个进程都释放时，所形成的孔洞将合并为一个孔洞</p><h4 id="动态存储分配问题"><a href="#动态存储分配问题" class="headerlink" title="动态存储分配问题"></a>动态存储分配问题</h4><ul><li>首次适应  分配首个足够大的孔，效率最高</li><li>最佳适应  分配最小的足够大的孔，浪费最小</li><li>最坏适应  分配最大的孔，产生的剩余孔更可能 被再利用</li></ul><p>首次分配和最佳分配在执行时间和利用空间方面都好于最坏适应，首次适应的效率优于最佳适应</p><h3 id="地址转换和保护"><a href="#地址转换和保护" class="headerlink" title="地址转换和保护"></a>地址转换和保护</h3><ul><li>两种连续分配方案的地址转换方式是相似的：  物理地址 &#x3D; 基址 + 逻辑地址</li><li>地址保护策略：与限长limit(寄存器)进行比较</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-12_16-43-12.png"></p><p>CPU在每次依靠MMU内存映射单元计算逻辑地址时，逻辑地址均要与 [0，limit] 范围进行比较（因为都要加基地址故省去），若在这个范围内则进行地址转换（访问物理地址），否则不进行地址转换（抛出异常）</p><h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><ul><li>Fragmentation: some little pieces of memory hardly  to be used.<ul><li>internal fragmentation(内部碎片)：针对固定分区来说，就是进程占用的固定分区的内存所导致有剩余内存，这部分内存被称为碎片</li><li>external fragmentation(外部碎片)：针对可变分区来说，当所剩孔洞足够小，小到不支持进程分配，那么部分内存被称为碎片</li></ul></li><li>碎片的解决方法：compaction(压缩，紧凑)，只有运行时地址转换才可以执行compaction，compaction的开销较大<br><img src="/img/oprating_system/Snipaste_2023-05-12_16-56-53.png"></li></ul><p>现代操作系统已经不采用这种内存管理的方案了</p><p>参考：<a href="https://www.bilibili.com/video/BV1bf4y147PZ/">https://www.bilibili.com/video/BV1bf4y147PZ/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> oprating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Segnation paging</title>
      <link href="/2024/10/23/12.segmation_page/"/>
      <url>/2024/10/23/12.segmation_page/</url>
      
        <content type="html"><![CDATA[<h1 id="segmation-paging分段分页"><a href="#segmation-paging分段分页" class="headerlink" title="segmation_paging分段分页"></a>segmation_paging分段分页</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>Solution to fragmentation(碎片): permit(允许) the logical address  space of processes to be noncontiguous(不连续). <ul><li>The view of memory is different between</li><li>logical (programmer’s ): a variable-sized(可变大小的) segments</li><li>physical : a linear(线性的) array of bytes</li></ul></li><li>The hardware could provide a memory mechanism(机制)  that mapped(映射) the logical view to the actual(实际的) physical  memory.</li></ul><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><h3 id="划分段"><a href="#划分段" class="headerlink" title="划分段"></a>划分段</h3><p>将：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void f()&#123;    //在未划分段时，地址时连续的，从 0 开始直至结束</span><br><span class="line">1.//...... </span><br><span class="line">2.//...... </span><br><span class="line">3.//...... </span><br><span class="line">4.&#125; </span><br><span class="line">5.void g()&#123; </span><br><span class="line">6.//...... </span><br><span class="line">7.//...... </span><br><span class="line">8.&#125; </span><br><span class="line">9.int main()&#123; </span><br><span class="line">10.//...... </span><br><span class="line">11.//...... </span><br><span class="line">12.return 0; </span><br><span class="line">13.&#125;</span><br></pre></td></tr></table></figure><p>划分为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0.void f()&#123;    //划分段后每段的起始地址为 0 ，每个段有对应的标号，段与段之间不需要连续</span><br><span class="line">1.//...... </span><br><span class="line">2.//...... </span><br><span class="line">3.//...... </span><br><span class="line">4.&#125;    // #1 表示第一段</span><br><span class="line">0.void g()&#123; </span><br><span class="line">1.//...... </span><br><span class="line">2.//...... </span><br><span class="line">3.&#125;    //#3 表示第三段</span><br><span class="line">0.int main()&#123; </span><br><span class="line">1.//...... </span><br><span class="line">2.//...... </span><br><span class="line">3.return 0;</span><br><span class="line">4.&#125;    //#2 表示第二段</span><br></pre></td></tr></table></figure><p><strong>在分段之后的程序中，访问逻辑地址需要表明段号和偏移</strong></p><p>注意：上述代码前的标号代表指令而非C语言语句</p><p>由于内存被分成了许多段，而且段与段之间并不连续，这就意味着需要一张段表来存放对应的信息用来寻找对应的逻辑地址</p><p>段表：段号，基址，限长</p><p>当拿到一个逻辑地址&lt;段号：偏移&gt;时，首先将段表内相应段号对应的基址值存放到base寄存器中，将对应的段限长存放到limit寄存器中，先执行保护（比较偏移与段限长，若未超过段限长则说明地址有效）后进行转换（物理地址 &#x3D; base + offset）</p><h3 id="逻辑地址-16位段式地址转换实例"><a href="#逻辑地址-16位段式地址转换实例" class="headerlink" title="逻辑地址 16位段式地址转换实例"></a>逻辑地址 16位段式地址转换实例</h3><p><img src="/img/oprating_system/Snipaste_2023-05-12_22-29-16.png"></p><ul><li><p>假设逻辑地址的段号占2bits，段内位移占14bits，此时 PC寄存器的值为0x240</p></li><li><p>下⼀条指令的物理地址为：</p><blockquote><p>PC：0b0000 00,10 0100 0000</p><p>故段号为0</p><p>下一条指令物理地址：0x4000 + 0x240 &#x3D; 0x4240</p></blockquote></li><li><p>Move 0x4050 → $a0, Move PC+4 → PC，下条指令物理地址为：</p><blockquote><p>PC由0x240 变为 0x244：0000 0010 0100 0100</p><p>短号为 0 </p><p>吓一跳物理地址为 0x4000 + 0x244 &#x3D; 0x4244</p></blockquote></li><li><p>Move 0x0248 → $ra (return address!), Move 0x0360 → PC，下条指令物理地址为：</p><blockquote><p>上述汇编指令意味着，将 0x0248存放到ra寄存器中（做函数的返回地址）</p><p>将PC寄存器中的值更新为 0x0360：0000 0011 0110 0000<br>对应短号为 0</p><p>下一条物理地址为：0x4000 + 0x0360 &#x3D; 0x4360</p></blockquote></li><li><p>Move 0x0→$v0, Move PC+4→PC，下条指令物理地址为：0x4364</p></li><li><p>“lb $t0,($a0)”(将a0寄存器中所示内存地址处取出1个字节存到寄存器t0中)，该内存地址为：</p><blockquote><p>a0中存放的值为：0x4040：0b0100 0000 0101 0000</p><p>对应的段为 1</p><p>运行时物理内存为：0x4800 + 0x50 &#x3D; 0x4850</p></blockquote></li></ul><p>分段并没有完全解决外部碎片的问题</p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="基本方案"><a href="#基本方案" class="headerlink" title="基本方案"></a>基本方案</h3><p>将内存看作是由若干个相等大小的分区组成，我们称这个分区为帧或页框</p><p>将进程也分为与帧大小相同的若干个，称为页面，只有切割进程的最后一块可能小于页面大小</p><p><img src="/img/oprating_system/Snipaste_2023-05-13_16-30-28.png"></p><p>如图：将内存分为 19 块等大的帧，进程分为 11 块等大的页面，将这 11个等大的页面离散的存放在memory中，当然就需要一张表用于存放帧的使用情况，记录了页面也页框的对应情况这个表被称为页表</p><p><img src="/img/oprating_system/Snipaste_2023-05-13_16-35-17.png"></p><p>分页后指令的逻辑地址将从 0 开始，为了确定物理地址，就必须确定页面号与页内偏移，根据页面号通过查询页表找到对应的页框号，从而确定物理地址</p><p><strong>physical address &#x3D; frame_no * pagesize + offset</strong></p><p>操作系统在进行分页地址转换时，直接将页面号替换为页框号与页内偏移进行拼接即可获得物理地址</p><h3 id="分页硬件"><a href="#分页硬件" class="headerlink" title="分页硬件"></a>分页硬件</h3><p><img src="/img/oprating_system/Snipaste_2023-05-13_17-19-09.png"></p><p>CPU根据逻辑地址&lt;页面号，页偏移&gt;，根据页面号查询页表找到对应的段号，将段号与段偏移拼接，得到物理地址</p><h3 id="LOGICAL-ADDRESS"><a href="#LOGICAL-ADDRESS" class="headerlink" title="LOGICAL ADDRESS"></a>LOGICAL ADDRESS</h3><ul><li>The page size (like the frame size) is defined by the hardware. The size of a  page is a power of 2(2的幂次), varying(更改) between 512 bytes and 1 GB per page,  depending(依赖) on the computer architecture(架构). （大小为2的幂次是为了可以拼接运算，目前大多数计算机采用页面大小为 4k）</li><li>The selection of a power of 2 as a page size makes the translation(转化) of a  logical address into a page number and page offset particularly(特别的) easy.</li><li>If the size of the logical address space is 2m , and a page size is 2n bytes,  then the high-order <code>m − n </code>bits of a logical address designate(指定为) the page  number, and the <code>n</code> low-order bits designate the page offset. Thus, the  logical address is as follows:</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-13_17-36-17.png"></p><h2 id="分页与分段的区别"><a href="#分页与分段的区别" class="headerlink" title="分页与分段的区别"></a>分页与分段的区别</h2><p><img src="/img/oprating_system/Snipaste_2023-05-13_17-45-49.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> oprating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Page table</title>
      <link href="/2024/10/23/13.page%20table/"/>
      <url>/2024/10/23/13.page%20table/</url>
      
        <content type="html"><![CDATA[<h1 id="Page-table"><a href="#Page-table" class="headerlink" title="Page table"></a>Page table</h1><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>页表是可以简化的，原来的页表：</p><p><img src="/img/oprating_system/Snipaste_2023-05-13_20-01-44.png"></p><p>可以观察出，若当页面号连续时，可以将页表简化为一个数组，数组元素中存放数组下标（即页面号）所对应的页框号</p><h3 id="页面大小"><a href="#页面大小" class="headerlink" title="页面大小"></a>页面大小</h3><p><img src="/img/oprating_system/Snipaste_2023-05-13_20-04-43.png"></p><ul><li>若逻辑地址长度为 m bits，页面大小：2^n Bytes<ul><li>页内位移占n bits</li><li>页号占m-n bits</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">:~<span class="variable">$uname</span> -m     //查看CPU架构</span></span><br><span class="line">x86_64</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">:~<span class="variable">$getconf</span> PAGESIZE   //获取当前页面大小</span></span><br><span class="line">4096</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">由于 4096Byte = 2 ^ 12 n=12   ,   系统为 64 位 故 m=64  (理论上)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但由于 64 位地址太大了，实际上我们只使用了 48位用来表示逻辑地址</span></span><br></pre></td></tr></table></figure><h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><ul><li>The operating system maintains(维护) a copy(副本) of the page  table for each process.</li><li>This copy is used to translate(转化) logical addresses to  physical addresses.</li><li>It is also used by the CPU dispatcher(派遣器) to define the  hardware page table when a process is to be allocated  the CPU.：当一个进程要被分配到CPU时，它也被CPU调度器用来定义硬件页表。</li><li>Paging therefore increases the context-switch(上下文切换) time</li></ul><h2 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h2><h3 id="HARDWARE-PAGE-TABLE（硬件页表）"><a href="#HARDWARE-PAGE-TABLE（硬件页表）" class="headerlink" title="HARDWARE PAGE TABLE（硬件页表）"></a>HARDWARE PAGE TABLE（硬件页表）</h3><ul><li>The page table is kept in main memory, and a pagetable base register (PTBR) points to the page table.</li><li>Changing(切换) page tables requires changing only this one  register, substantially(大幅的) reducing(减少) context-switch time.</li><li>With this scheme(方案), two memory accesses are needed to  access a byte (one for the page-table entry, one for the  byte).：在这种方案下，访问一个字节需要两次内存访问（一次为页表条目（寻找对应页面），一次为字节）。</li></ul><h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><ul><li>TLB(Translation(转换) Look-aside(旁路) Buffer(缓冲区)) is a kind of small,  fast-lookup(快速查找) hardware cache. It is used with page  tables in the following way(以下方式).<ul><li>The TLB contains only a few of (少数)the page-table entries(条目).这些条目的总称为快表</li><li>When a logical address is generated by(被生成) the CPU, its page  number is presented(提交) to the TLB. </li><li>If the page number is found, its frame number is  immediately available(可用的) and is used to access memory. </li><li>If TLB miss(没有命中), a memory reference to the page table must be  made.</li></ul></li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-13_21-28-33.png"></p><ul><li>The percentage(百分比) of times that the page number of interest is  found in the TLB is called the hit ratio(命中率).</li></ul><h2 id="基于页的保护与共享"><a href="#基于页的保护与共享" class="headerlink" title="基于页的保护与共享"></a>基于页的保护与共享</h2><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><ul><li>为了防止地址转换时出现异常，可在页表每个条目 设置一个“valid-invalid”比特位，用于表示该页 的有效性。</li><li>这个方法可以被轻松扩 展以提供更好的保护级别，如两个bit可实现 “只读”、“读 写”、“可执行”等。</li></ul><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p><img src="/img/oprating_system/Snipaste_2023-05-13_22-27-25.png"></p><p>如图，进程P1 P2 P3 对应的页表中均含有 3 4 6 号页面，这意味着3 4 6 号页面被三个进程所共享，只有特定的内容才可以被共享，一般具有只读属性</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><h4 id="页表大小"><a href="#页表大小" class="headerlink" title="页表大小"></a>页表大小</h4><ul><li>假设CPU是32bits，采用的逻辑地址是32bits，那么 进程的逻辑地址空间大小为2 32Bytes，即4G Bytes。<ul><li>若页面大小是4K Bytes，则一个进程最多被分成 4G&#x2F;4K &#x3D; 1M个页 面，也就是说进程的页表最多有1M个页表项；</li><li>若每个页表项占用4Bytes，则每个页表最多占用 1M B* 4B &#x3D; 4MBytes ，由于页大小为4k，故需要 4M&#x2F;4K 1K个连续页框。</li></ul></li></ul><p>问题来了，1k个连续的页框应该如何解决？<br>这里采用的方法时将页表也拆散</p><h4 id="页表页"><a href="#页表页" class="headerlink" title="页表页"></a>页表页</h4><p><img src="/img/oprating_system/Snipaste_2023-05-14_13-57-38.png"></p><p>我们将进程分为（p#0 p#1 p#2 …… p#7），将其存放在页表中，根据页表可以查询到对应的页框，但是由于页表较大需要连续分配2个页框，但我们希望将页表分开存储以达到内存灵活，因此设计了页表页。首先将页表按照页框大小分若个个并标号，将页表离散的存储到页框中，页表页中记录了页表对应的编号和存放到对应页框的对应关系，这样就实现了页表的离散存储。当然对应的逻辑地址也要发生改变。这种分页方法我们称为二级页表</p><h4 id="多级页表-1"><a href="#多级页表-1" class="headerlink" title="多级页表"></a>多级页表</h4><p><img src="/img/oprating_system/Snipaste_2023-05-14_14-12-11.png"></p><ul><li>上面是一个32位地址采用两级页表的例子，页面大 小是4KBytes，第一级页表页的数量是1K个，每个页 表页中包含的页面数量也是1K个。</li><li>下面是x86-64架构CPU采用的四级页表方案</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-14_14-12-42.png"></p><p>参考：<a href="https://www.bilibili.com/video/BV1bf4y147PZ/">https://www.bilibili.com/video/BV1bf4y147PZ/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> oprating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>virtual memory</title>
      <link href="/2024/10/23/14.virtual%20memory/"/>
      <url>/2024/10/23/14.virtual%20memory/</url>
      
        <content type="html"><![CDATA[<h1 id="Virtual-memory"><a href="#Virtual-memory" class="headerlink" title="Virtual memory"></a>Virtual memory</h1><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p><img src="/img/oprating_system/Snipaste_2023-05-15_10-40-40.png"></p><p>CPU核心首先从 cache 中寻找数据，当数据不存在时再访问内存，并且将该内存的内容拷贝一份放入缓存。<br>缓存的长相形如上图黄色部分，每次向缓存读入数据的单位是缓存行，一个缓存行中有8个格子，每个格子大小为 8Byte，故：一个缓存行大小为 64Byte。当缓存中没有指定内容，需要到内存中访问数据时，会将该内存以及后 63Byte，一同拷贝到一个缓存行中</p><h3 id="那些数据应该放入缓存中"><a href="#那些数据应该放入缓存中" class="headerlink" title="那些数据应该放入缓存中"></a>那些数据应该放入缓存中</h3><p><img src="/img/oprating_system/Snipaste_2023-05-15_11-06-53.png"></p><p>由大量的实验表明，在进程中，大量被引用的代码和数据常常位于进程地址空间中的某一局部地址，这被称为局部性原理。由于存在局部性原理，使得缓存的命中率变得非常的高</p><h3 id="局部性原理-1"><a href="#局部性原理-1" class="headerlink" title="局部性原理"></a>局部性原理</h3><ul><li>时间局部性(Temporal locality)：如果某个信息这次被访问，那它有可能在不久的未来被多次访问。</li><li>空间局部性(Spatial locality)：如果某个位置的信息被访问，那和它相邻的信息也很有可能被访问到。</li><li>内存局部性(Memory locality)：访问内存时，大概率会访问连续的块，而不是单一的内存地址，其实就是空 间局部性在内存上的体现。</li><li>分支局部性(Branch locality)：计算机中大部分指令是顺序执行，顺序执行和非顺序执行的比例大致是5:1。 </li><li>等距局部性(Equidistant locality)：等距局部性是指如果某个位置被访问，那和它相邻等距离的连续地址极有可 能会被访问到。</li></ul><h3 id="修改缓存"><a href="#修改缓存" class="headerlink" title="修改缓存"></a>修改缓存</h3><p>两种方案（保持数据的一致性）：</p><ul><li>write through：修改缓存数据的同时修改内存数据（效率低下，不仅修改了内存还修改了缓存，不如直接该内存）</li><li>write back：只修改缓存数据，直到该数据要被清除出 缓存再修改内存中的数据，我们称缓存中被修改的数据为dirty data(脏数据)</li></ul><h3 id="缓存数据的淘汰"><a href="#缓存数据的淘汰" class="headerlink" title="缓存数据的淘汰"></a>缓存数据的淘汰</h3><p>缓存的容量很小，当缓存满的时候，就需要将缓存中的部分数据淘汰，装入新的数据。  这就需要淘汰算法</p><ul><li>淘汰命中次数最少的</li><li>淘汰第一个CacheLine 或 最后一个CacheLine</li></ul><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="部分装入和部分对换"><a href="#部分装入和部分对换" class="headerlink" title="部分装入和部分对换"></a>部分装入和部分对换</h3><ul><li>部分装入<ul><li>进程运行时仅加载部分进入内存，而不必全部装入</li><li>其余部分暂时放在swap space(交换空间)</li></ul></li><li>部分对换<ul><li>可以将进程部分对换出内存，用以腾出内存空间</li><li>对换出的部分暂时放在swap space</li></ul></li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-15_14-35-59.png"></p><p>swap space位于磁盘，当进程会将一部分暂时不需要的内容存放在swap space中，当swap space中的内容被需要时将会加载到内存中，这个过程被称为 swap in ， 进程不需要的内容会被存放在swap space中，这个过程被称为 swap out。由于swap in 和 swap out 的存在，导致内存好像变得无限大，这个swap space就被称为虚拟内存</p><h3 id="virtual-memory"><a href="#virtual-memory" class="headerlink" title="virtual memory"></a>virtual memory</h3><ul><li>Virtual memory is a technique that allows the execution  of processes that are not completely(完全地) in memory.(部分装入)</li><li>One major(主要的) advantage of this scheme(安排) is that programs can  be larger than physical memory.</li><li>Further(此外), virtual memory abstracts(抽象) main memory into an  extremely(极度地) large, uniform(统一) array of storage, separating(独立的)  logical memory as viewed by the user from physical  memory.</li><li>This technique frees programmers(程序员) from the concerns(关注) of  memory-storage limitations(限制).</li></ul><h2 id="demand-paging-请求调页"><a href="#demand-paging-请求调页" class="headerlink" title="demand paging 请求调页"></a>demand paging 请求调页</h2><p>linux采用分页机制管理内存，请求调页时基于分页机制的</p><h3 id="demand-paging"><a href="#demand-paging" class="headerlink" title="demand  paging"></a>demand  paging</h3><ul><li>With demand-paged virtual memory , pages  are loaded only when  they are demanded  during program  execution.<br>在需求分页的虚拟内存中，只有在程序执行过程中需要的时候才会加载页面。</li><li>Pages that are never  accessed(访问) are thus never  loaded into physical  memory.</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-15_15-28-20.png"></p><p>如图：一个进程被分为7个页面(ABCDEFGH)，只有ACF被装载到内存中（我们称之为内存驻留），其余页面位于虚拟内存中。此时page table内只记录内存驻留的页面，当需要虚拟内存中数据时，当发起请求，成功则执行调页并记录在page table内</p><h3 id="请求调页步骤"><a href="#请求调页步骤" class="headerlink" title="请求调页步骤"></a>请求调页步骤</h3><p><img src="/img/oprating_system/Snipaste_2023-05-15_15-43-15.png"></p><p>当逻辑地址 M 被引用时，首先在页表中查询，对应invalue，即此页面没有加载到内存中，将发出缺页中断，将在内核模式下完成调页，将在虚拟内存中找到所要加载的页面，在页框中找到空闲的页框，将其载入，后在页表中记录</p><h3 id="请求调页的性能"><a href="#请求调页的性能" class="headerlink" title="请求调页的性能"></a>请求调页的性能</h3><ul><li><p>假设访问内存时间为ma，处理一次缺页中断的时间 记作page fault time，令p为缺页中断的出现几率， 则有效访问时间的计算公式为：</p><blockquote><p>effective access time &#x3D; (1 − p) × ma + p × page fault time </p></blockquote></li><li><p>若ma&#x3D;200ns，page fault time&#x3D;8ms，p&#x3D;0.001，则  </p><blockquote><p>effective access time &#x3D; 8200ns </p></blockquote><p>比直接访问内存慢了40倍</p></li><li><p>缺页中断率p对性能影响重大</p></li></ul><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ul><li>当进程在执行过程中发生了缺页，在请求调页的时候发现内存已经没有空闲页框可用，操作系统在此时会做出一个处理：页面置换。</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-15_19-02-24.png"></p><ol><li>在内存中选取一个页框为victim(牺牲者)，将它放在swap page中保存</li><li>将页表中对应的页框置为invalid</li><li>将所要加载的页面加载到空出的页框中</li><li>将页表中对应页框标记为valid</li></ol><p>对于victim的选择就由很大的讲究了，若选的不好，这将大大增加缺页的概率，导致执行时间延长</p><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><ul><li>总是淘汰最先进入内存的页面，因为它在内存中待的时间最久。</li></ul><h3 id="OPIMAL-最优"><a href="#OPIMAL-最优" class="headerlink" title="OPIMAL 最优"></a>OPIMAL 最优</h3><ul><li>总是淘汰未来最长时间不会再使用的页面。</li></ul><p>虽然是最优算法，但是不可能实现，因为操作系统不能知道每个页面将应该在何时被使用</p><h3 id="LRU（LEAST-RECENT-UNUSED）"><a href="#LRU（LEAST-RECENT-UNUSED）" class="headerlink" title="LRU（LEAST RECENT UNUSED）"></a>LRU（LEAST RECENT UNUSED）</h3><ul><li>总是淘汰最近最少使用的页面</li></ul><h2 id="系统抖动"><a href="#系统抖动" class="headerlink" title="系统抖动"></a>系统抖动</h2><ul><li>If the process does not have the number of frames it needs to support pages in active use, it will quickly pagefault. At this point, it must replace some page. However, since all its pages are in active use, it must replace a page that will be needed again right away. Consequently, it quickly faults again, and again, and again, replacing pages that it must bring back in immediately.<br>如果进程没有它所需要的页框数量来支持正在使用的页面，它将很快出现pagefault。在这一点上，它必须替换一些页面。然而，因为它的所有页面都在使用中，所以它必须替换一个马上就需要的页面 它必须替换一个马上就会再次需要的页面。因此，它迅速地再犯错，再犯错，再犯错，替换那些必须立即恢复的页面。它必须立即恢复。</li><li>This high paging activity is called thrashing. A process is  thrashing if it is spending more time paging than  executing.<br>这种高分页活动被称为 “抖动”。一个进程如果一个进程花在分页上的时间多于执行的时间。</li></ul><h3 id="抖动的原因"><a href="#抖动的原因" class="headerlink" title="抖动的原因"></a>抖动的原因</h3><p>开始时，COU利用率随着多道程序的增加而增加，当多道程序持续增多，CPU利用率陡然下降（page faul 出现增多），产出了抖动</p><p><img src="/img/oprating_system/Snipaste_2023-05-15_19-41-41.png"></p><ul><li>并发进程数量过多 </li><li>进程页框分配不合理</li></ul><h3 id="PAGE-FAULT-FREQUENCY（频率）"><a href="#PAGE-FAULT-FREQUENCY（频率）" class="headerlink" title="PAGE FAULT FREQUENCY（频率）"></a>PAGE FAULT FREQUENCY（频率）</h3><p><img src="/img/oprating_system/Snipaste_2023-05-15_19-50-56.png"></p><ul><li>PFF称作页面故障(频)率，基于这个数据可以实施一个 防止抖动的策略：动态调节分配给进程的页框数量。</li></ul><p>使一个进程的 page fault frequency 动态调节位于 upper bound 和 lower bound 之间，这样既不会造成资源的浪费也不会发生过多的缺页</p><h3 id="CONCLUDING-REMARKS"><a href="#CONCLUDING-REMARKS" class="headerlink" title="CONCLUDING REMARKS"></a>CONCLUDING REMARKS</h3><ul><li>Practically speaking, thrashing and the resulting  swapping have a disagreeably large impact on  performance.</li><li>The current best practice in implementing a computer  facility is to include enough physical memory, whenever  possible, to avoid thrashing and swapping.</li><li>From smartphones through mainframes, providing  enough memory to keep all working sets in memory  concurrently, except under extreme conditions, gives the  best user experience.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> oprating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mass story</title>
      <link href="/2024/10/23/15.mass%20storage/"/>
      <url>/2024/10/23/15.mass%20storage/</url>
      
        <content type="html"><![CDATA[<h1 id="Mass-storage"><a href="#Mass-storage" class="headerlink" title="Mass storage"></a>Mass storage</h1><h2 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h2><ul><li>磁道：能被磁头访问的一组同心圆  </li><li>扇区：磁道上的区域，数据存放的基本单位  </li><li>柱面：所有盘片同一磁头下的磁道集合</li></ul><p>对磁道的划分有两种方法：</p><ol><li>以同心圆的方式划分：磁盘要使用恒定角速度旋转</li></ol><p><img src="/img/oprating_system/Snipaste_2023-05-16_10-59-35.png"></p><ol start="2"><li>以磁道密度相等划分：磁盘转动的线速度相等，即角速度不断改变</li></ol><h3 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h3><ul><li><p>低级格式化（Low-level formatting</p><ul><li>physical formatting </li><li>为每个扇区使用特殊的数据结构进行填充，包括一个头 部、数据区域和一个尾部。</li><li>头部和尾部包含一些控制信息，如扇区号、ECC码(校验码)等。<br>低级格式化是与操作系统无关的格式化，属于物理级别的格式化，一个磁盘建立柱面划分扇区的过程就是在低级格式化中完成的，当大家买到一块硬盘时，低级格式化就已经完成了。当磁道损坏较高时应该进行低级格式化</li></ul></li><li><p>高级格式化（High-level formatting）</p><ul><li><p>Logical formatting</p></li><li><p>构建文件系统，在磁盘上初始化文件系统数据结构，如空 闲和 已分配空间表、一个空目录等。</p><p>高级格式化一般是和操作系统有关的<br>如windows电脑一般采用 NTFS 进行格式化 MAC系统一般采用EXT4 进行格式化</p></li></ul></li></ul><h2 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h2><ul><li>查找一个物理块的顺序：柱面号、磁头号和扇区号<ul><li>寻道时间Ts：将磁头定位到正确磁道(柱面)上所花的时 间，与盘片直径和传动臂速度相关，平均20ms。  </li><li>旋转延迟Tr：所查找的扇区转到磁头下所用的时间，与 磁盘的旋转速度有关，一个10,000 r&#x2F;m的磁盘平均旋转延 迟为3ms。  </li><li>传送时间T：传送扇区内的数据的时间，同样取决于磁盘 的旋转速度，T &#x3D; b&#x2F;(rN) (b为要传送的字节数，N为一个 磁道中的字节数，r为转速)</li></ul></li><li>总的平均存取时间 Ta &#x3D; Ts + Tr + T</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">条件假设: </span><br><span class="line">平均寻道时间为 5 ms，平均旋转延迟为 4 ms </span><br><span class="line">传输速率为 4 MByte/s，扇区大小是 1 KByte</span><br><span class="line"></span><br><span class="line">如果随机访问一个扇区 </span><br><span class="line">Ta = 5ms + 4ms + 0.25ms ≈ 10 ms </span><br><span class="line">总的存取速率为100 KByte/sec</span><br><span class="line"></span><br><span class="line">如果要访问的扇区在同一个柱面 </span><br><span class="line">Ta = 4ms + 0.25ms ≈ 5 ms → 200 KByte/sec </span><br><span class="line"></span><br><span class="line">如果下一个要访问的扇区正好和上次访问的扇区相邻 </span><br><span class="line">Ta = 0.25ms → 4 MByte/sec</span><br><span class="line">可以看出寻道时间和旋转延时相对于数据访问是要大得多</span><br></pre></td></tr></table></figure><h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><h3 id="disk-io-request"><a href="#disk-io-request" class="headerlink" title="disk io request"></a>disk io request</h3><ul><li>Whenever a process needs I&#x2F;O to or from(读或书) the disk, it  issues(发出) a system call to the operating system. The  request specifies(指定) several(一些) pieces of information:<ul><li>Whether this operation(操作) is input or output  </li><li>What the disk address for the transfer(转移) is  </li><li>What the memory address for the transfer is  </li><li>What the number of sectors(扇区) to be transferred is</li></ul></li></ul><h3 id="disk-scheduling"><a href="#disk-scheduling" class="headerlink" title="disk scheduling"></a>disk scheduling</h3><ul><li>For a multiprogramming system with many processes, the  disk queue may often have several(多个) pending (未决) requests.</li></ul><h4 id="FCFS先来先服务"><a href="#FCFS先来先服务" class="headerlink" title="FCFS先来先服务"></a>FCFS先来先服务</h4><p><img src="/img/oprating_system/Snipaste_2023-05-16_12-38-28.png"></p><h4 id="SSTF-Shortest-seek-time-first"><a href="#SSTF-Shortest-seek-time-first" class="headerlink" title="SSTF(Shortest seek time first)"></a>SSTF(Shortest seek time first)</h4><p>每次寻道均寻找当前队列中，距离当前磁头所在磁道距离最近的柱面</p><p><img src="/img/oprating_system/Snipaste_2023-05-16_12-42-34.png"></p><p>这会导致磁臂粘连现象，这本质也是一种饥饿现象，磁头会读取当前柱面附近的柱面，从而导致与之较远的柱面长时间未被读取，产生饥饿</p><h4 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h4><p><img src="/img/oprating_system/Snipaste_2023-05-16_12-50-24.png"></p><p>扫描算法，会沿着当前方向一直寻找，直至到<strong>最端柱面</strong>，在此过程中若经过pending queue中存在的柱面号，则暂停寻找处理数据。<br>当进程所有访问的柱面是分散的时，采用scan算法时较好</p><h4 id="c-scan"><a href="#c-scan" class="headerlink" title="c-scan"></a>c-scan</h4><p>scan算法是会原路返回的，但是这一小段时间内pending队列中出现靠近柱面最端的概率并不大，故改进，当扫描到达柱面端时，从另一柱面端开始重新扫描</p><p><img src="/img/oprating_system/Snipaste_2023-05-16_13-13-09.png"></p><h4 id="look"><a href="#look" class="headerlink" title="look"></a>look</h4><p>scan和c-scan算法，有些蠢，当对应方向之后没有要寻找的柱面时，磁头任然会继续移动直至柱面端点，look对此进行了改善，当对应方向之后没有需要寻找的柱面时，方向将会反转</p><p><img src="/img/oprating_system/Snipaste_2023-05-16_13-18-24.png"></p><ul><li><p>FCFS is the simplest(最简单的). </p></li><li><p>SSTF is common and has a natural appeal but it may  cause a starvation(饥饿) problem.  </p></li><li><p>SCAN and C-SCAN perform better for systems that  place a heavy load on the disk.</p></li></ul><p>查看linux中当前的和支持的磁盘调度算法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">:~<span class="variable">$cat</span> /sys/block/sda/queue/scheduler</span></span><br></pre></td></tr></table></figure><h3 id="linux-io-scheduler"><a href="#linux-io-scheduler" class="headerlink" title="linux io scheduler"></a>linux io scheduler</h3><ul><li>noop：it performs(施行) FCFS policy which is good enough for SSD.</li><li>deadline：it works by creating two queues: a read queue and a  write queue. Each I&#x2F;O request has a time stamp(时间戳) associated(关联) that is used by the kernel for an expiration(过期) time. When an I&#x2F;O  request reaches its deadline, it is pushed to(推到) the highest priority(优先级).    </li><li>cfq：Complete(完全) Fairness(公平的) Queueing works by creating a perprocess I&#x2F;O queue. The goal of this I&#x2F;O scheduler is to provide  a fair I&#x2F;O priority to each process. While the CFQ algorithm is  complex, the gist of this scheduler is that after ordering the  queues to reduce disk seeking, it services these per-process I&#x2F;O  queues in a round-robin fashion.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> oprating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Process Concept</title>
      <link href="/2024/10/23/2.process%20concept/"/>
      <url>/2024/10/23/2.process%20concept/</url>
      
        <content type="html"><![CDATA[<h1 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h1><h2 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h2><h3 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h3><ul><li>A program is a passive(被动的) entity(实体), such as a file  containing a list of instructions stored on disk(often  called an executable file).</li><li>A program becomes a process when an executable file  is loaded into memory.</li><li>A process is an active(活动的) entity, with a program counter(程序计数器) specifying(指明) the next instruction to execute an a set of  associated(相关的) resources<br>一个进程是一个活跃的实体，有一个程序计数，指定下一条要执行的指令和一组相关的资源。</li></ul><h3 id="program-counter"><a href="#program-counter" class="headerlink" title="program counter"></a>program counter</h3><ul><li>程序计数器（PC）是一个CPU中的寄存器，里面存放下一条要执行指令的内存地址，在Intel x86和 Itanium微处理器中，它叫做指令指针（Instruction  Pointer，IP），有时又称为指令地址寄存器 （instruction address register，IAR）、指令计数器。</li><li>通常，CPU在取完一条指令之后会将PC寄存器的值 加“1”，以计算下条要执行指令的地址。这里的 + 1 指的是指向下一条指令</li></ul><p><strong>process in memory 详细参考csapp第七章链接 以及 栈工作原理不在赘述了，</strong></p><h3 id="并发的进程"><a href="#并发的进程" class="headerlink" title="并发的进程"></a>并发的进程</h3><ul><li><p>Concurrency(并发)：the fact(事实) of two or more events or  circumstances(情况) happening or existing at the same time.</p></li><li><p>与并行的区别</p><blockquote><p>并发是指系统能够同时处理多个任务，而不是同时执行多个任务。在并发模型中，任务被交替执行，它们共享系统资源（例如 CPU、内存等），每个任务都有自己的执行上下文，但它们在同一时间只能执行一部分操作。这种模型通常用于处理大量的 I&#x2F;O 操作，因为在等待 I&#x2F;O 操作完成的过程中，系统可以同时执行其他任务，从而提高了系统的利用率。</p><p>并行是指系统可以同时执行多个任务，每个任务都可以独立执行，它们之间没有任何依赖关系。在并行模型中，任务被同时执行，每个任务都有自己的 CPU 核心或处理器来处理它们，每个任务的执行时间可以重叠，从而缩短了总体的执行时间。这种模型通常用于处理计算密集型任务，例如图像处理、数值模拟等。</p><p>总之，虽然并发和并行都涉及到同时执行多个任务，但并发强调的是同时处理多个任务，而并行强调的是同时执行多个任务。</p></blockquote></li><li><p>进程并发的动机：多道程序设计</p></li></ul><h3 id="并发进程共享CPU"><a href="#并发进程共享CPU" class="headerlink" title="并发进程共享CPU"></a>并发进程共享CPU</h3><ul><li>并发进程可能无法一次性执行完毕，会走走停停。</li><li>一个进程在执行过程中可能会被另一个进程替换占有 CPU，这个过程称作“进程切换”。</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-07_17-02-52.png"></p><p>如图有三个进程并发运行，实线表示占用 CUP 虚线表示不占用 CPU 可能进行 IO 操作，参见这幅图进程切换也就显而易见了</p><h3 id="进程的定义-1"><a href="#进程的定义-1" class="headerlink" title="进程的定义"></a>进程的定义</h3><ul><li>进程是一个程序的一次执行过程<ul><li>能完成具体的功能</li><li>是在某个数据集合上完成的</li><li>执行过程是可并发的</li></ul></li><li>进程是资源分配、保护和调度的基本单位</li></ul><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><h3 id="进程状态-process-state"><a href="#进程状态-process-state" class="headerlink" title="进程状态(process state)"></a>进程状态(process state)</h3><ul><li>进程在执行期间自身的状态会发生变化，进程有三 种基本状态，分别是：<ul><li>运行态（Running）：此时进程的代码在CPU上运行</li><li>就绪态（Ready）：进程具备运行条件，等待分配CPU</li><li>等待态（Waiting）：进程在等待某些事件的发生（比如 IO操作或是一个信号）</li></ul></li></ul><h3 id="进程何时离开CPU"><a href="#进程何时离开CPU" class="headerlink" title="进程何时离开CPU"></a>进程何时离开CPU</h3><ul><li>内部事件 （主动）<ul><li>进程主动放弃(yield)CPU，进入等待状态。E.g 使用I&#x2F;O设备</li><li>非正常结束，进入终止状态。E.g 除数是0</li></ul></li><li>外部事件（被动）<ul><li>进程被剥夺CPU使用权，进入就绪状态。这个动作叫抢占(preempt)。E.g 时间片到达，高优先权进程到达。</li></ul></li></ul><h3 id="进程转换"><a href="#进程转换" class="headerlink" title="进程转换"></a>进程转换</h3><p><img src="/img/oprating_system/Snipaste_2023-05-07_19-51-24.png"></p><blockquote><p>一个程序被加载处于新建状态，当资源齐全时会进入就绪ready(就绪状态)</p><p>running -&gt; ready ：被动被抢占，可能时间片到达，高优先级被抢占</p><p>running -&gt; waiting：主动放弃，可能调用了 IO 设备</p><p>running -&gt; finish：程序非正常结束，可能除数是 0</p><p>ready -&gt; running：当排队到时间片时，开始运行</p><p>waiting -&gt; running : 这是不可行的</p><p>waiting -&gt; ready：如当 IO 操作完成时程序进入就绪态，IO操作由 USB 控制器完成</p><p>ready -&gt; running：不用解释</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> oprating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>process scheduling</title>
      <link href="/2024/10/23/3process%20scheduling%20and%20practice1/"/>
      <url>/2024/10/23/3process%20scheduling%20and%20practice1/</url>
      
        <content type="html"><![CDATA[<h1 id="process-scheduling"><a href="#process-scheduling" class="headerlink" title="process scheduling"></a>process scheduling</h1><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><h3 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h3><ul><li>外中断：来自处理器之外的硬件中断信号<ul><li>如时钟中断、键盘中断、外围设备中断</li><li><strong>外部中断均是异步中断</strong>，所谓的异步就是随机</li></ul></li><li>内中断（异常 Exception）：来自于处理器内部，指令执行过程中发生的中断，<strong>属同步中断</strong><ul><li>硬件异常：掉电、奇偶校验错误等</li><li>程序异常：非法操作、地址越界、断点、除数为0 </li><li>系统调用</li></ul></li></ul><p><strong>由于系统调用是内中断所以系统调用存在陷阱机制(这才是系统调用陷阱机制的原因)</strong></p><p>外中断是不可预测的是随机的。但是内中断(异常)的发生均是在预定指令的执行过程中发生的，所以异常属于同步中断</p><h3 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h3><p>在详细的说一遍中断的过程：</p><p><img src="/img/oprating_system/Snipaste_2023-05-07_21-34-47.png"></p><blockquote><ol><li>程序在用户态执行时由于自身原因遇到了异常或由于外部时间导致程序产出中断</li><li>save the context(上下文) of the executing process，如当前寄存器状态，cpu时间片使用</li><li>陷入内核态，determine(确认) the cause of exception or interrupt，Handle the exception &#x2F; interrupt</li><li>select a process to restore and resume(复原)  选择要恢复的进程<br>restore the context of the selected process   恢复所选择进程的上下文<br>resume execution of the selected process     恢复所选择进程的执行</li></ol></blockquote><h3 id="特权指令和非特权指令"><a href="#特权指令和非特权指令" class="headerlink" title="特权指令和非特权指令"></a>特权指令和非特权指令</h3><ul><li>Privileged(特权) Instructions : The Instructions that can run only in Kernel Mode are called  Privileged Instructions .<ul><li>I&#x2F;O instructions and Halt(停顿&#x2F;暂定) instructions </li><li>Turn off all Interrupts    关闭所有中断</li><li>set the Timer(定时器)</li><li>process switching(切换)</li></ul></li><li>Non-Privileged Instructions : The Instructions that can run only in User Mode are called Non-Privileged Instructions</li></ul><h3 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h3><p><strong>中断是用户态向核心态转换的唯一途径！系统调用 实质上也是一种中断</strong></p><p>OS提供<code>Load PSW</code>指令装载用户进程返回用户状态</p><p><img src="/img/oprating_system/Snipaste_2023-05-07_22-06-12.png"></p><h3 id="进程切换-1"><a href="#进程切换-1" class="headerlink" title="进程切换"></a>进程切换</h3><ul><li><p>切换时机</p><ul><li><p>进程需要进入等待状态，主动离开CPU可能因为执行 IO 操作</p></li><li><p>进程被抢占CPU而进入就绪状态，被动离开可能因为时间片切换</p><blockquote><p>进程切换一定发生在中断&#x2F;异常&#x2F;系统调用处理过程中，常见的有以下情况：</p><ul><li>时间片<strong>中断</strong>、IO<strong>中断</strong>后 更改优先级进程；（导致被中断进程进入<strong>就绪态</strong>）；</li><li>阻塞式<strong>系统调用</strong>、<strong>虚拟地址异常</strong>；（导致被中断进程进入<strong>等待态</strong>）</li><li>终止用<strong>系统调用</strong>、<strong>不能继续执行的异常</strong>；（导致被中断进程进入<strong>终止态</strong>）</li></ul></blockquote></li></ul></li><li><p>切换过程</p><ul><li>由用户态切换到内核态，之后的切换工作均在内核态完成</li><li>保存被中断进程的上下文信息（Context)</li><li>修改被中断进程的控制信息（如状态等）</li><li>将被中断的进程加入相应的状态队列 ，若为等待状态则进入等待状态的队列</li><li>调度一个新的进程并恢复它的上下文信息</li></ul></li></ul><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>A Process Control Block（PCB）contains many  pieces of information associated(与……有关) with a specific(特定的)  process.</p><p>每个进程中都有一个PCB控制块</p><p>PCB进程控制块中包含了</p><blockquote><p>process state：进程状态，如就绪，等待，运行</p><p>process num：进程号 pid</p><p>programe counter</p><p>registers：寄存器的值</p><p>memory limits：内存信息，如：加载地址，最大上限，虚拟地址</p><p>list of open file：进程所打开的文件描述符</p><p>等一系列信息</p></blockquote><h3 id="进程在物理内存"><a href="#进程在物理内存" class="headerlink" title="进程在物理内存"></a>进程在物理内存</h3><p>存放方式如图：</p><p><img src="/img/oprating_system/Snipaste_2023-05-08_09-08-00.png"></p><p>进程实际在物理内存中并不是连续存放的，而是离散的</p><h3 id="进程队列"><a href="#进程队列" class="headerlink" title="进程队列"></a>进程队列</h3><p><img src="/img/oprating_system/Snipaste_2023-05-08_09-12-24.png"></p><p>如图，第一个队列为就绪队列，其余均为等待队列。等待队列有多个是因为针对不同的IO设备存在对应个数的等待对垒。没有运行队列的原因，对于单处理器来说哦同一时间只有一个进程可以运行。</p><p>注意进程队列中存放的是对于进程的PCB信息而非进程的全部信息，因为PCB足以描述进程切换所用到的信息</p><h3 id="进程调度-process-sheduling"><a href="#进程调度-process-sheduling" class="headerlink" title="进程调度(process sheduling)"></a>进程调度(process sheduling)</h3><p>进程在整个生命周期中会在各个调度队列中迁移， 由操作系统的一个调度器（scheduler）来执行。</p><p><img src="/img/oprating_system/Snipaste_2023-05-08_09-20-42.png"></p><p>如图：显示了进程调度中可能的情况，从等待状态 - &gt; 就绪状态 - &gt; 运行状态 ， 这个迁移过程是由 scheduler 完成的</p><p>由于学过linux系统编程了实验二就是fork函数的使用，我就没有做</p>]]></content>
      
      
      
        <tags>
            
            <tag> oprating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thread</title>
      <link href="/2024/10/23/4.thread/"/>
      <url>/2024/10/23/4.thread/</url>
      
        <content type="html"><![CDATA[<h1 id="threads"><a href="#threads" class="headerlink" title="threads"></a>threads</h1><h2 id="线程定义"><a href="#线程定义" class="headerlink" title="线程定义"></a>线程定义</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul><li>一个应用通常需要同时处理很多工作，比如一个Web浏览器，可能需要同时处理文字和图片，这些同时执行的任务可称为 “执行流”，我们不希望它们是顺序执行的。</li><li>早期，每个执行流都要创建一个进程来实现，但是进程的创建需要消耗大量的时间和资源。</li><li>现在，和一个应用相关的所有执行任务都装在一个进程里，这些进程内部的执行任务就是“线程”（Thread）。</li></ul><p>如果一个web服务器中的文字图片和视频是顺序执行的，那么用户体验是极差的，但这不是我们要讨论的主题，主要是CPU的利用率是低下的，进程浪费的资源主要是内存资源</p><h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><p>如图是单线程进程和多线程进程的部分虚拟内存布局</p><p><img src="/img/oprating_system/Snipaste_2023-05-08_12-18-04.png"></p><p>多线程进程：code data files 这三样东西是共享的，与多进程程序相比节省了系统资源，即线程间通信资源消耗小于进程间通信。每个线程中独立存在保存当前进程的寄存器值，以及线程中独立拥有栈空间</p><h3 id="采用多线程的优点"><a href="#采用多线程的优点" class="headerlink" title="采用多线程的优点"></a>采用多线程的优点</h3><ul><li><p>响应性：</p></li><li><p>资源共享</p></li><li><p>经济</p></li><li><p>可伸缩性</p><p>如web服务器接受client的请求，每接收一个请求就新建一个线程，由于client访问的资源常常会有重复，线程不像进程那样复制资源，共享资源节省了很大的内存，可伸缩性值的是多核处理器中并行运行时可以独占CPU</p></li></ul><h3 id="defintion-of-thread"><a href="#defintion-of-thread" class="headerlink" title="defintion of thread"></a>defintion of thread</h3><ul><li>A thread is a basic unit(基本单位) of CPU utilization(利用); it comprises(包括) a  thread id, a program counter, a register set, and a stack.</li><li>It shares with other threads belonging(属于) to the same  process its code section, data section, and other  operating-system resources, such as open files and  signals(信号).</li><li>A traditional(传统的) (or heavyweight) process has a single(单一的)  thread of control. If a process has multiple threads of  control, it can perform(执行) more than one task at a time.</li></ul><h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><h3 id="多核编程"><a href="#多核编程" class="headerlink" title="多核编程"></a>多核编程</h3><p>在多处理器系统中，多核编程机制让应用程序可以 更有效地将自身的多个执行任务（并发的线程）分散到不同的处理器上运行，以实现并行计算 </p><p><img src="/img/oprating_system/Snipaste_2023-05-08_12-42-43.png"></p><h3 id="多线程模型-1"><a href="#多线程模型-1" class="headerlink" title="多线程模型"></a>多线程模型</h3><ul><li><p>用户线程ULT（User Level Thread）</p><blockquote><p>ULT在user mode下运行，它的管理无需内核支持。</p></blockquote></li><li><p>内核线程KLT（Kernel Level Thread）</p><blockquote><p>KLT在kernel mode下运行，由操作系统支持与管理。</p></blockquote></li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-08_12-48-49.png"></p><h4 id="M：1模型"><a href="#M：1模型" class="headerlink" title="M：1模型"></a>M：1模型</h4><p>当只有一个CUP单核时：</p><p><img src="/img/oprating_system/Snipaste_2023-05-08_15-52-10.png"></p><p>所有的用户模式下的线程对应这一个内核模式下的线程</p><p>在用户看来自己使用的是多线程，用户认为有多个执行流（逻辑上），实际上真正占有CPU的只有一个线程<strong>只有KLP才可以占有CPU</strong>，这样设计的原因是硬件一般仅有一个核心</p><h4 id="1：1模型"><a href="#1：1模型" class="headerlink" title="1：1模型"></a>1：1模型</h4><p>存在一个用户线程就有一个内核线程与之对应</p><p><img src="/img/oprating_system/Snipaste_2023-05-08_16-01-51.png"></p><p>在内核级别的线程上看来实现了真正的并发与并行(多核)，但是由于每个用户线程对应一个内核线程，这样显得过于浪费资源</p><h4 id="M：M模型"><a href="#M：M模型" class="headerlink" title="M：M模型"></a>M：M模型</h4><p><img src="/img/oprating_system/Snipaste_2023-05-08_16-07-29.png"></p><p>注意：KLP的数量大于CPU的核心数</p><p>解决了1：1模型中开销大的问题，但是加入了用户线程想内核线程分配的过程，实现复杂</p><p>NPTL：native(原生的) posix thread library     指的是1：1模型</p><p>NGPT：nexr gerneration(机构) posix thread  指的是M：M模型</p><p>目前操作系统的主流采用 1：1模型</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>使用Pthread库创建多个线程，并观察线程的并发执行现象及数据共享</p><blockquote><p>Monte Carlo技术计算π值（多线程）</p></blockquote><p>数学原理：</p><p><img src="/img/oprating_system/Snipaste_2023-05-08_17-01-17.png"><br>$$<br>(2r) ^ 2 &#x2F; π * r^2 &#x3D; 4<br>$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">calculate_pi</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cir_points = <span class="number">0</span>;    <span class="comment">//存在圆内的点的数量</span></span><br><span class="line">    <span class="type">int</span> square_points = <span class="number">0</span>; <span class="comment">//存在正方形内点的数量</span></span><br><span class="line">    <span class="type">double</span> pi;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> intervals = *(<span class="type">int</span>*)argv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;intervals * intervals;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> rand_x = (<span class="type">double</span> )rand() / RAND_MAX;</span><br><span class="line">        <span class="type">double</span> rand_y = (<span class="type">double</span> )rand() / RAND_MAX;</span><br><span class="line">        <span class="keyword">if</span>(rand_x * rand_x + rand_y * rand_y &lt; <span class="number">1</span>)</span><br><span class="line">            cir_points++;</span><br><span class="line">        square_points++;</span><br><span class="line">    &#125;</span><br><span class="line">    pi = (<span class="type">double</span> )(<span class="number">4.0</span> * cir_points) / square_points;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;circle points: %d , square_point: %d , the extimated PI is %lf pid :%d\n&quot;</span>,</span><br><span class="line">           cir_points,square_points,pi,getpid());</span><br><span class="line">    pthread_exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="type">time_t</span> start = rand();</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = <span class="number">100</span> * (i + <span class="number">1</span>);</span><br><span class="line">        pthread_create(tid+i,<span class="literal">NULL</span>,calculate_pi,(<span class="type">void</span>*)(arr+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">time_t</span> delta = rand();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time : %ld&quot;</span>,(delta - start) / CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> oprating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU Scheduling</title>
      <link href="/2024/10/23/5.CPU%20scheduling/"/>
      <url>/2024/10/23/5.CPU%20scheduling/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU-Scheduling"><a href="#CPU-Scheduling" class="headerlink" title="CPU Scheduling"></a>CPU Scheduling</h1><h2 id="CPU调度程序"><a href="#CPU调度程序" class="headerlink" title="CPU调度程序"></a>CPU调度程序</h2><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><ul><li>多道程序设计的目的将CPU 的利用率最大化。</li><li>多个进程同时存在于内存（并发），当一个进程暂不使用CPU时，系统调度另一 个进程占用CPU。</li></ul><p>CPU-burst Durrations(CPU突发事件持续时间)</p><p><img src="/img/oprating_system/Snipaste_2023-05-08_20-48-58.png"></p><p>如图：横轴为突发时间持续时间，纵轴为发生的频率</p><p>我们将时间位于 0 - 8ms 中的进程称为 CPU-bound program 也可以被称为短进程 ，大于 8ms的进程称为 I&#x2F;O-bound program 也可以被称为长进程，从频率长看大多数进程属于短进程</p><h3 id="CPU调度程序-1"><a href="#CPU调度程序-1" class="headerlink" title="CPU调度程序"></a>CPU调度程序</h3><p>Whenever the CPU becomes idle(闲置), the operating  system must select one of the processes in the ready  queue to be executed. The selection process is carried  out by the CPU scheduler.</p><p>存在两种调度方法：</p><ul><li>非抢占调度（Nonpreemptive scheduling）：一旦某个进程得到CPU，就会一直占用到终止或等待状态。</li><li>抢占调度 (preemptive scheduling)：调度程序被动被动离开CPU如：时间片到期</li></ul><h2 id="CPU调度准则"><a href="#CPU调度准则" class="headerlink" title="CPU调度准则"></a>CPU调度准则</h2><h3 id="调度算法的衡量"><a href="#调度算法的衡量" class="headerlink" title="调度算法的衡量"></a>调度算法的衡量</h3><ul><li>CPU利用率：CPU的忙碌程度</li><li>响应时间：从提交任务到第一次响应的时间，针对交互式系统</li><li>等待时间：进程<strong>累积</strong>在就绪队列中等待的时间</li><li>周转时间：从提交到完成的时间</li><li>呑吐率：每个时钟单位处理的任务数</li><li>公平性：以合理的方式让各个进程共享CPU</li></ul><p>假设作业 i 提交给系统的时刻是ts，完成的时刻是tf， 所需运行时间为 tk，那么：</p><blockquote><p>单个作业的周转时间 ti：完成时间 - 开始时间<br>$$<br>ti &#x3D; tf - ts<br>$$<br>平均作业周转时间 T：n为操作系统的进程数，将每个进程的周转时间累加后在平均<br>$$<br>T &#x3D; \sum_{i&#x3D;1}^n ti \times 1 &#x2F; n<br>$$</p></blockquote><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务-FCFS）"><a href="#先来先服务-FCFS）" class="headerlink" title="先来先服务(FCFS）"></a>先来先服务(FCFS）</h3><ul><li><p>First-Come, First-Served (FCFS)</p><ul><li><p>早期系统里，FCFS意味着一个程序会一直运行到结束(尽管其中会出 现等待I&#x2F;O的情况)</p></li><li><p>非抢占式</p></li><li><p>如今，当一个程序阻塞时会让出CPU</p><blockquote><p>假设当前就绪队列中依次存在 p1  p2  p3  p4 四个进程，p1 开始运行，运行过程中调用IO设备，此时将让出CPU进入等待状态，位于就绪队列队头的 p2 被调度器从就绪队列中取出进入运行状态，一段时间后 p1 完成IO操作要返回就绪队列，要注意的是，p1入队(从队尾入队)</p></blockquote><p><img src="/img/oprating_system/Snipaste_2023-05-09_08-24-27.png"></p><p><img src="/img/oprating_system/Snipaste_2023-05-09_08-25-17.png"></p><p>第二种排列方式比第一种要好，平均周转时间缩短为18</p></li><li><p>优点：简单易行<br>缺点：需要控制进程先到的顺序才能时平均周转时间减少</p></li></ul></li></ul><h3 id="时间片轮转-ROUND-ROBIN"><a href="#时间片轮转-ROUND-ROBIN" class="headerlink" title="时间片轮转(ROUND ROBIN)"></a>时间片轮转(ROUND ROBIN)</h3><ul><li><p>时间片轮转(ROUND ROBIN)</p><ul><li>每个进程都可以得到相同的CPU时间(CPU时间片,  time slice)，当时间片到达，进程将被剥夺CPU并加入就绪队列的尾部 。（分时系统）</li><li>抢占式调度算法</li><li>n个就绪队列中的进程和时间片q：<br>每个进程获得1&#x2F;n的CPU时间，大约是q个时间单位<br>没有进程等待时间会超过 (n-1)q</li><li>例题：</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-09_08-50-03.png"></p><blockquote><p>等待时间分别是：</p><p>P1&#x3D;(68-20)+(112-88)+(145-132)&#x3D;85   P2&#x3D;(20-0)+(88-40)+(132-108)&#x3D;92<br>P3&#x3D;(40-0)+(108-60)&#x3D;88                           dP4&#x3D;(60-0)&#x3D;60 </p><ul><li>平均等待时间 &#x3D; (85+92+88+60)&#x2F;4&#x3D;81.25</li><li>平均周转时间 &#x3D; (153+145+112+68)&#x2F;4&#x3D;119.5</li></ul></blockquote><ul><li>RR算法分析<ul><li>时间片（time slice）取选<ul><li>取值太小：进程切换开销显著增大(不能小于进程切换的时间)</li><li>取值较大：响应速度下降（取值无穷大将退化成FCFS）</li><li>一般时间片的选取范围为 10ms~100ms</li><li>上下文切换的时间大概为 0.1ms~1ms （1%的CPU时间开销）</li></ul></li><li>RR算法优缺点<ul><li>公平算法(+) </li><li>对长作业带来额外的切换开销(-)</li></ul></li></ul></li></ul><h3 id="最短作业优先-SJF"><a href="#最短作业优先-SJF" class="headerlink" title="最短作业优先(SJF)"></a>最短作业优先(SJF)</h3><ul><li>SJF(Shortest Job First)：下一次调度总是选择所需要 CPU时间最短的那个作业（进程）。</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-09_09-20-40.png"></p><p>在FCFS算法中，我们提及到，如果我们知道每个作业所需的运行时长，并按照时长从低到高的顺序依次服务，这样求出的平均周转时间是很低的，这也就是SJF算法的由来</p><ul><li>SJF是一个非抢占式的算法，当人也可以改造为一个抢占式SRTF</li></ul><p>以上图举例：当0时刻P1到达，1时刻 P2 到达，此时 P1 的剩余时间就变为 7 P2 剩余时间少于 P1 故优先运行 P2，依次类推直至进程全部运行完成</p><ul><li>SJF&#x2F;SRTF算法分析<ul><li>该算法总是将短进程移到长进程之前执行，因此平均等待时间 最小，该算法被证明是最优的。</li><li>饥饿现象：长进程可能长时间无法获得CPU</li><li>该算法需要事先知道进程所需的CPU时间，预测一个进程的CPU时间并非易事</li></ul></li><li>优缺点<ul><li>优化了响应时间(+)</li><li>难以预测作业CPU时间(-)</li><li>不公平算法(-)</li></ul></li></ul><h3 id="优先级调度-PRIORITY"><a href="#优先级调度-PRIORITY" class="headerlink" title="优先级调度(PRIORITY)"></a>优先级调度(PRIORITY)</h3><ul><li><p>优先级通常为固定区间的数字，如[0, 10]：</p><ul><li>数字大小与优先级高低的关系在不同系统中实现不一样，以 Linux为例，0为最高优先级。 </li><li>调度策略：下一次调度总是选择优先级最高的进程。</li><li>SJF是优先级调度的一个特例。</li><li>优先级调度可以是抢占式，也可以是非抢占式。</li></ul></li><li><p>优先级的定义</p><ul><li>静态优先级<ul><li>优先级保持不变，但会出现不公平(饥饿)现象</li></ul></li><li>动态优先级（退化Aging）<ul><li>根据进程占用CPU时间：当进程占有CPU时间愈长，则慢慢降低它的优先级</li><li>根据进程等待CPU时间：当进程在就绪队列中等待时间愈长，则慢慢提升它的优先级</li></ul></li></ul></li><li><h3 id="优先级调度-PRIORITY-1"><a href="#优先级调度-PRIORITY-1" class="headerlink" title="优先级调度(PRIORITY)"></a>优先级调度(PRIORITY)</h3><ul><li>优先级通常为固定区间的数字，如[0, 10]：<ul><li>数字大小与优先级高低的关系在不同系统中实现不一样，以 Linux为例，0为最高优先级。 </li><li>调度策略：下一次调度总是选择优先级最高的进程。</li><li>SJF是优先级调度的一个特例。</li><li>优先级调度可以是抢占式，也可以是非抢占式。</li></ul></li><li>优先级的定义<ul><li>静态优先级<ul><li>优先级保持不变，但会出现不公平(饥饿)现象</li></ul></li><li>动态优先级（退化Aging）<ul><li>根据进程占用CPU时间：当进程占有CPU时间愈长，则慢慢降低它的优先级</li><li>根据进程等待CPU时间：当进程在就绪队列中等待时间愈长，则慢慢提升它的优先级</li></ul></li></ul></li></ul></li></ul><p>在linux中每个线程中存在一个控制该线程属性的结构体，<code>struct pthread_attr_t</code>，也就是pthread_create函数的第二个参数的所指值，线程属性在使用时要使用<code>pthread_attr_init</code>初始化，使用完之后<code>pthread_attr_destory</code>销毁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line">   <span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;   </span><br><span class="line"><span class="comment">/*pthread_attr_init之后，pthread_t结构所包含的内容就是操作系统实现</span></span><br><span class="line"><span class="comment">   支持的线程所有属性的默认值。</span></span><br><span class="line"><span class="comment">   如果pthread_attr_init实现时为属性对象分配了动态内存空间，</span></span><br><span class="line"><span class="comment">   pthread_attr_destroy还会用无效的值初始化属性对象，因此如果经</span></span><br><span class="line"><span class="comment">   pthread_attr_destroy去除初始化之后的pthread_attr_t结构被</span></span><br><span class="line"><span class="comment">   pthread_create函数调用，将会导致其返回错误。*/</span></span><br></pre></td></tr></table></figure><p>线程属性其结构体为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">int</span>                           detachstate;    线程的分离状态</span><br><span class="line">       <span class="type">int</span>                           schedpolicy;   *线程调度策略 </span><br><span class="line">       <span class="keyword">struct</span> <span class="title class_">sched_param</span>      schedparam;           线程的调度参数</span><br><span class="line">       <span class="type">int</span>                          inheritsched;    线程的继承性</span><br><span class="line">       <span class="type">int</span>                          scope;          *线程的作用域</span><br><span class="line">       <span class="type">size_t</span>                       guardsize;       线程栈末尾的警戒缓冲区大小</span><br><span class="line">       <span class="type">int</span>                          stackaddr_set;   </span><br><span class="line">       <span class="type">void</span> *                     stackaddr;         线程栈的位置</span><br><span class="line">       <span class="type">size_t</span>                      stacksize;        线程栈的大小</span><br><span class="line">&#125;<span class="type">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure><p>分离状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">我们已经在前面已经知道，在默认情况下线程是非分离状态的，这种情况   </span><br><span class="line">下，原有的线程等待创建的线程结束。只有当pthread_join() 函数返回       </span><br><span class="line">时，创建的线程才算终止，才能释放自己占用的系统资源。   </span><br><span class="line">   </span><br><span class="line">分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，</span><br><span class="line">马上释放系统资源。</span><br><span class="line">   </span><br><span class="line">通俗的说也就是：我们知道一般我们要等待(pthread_join)一个线程的结束，</span><br><span class="line">主要是想知道它的结束状态，否则等待一般是没有什么意义的！但是<span class="keyword">if</span>有一</span><br><span class="line">些线程的终止态我们压根就不想知道，那么就可以使用“分离”属性，那么我</span><br><span class="line">们就无须等待管理，只要线程自己结束了，自己释放src就可以咯！这样更</span><br><span class="line">方便！</span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> * attr, <span class="type">int</span> * detachstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> * attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line">参数：attr:线程属性变量</span><br><span class="line">        detachstate:分离状态属性   </span><br><span class="line">若成功返回<span class="number">0</span>，若失败返回<span class="number">-1</span>。</span><br><span class="line">   </span><br><span class="line">设置的时候可以有两种选择：</span><br><span class="line">&lt;<span class="number">1</span>&gt;.detachstate参数为：PTHREAD_CREATE_DETACHED     分离状态启动</span><br><span class="line">&lt;<span class="number">2</span>&gt;.detachstate参数为：PTHREAD_CREATE_JOINABLE    正常启动线程</span><br></pre></td></tr></table></figure><p>线程的作用域：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">函数pthread_attr_setscope和pthread_attr_getscope分别</span><br><span class="line">用来设置和得到线程的作用域。       </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>   </span></span><br><span class="line"><span class="type">int</span>    <span class="title function_">pthread_attr_getscope</span><span class="params">( <span class="type">const</span> <span class="type">pthread_attr_t</span> * attr, <span class="type">int</span> * scope )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setscope</span><span class="params">( <span class="type">pthread_attr_t</span>*, <span class="type">int</span> scope )</span>;</span><br><span class="line">参数：</span><br><span class="line">        attr               线程属性变量</span><br><span class="line">        scope         线程的作用域       </span><br><span class="line">若成功返回<span class="number">0</span>，若失败返回<span class="number">-1</span>。</span><br><span class="line">   </span><br><span class="line">作用域控制线程是否在进程内或在系统级上竞争资源，可能的值是</span><br><span class="line">PTHREAD_SCOPE_PROCESS  （进程内竞争资源）</span><br><span class="line">PTHREAD_SCOPE_SYSTEM   （系统级竞争资源）linux中默认，这是由linux的线程模型为<span class="number">1</span>：<span class="number">1</span>模型决定的·</span><br></pre></td></tr></table></figure><p>调度策略及优先级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">        函数pthread_attr_setschedpolicy和pthread_attr_getschedpolicy分别用</span><br><span class="line">        来设置和得到线程的调度策略。</span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> <span class="title function_">pthread_attr_getschedpolicy</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *, <span class="type">int</span> * policy)</span></span><br><span class="line">        <span class="type">int</span> <span class="title function_">pthread_attr_setschedpolicy</span><span class="params">(pthread_attr_*, <span class="type">int</span> policy)</span></span><br><span class="line">        参数：</span><br><span class="line">                attr            线程属性变量</span><br><span class="line">                policy        调度策略   </span><br><span class="line">        若成功返回0，若失败返回-1。</span><br><span class="line">       </span><br><span class="line">        所谓调度策略也就是我们之前在OS中所学过的那些调度算法：</span><br><span class="line">        SCHED_FIFO    ：先进先出</span><br><span class="line">        SCHED_RR       ：轮转法</span><br><span class="line">        SCHED_OTHER    ：其他方法</span><br><span class="line">       </span><br><span class="line">        SCHED_OTHER是不支持优先级使用的,而SCHED_FIFO和SCHED_RR</span><br><span class="line">        支持优先级的使用,他们分别为1和99,数值越大优先级越高.</span><br><span class="line">       </span><br><span class="line">        注意：</span><br><span class="line">                &gt; 此处的SCHED_FIFO是允许被高优先级抢占的！</span><br><span class="line">                &gt; 也就是有高优先级的必须先运行</span><br><span class="line">                &gt; SCHED_RR是设置一个时间片</span><br><span class="line">                &gt; 当有SCHED_FIFO或SCHED_RR策赂的线程在一个条件变量</span><br><span class="line">                上等持或等持加锁同一个互斥量时，它们将以优先级顺序被唤</span><br><span class="line">                醒。即，如果一个低优先级的SCHED_FIFO线程和一个高优先</span><br><span class="line">                织的SCHED_FIFO线程都在等待锁相同的互斥且，则当互斥量</span><br><span class="line">                被解锁时，高优先级线程将总是被首先解除阻塞。</span><br><span class="line">               </span><br><span class="line">&lt;2&gt;.调度参数：</span><br><span class="line">       </span><br><span class="line">        函数pthread_attr_getschedparam 和pthread_attr_setschedparam分别</span><br><span class="line">        用来设置和得到线程的调度参数。</span><br><span class="line">  </span><br><span class="line">        <span class="type">int</span> <span class="title function_">pthread_attr_getschedparam</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *,<span class="keyword">struct</span></span></span><br><span class="line"><span class="params">        sched_param *)</span>;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">pthread_attr_setschedparam</span><span class="params">(<span class="type">pthread_attr_t</span> *,<span class="type">const</span> <span class="keyword">struct</span></span></span><br><span class="line"><span class="params">        sched_param *)</span>;</span><br><span class="line">        参数：</span><br><span class="line">                attr            线程变量属性</span><br><span class="line">                param        sched_parm 结构体</span><br><span class="line">        若成功返回<span class="number">0</span>，若失败返回<span class="number">-1</span>。</span><br><span class="line">       </span><br><span class="line">        /usr/include /bits/sched.h</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">               <span class="type">int</span> sched_priority;    <span class="comment">//!&gt; 参数的本质就是优先级</span></span><br><span class="line">        &#125;;</span><br><span class="line">        注意：大的权值对应高的优先级!</span><br><span class="line">        系统支持的最大和最小的优先级值可以用函数：</span><br><span class="line">        sched_get_priority_max和sched_get_priority_min得到！</span><br><span class="line">       </span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">        <span class="type">int</span> <span class="title function_">sched_get_priority_max</span><span class="params">( <span class="type">int</span> policy )</span>;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">sched_get_priority_min</span><span class="params">( <span class="type">int</span> policy )</span>;</span><br><span class="line">        参数：max_：    系统支持的优先级的最小值</span><br><span class="line">                min_ ：    系统支持的优先级的最大值</span><br><span class="line">       </span><br><span class="line">        使用：max_ = sched_get_priority_max( policy );</span><br><span class="line">                min_ = sched_get_priority_min( policy );</span><br><span class="line">                注意参数是policy调用策略，也就是说对于不同的策略的值是不</span><br><span class="line">                一样的！</span><br><span class="line">   </span><br><span class="line">       </span><br><span class="line">        policy = SCHED_OTHER</span><br><span class="line">        max_priority = <span class="number">0</span></span><br><span class="line">        min_priority = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">        Show SCHED_FIFO of priority</span><br><span class="line">        max_priority = <span class="number">99</span></span><br><span class="line">        min_priority = <span class="number">1</span></span><br><span class="line">       </span><br><span class="line">        Show SCHED_RR of priority</span><br><span class="line">        max_priority = <span class="number">99</span></span><br><span class="line">        min_priority = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>调度策略可以分为两种</p><ul><li><p>normal scheduling：对应的调度策略schedpolicy的取值为<code>SCHED_OTHERSCHED_IDLESCHED_TATCH</code>，此状态下对应的优先级schedparam均为0</p></li><li><p>real scheduling：对应的调度策略schedpolicy取值为<code>SCHED_FIFOSCHED_RR</code>，此状态下对应的优先级schedparam位于 1 - 99之间，数值越低意味着优先级越低</p></li></ul><p>我们自己创建进程的调度策略大多均为<code>SCHED_OTHER</code>模式，这种也遵循时间片轮转的策略，但要注意它位于normal，一旦由real sheduling的进程normal sheduling要让出CPU</p><p>在linux终端中查看进程的优先级</p><p>方法一：</p><blockquote><p>top命令，注意观察 PR 和 NI(nice)友好值</p><p>PR值越小所代表的优先级越高(与线程属性中的优先级相反)，NI的取值范围(-20，19)，当取值为 0 意味着这是一个普通线程，PR &#x3D; 20 + NI(PR值在normal进程中范围为(0 , 39)，NI值仅对normal有效)，当PR值为负数或者rt)时，意味着该线程为实时线程。对于real scheduling 线程 PR &#x3D; -1 - priority_value(优先级)</p></blockquote><p>方法二：</p><blockquote><p>chrt命令 -p + pid</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">:/mnt/c/Users/satellite<span class="variable">$sudo</span> chrt -p 7</span></span><br><span class="line">pid 7&#x27;s current scheduling policy: SCHED_OTHER</span><br><span class="line">pid 7&#x27;s current scheduling priority: 0     //优先级</span><br></pre></td></tr></table></figure><p>chrt命令也可以用来设置调度策略</p></blockquote><p>参考：<a href="https://www.bilibili.com/video/BV1bf4y147PZ">https://www.bilibili.com/video/BV1bf4y147PZ</a><br><a href="https://www.jianshu.com/p/7bf93be5a1b0">https://www.jianshu.com/p/7bf93be5a1b0</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> oprating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sychronization(同步)</title>
      <link href="/2024/10/23/6.Synchronization/"/>
      <url>/2024/10/23/6.Synchronization/</url>
      
        <content type="html"><![CDATA[<h1 id="Synchronization（同步）"><a href="#Synchronization（同步）" class="headerlink" title="Synchronization（同步）"></a>Synchronization（同步）</h1><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="并发进程-x2F-线程"><a href="#并发进程-x2F-线程" class="headerlink" title="并发进程&#x2F;线程"></a>并发进程&#x2F;线程</h3><ul><li>在内存中同时存在的若干个进程&#x2F;线程，由操作系统的调度程序采用适当的策略将他(们)调度至CPU(s)上运行，同时维护他们的状态队列。 <ul><li>在内存中同时存在的若干个进程&#x2F;线程，由操作系统 的调度程序采用适当的策略将他(们)调度至CPU(s)上 运行，同时维护他们的状态队列。 </li><li>从微观上看，他们的运行过程是走走停停；</li><li>并发的进程&#x2F;线程之间是交替执行（Interleaving）。</li></ul></li></ul><h3 id="并发进程之间的关系"><a href="#并发进程之间的关系" class="headerlink" title="并发进程之间的关系"></a>并发进程之间的关系</h3><ul><li>独立关系：并发进程分别在自己的变量集合上运行</li><li>交互关系：并发进程执行过程中需要共享或是交换数据，交互的并发进程之间又存在着竞争和协作的关系</li></ul><blockquote><p>这里就不做竞争与协作的笔记了</p></blockquote><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><ul><li>Asynchronous means RANDOM!(异步就意味这随机)</li><li>会引发竞争条件（Race Condition）：一种这样的情况： 多个进程并发操作同一个数据导致执行结果依赖于特定的进程执行顺序。若不加以控制的话有可能引发错误</li></ul><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><ul><li>Process Synchronization means a mechanism(机制) to  maintain(维护) the consistency(一致性) of data shared in cooperative(竞争)  processes.</li><li>Synchronization Tool Kits(套件)<ul><li>Mutex lock：常用于解决竞争问题</li><li>Semaphore(信号量)：常用于解决协作问题</li></ul></li></ul><p>参考：<a href="https://www.bilibili.com/video/BV1bf4y147PZ">https://www.bilibili.com/video/BV1bf4y147PZ</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> oprating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mutex locks</title>
      <link href="/2024/10/23/7.mutex%20locks/"/>
      <url>/2024/10/23/7.mutex%20locks/</url>
      
        <content type="html"><![CDATA[<h1 id="Mutex-locks"><a href="#Mutex-locks" class="headerlink" title="Mutex locks"></a>Mutex locks</h1><p>​</p><h2 id="critical-section-problem-临界区问题"><a href="#critical-section-problem-临界区问题" class="headerlink" title="critical-section problem (临界区问题)"></a>critical-section problem (临界区问题)</h2><h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><ul><li>Each concurrent(并发的) process has a segment of code, called a  critical section(临界区), in which the process may be changing  common(共有的) variables, updating a table, writing a file, and so on.</li><li>The important feature(特征) of the system is that, when one  process is executing in its critical section, no other process is  allowed to execute in its critical section. That is(换句话说), NO two  processes are executing in their critical sections at the same  time.</li><li>The critical-section problem is to design a protocol(协议) that the  processes can use to cooperate(协作).</li></ul><h3 id="进程进出临界区协议"><a href="#进程进出临界区协议" class="headerlink" title="进程进出临界区协议"></a>进程进出临界区协议</h3><p>伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">entry secion</span><br><span class="line">critical section</span><br><span class="line">exit section</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入临界区前在 entry section 要请求许可</li><li>离开临界区后在exit section 要归还许可</li></ul><h3 id="临界区管理准则"><a href="#临界区管理准则" class="headerlink" title="临界区管理准则"></a>临界区管理准则</h3><ul><li>Mutual(相互的) exclusion(排他的) (Mutex)：互斥</li><li>Progress：前进</li><li>Bounded waiting：有限等待</li></ul><p>只有一个进程可以进入到临界区，一个进程不可以无限的待在临界区当中</p><p>秘籍：</p><blockquote><p>有空让进，泽一而入，无空等待，有限等待，让权等待</p></blockquote><h2 id="mutex-lock互斥锁"><a href="#mutex-lock互斥锁" class="headerlink" title="mutex lock互斥锁"></a>mutex lock互斥锁</h2><h3 id="define-1"><a href="#define-1" class="headerlink" title="define"></a>define</h3><ul><li>Operating-systems designers build software tools to  solve the critical-section problem. The simplest(最简单的) of  these tools is the mutex lock.</li><li>A process must acquire(获得) the lock before entering a critical  section;</li><li>It must release(释放) the lock when it exits the critical section</li></ul><h3 id="锁的基本操作"><a href="#锁的基本操作" class="headerlink" title="锁的基本操作"></a>锁的基本操作</h3><ul><li>lock：测试一把锁是否已经上锁，若未上锁则上锁，若以上锁则等待</li><li>unlock：解锁</li><li>lock 与 unlock 均为原子操作(不能被打断)</li></ul><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><ul><li>Atomic operations mean the operation can NOT be  interrupted while it’s running.</li><li>原子操作（原语）是操作系统重要的组成部分，下面2条(大多数)硬件指令都是原子操作，它们可以被用来实现对临界区的管理（也就是“锁”）。<br>test_and_set()<br>compare_and_swap()</li></ul><h3 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h3><p>test_and_set实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">test_and_set函数的过程:(这里用C语言的方式解释，但实际上它是一条原语)</span><br><span class="line"><span class="type">bool</span> <span class="title function_">test_and_set</span><span class="params">(<span class="type">bool</span> *target)</span>   <span class="comment">//将传入参数的所指值值为false，并返回传入参数的所指值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> result = *target;</span><br><span class="line">*target = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">锁的实现：</span><br><span class="line"><span class="type">bool</span> available = <span class="literal">true</span>;    <span class="comment">//lock和unlock共享的资源，初始化为 1 表示被占用</span></span><br><span class="line">lock()&#123;    </span><br><span class="line"><span class="keyword">while</span>(!test_and_set(&amp;available))   <span class="comment">//循环等待共享变量置为true</span></span><br><span class="line"><span class="keyword">do</span> nothing</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// .... 临界区</span></span><br><span class="line">unlock()</span><br><span class="line">&#123;</span><br><span class="line">available = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="忙式等待（BUSY-WAITING）"><a href="#忙式等待（BUSY-WAITING）" class="headerlink" title="忙式等待（BUSY WAITING）"></a>忙式等待（BUSY WAITING）</h3><ul><li>忙式等待是指占用CPU执行空循环实现等待，解决方法是让进程加入到等待队列中，避免消耗CPU</li><li>这种类型的互斥锁也被称为“自旋锁”(spin lock)<ul><li>缺点：浪费CPU周期，可以将进程插入等待队列以让出CPU 的使用权；</li><li>优点：进程在等待时没有上下文切换，对于使用锁时间不长的进程，自旋锁还是可以接受的；在多处理器系统中， 自旋锁的优势更加明显，因为可以实现在一个核心上自旋其他核心运算</li></ul></li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">int</span> ticketAmount = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">ticketMmount</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lock);</span><br><span class="line">    <span class="type">int</span> t = ticketAmount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;One ticket sold\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Ticket sold out\n&quot;</span>);</span><br><span class="line">    ticketAmount = t;</span><br><span class="line">    pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tichetAgent_tid[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(tichetAgent_tid + i,<span class="literal">NULL</span>,ticketMmount,<span class="literal">NULL</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tichetAgent_tid[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.bilibili.com/video/BV1bf4y147PZ">https://www.bilibili.com/video/BV1bf4y147PZ</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> oprating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步问题</title>
      <link href="/2024/10/23/9.%E7%95%AA%E5%A4%96%20%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2024/10/23/9.%E7%95%AA%E5%A4%96%20%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="同步问题案例"><a href="#同步问题案例" class="headerlink" title="同步问题案例"></a>同步问题案例</h1><h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>问题描述：</p><blockquote><p>有两组并发进程：读者和写者，共享一个文件F，要求:<br>（1）允许多个读者同时执行读操作<br>（2）任一写者在完成写操作之前不允许其它读者或写者工作<br>（3）写者执行写操作前，应让已有的写者和读者全部退出</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">semapore rw = <span class="number">1</span>;   <span class="comment">//控制读者和写者同时操作文件,当有写者时加锁，当有第一个读者时加锁（之后只允许读者访问）</span></span><br><span class="line">semapore mutex = <span class="number">1</span>;  <span class="comment">//控制多个写者控制文件</span></span><br><span class="line"><span class="type">int</span> reader_count = <span class="number">0</span>;  <span class="comment">//记录当前的读者数量</span></span><br><span class="line">Reader&#123;</span><br><span class="line">P(mutex);</span><br><span class="line"><span class="keyword">if</span>(reader_count++ == <span class="number">0</span>)   <span class="comment">//如果这是第一个读者，就加锁</span></span><br><span class="line">&#123;</span><br><span class="line">P(rw);</span><br><span class="line">&#125;</span><br><span class="line">V(mutex);</span><br><span class="line"><span class="comment">//执行读操作</span></span><br><span class="line"></span><br><span class="line">P(mutex);</span><br><span class="line"><span class="keyword">if</span>(reader_count-- == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">V(rw);</span><br><span class="line">&#125;</span><br><span class="line">V(mutex);</span><br><span class="line">&#125;</span><br><span class="line">Writer&#123;</span><br><span class="line">P(rw);</span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">V(rw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当写者加锁成功其余写者与读者均不能加锁，当读者加锁成功，其他读者可以继续执行，但写者无法加锁</p><h2 id="理发师问题"><a href="#理发师问题" class="headerlink" title="理发师问题"></a>理发师问题</h2><p><img src="/img/oprating_system/Snipaste_2023-05-11_13-08-22.png"></p><blockquote><ul><li>理发店有一位理发师、一把理发椅和N把供等候理发的顾客坐的椅子</li><li>如果没有顾客，理发师便在理发椅上睡觉</li><li>一个顾客到来时，他必须叫醒理发师</li><li>如界理发师正在理发时又有顾客来到，则如果有空椅子可坐，就坐下来等待，否则就离开</li><li>使用PV操作求解该问题</li></ul></blockquote><p>初始条件，没有顾客，理发师在休息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semapore customer = <span class="number">0</span>;</span><br><span class="line">semapore barber = <span class="number">1</span>;</span><br><span class="line">semapore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> waiting = <span class="number">0</span>;  <span class="comment">//等待的人数</span></span><br><span class="line">chair_count = max;</span><br><span class="line">Barber&#123;</span><br><span class="line">P(customer);</span><br><span class="line">P(mutex); waiting--; V(mutex);</span><br><span class="line"><span class="comment">//执行理发</span></span><br><span class="line">V(barber);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customer&#123;</span><br><span class="line">P(mutex);</span><br><span class="line"><span class="keyword">if</span>(waiting &lt;= max) </span><br><span class="line">&#123;</span><br><span class="line">waiting++;</span><br><span class="line">V(mutex);</span><br><span class="line">P(barber);   <span class="comment">//等待理发师   </span></span><br><span class="line">V(customer);  </span><br><span class="line"><span class="comment">//被理发</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">V(mutex);</span><br><span class="line"><span class="comment">//leaving,椅子已经坐满了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><p><img src="/img/oprating_system/Snipaste_2023-05-11_21-02-26.png"></p><p>有 5 个哲学家，他们面前都有一双筷子，即左手有一根筷子，右手有一根筷子。当然，这个问题有多个版本的描述，可以说是筷子，也可以说是一刀一叉，因为吃牛排的时候，需要刀和叉，缺一不可，也有说是用两把叉子来吃意大利面。这里具体是刀叉还是筷子并不重要，重要的是<strong>必须要同时持有左右两边的两个才行</strong>，也就是说，哲学家左手要拿到一根筷子，右手也要拿到一根筷子，在这种情况下哲学家才能吃饭。为了方便理解，我们选取和我国传统最贴近的筷子来说明这个问题。</p><p>我们来看一下哲学家就餐的主流程。哲学家如果想吃饭，他会先尝试拿起左手的筷子，然后再尝试拿起右手的筷子，如果某一根筷子被别人使用了，他就得等待他人用完，用完之后他人自然会把筷子放回原位，接着他把筷子拿起来就可以吃了（不考虑卫生问题）。这就是哲学家就餐的最主要流程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">semaghore chopstick[5] = &#123;1&#125;;  //初始状态均为空闲状态</span><br><span class="line">philospher_i&#123;</span><br><span class="line">//Thinking</span><br><span class="line">P(choptick[i]);</span><br><span class="line">P((chopstick[i+1)%5])</span><br><span class="line">//eating</span><br><span class="line">V(choptick[i]);</span><br><span class="line">V((chopstick[i+1)%5])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上有问题的，当每个哲学家都拿到其左边的筷子，这样死锁就产生了，具体将在下一节给出死锁的解决方案</p><p>参考：<a href="https://www.bilibili.com/video/BV1bf4y147PZ/?p=18">https://www.bilibili.com/video/BV1bf4y147PZ/?p=18</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> oprating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Semaphores (信号量)</title>
      <link href="/2024/10/23/8.Semaphores/"/>
      <url>/2024/10/23/8.Semaphores/</url>
      
        <content type="html"><![CDATA[<h1 id="Semaphores"><a href="#Semaphores" class="headerlink" title="Semaphores"></a>Semaphores</h1><p><img src="/img/oprating_system/Snipaste_2023-05-10_13-29-41.png"></p><p>注意：竞争属于协作，竞争是协作的特例，因此使用信号量可以解决竞争关系</p><h2 id="信号量与PV操作"><a href="#信号量与PV操作" class="headerlink" title="信号量与PV操作"></a>信号量与PV操作</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul><li>信号量（Semaphore）是一种比互斥锁更强大的同步工具，它可以提供更高级的方法来同步并发进程。</li><li>A semaphore S is an integer(整数) variable that, apart from  initialization, is accessed only through two standard  atomic operations: P (proberen(测试) in Dutch) and  V(verhogen(增加) in Dutch).<br>信号量 S 是一个整数变量，除了在初始化之外，信号量S被访问只能依靠两个<strong>原子操作</strong> P 和 V</li></ul><h3 id="信号量的实现"><a href="#信号量的实现" class="headerlink" title="信号量的实现"></a>信号量的实现</h3><p>伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">P(s)&#123;   <span class="comment">//测试信号量是否大于0，若大于0，执行自减操作</span></span><br><span class="line"><span class="keyword">while</span>(s&lt;=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">do</span> nothing;</span><br><span class="line">s--; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V(s)&#123;   <span class="comment">//使信号量增加</span></span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h2><p>P V 操作必须成对出现</p><h3 id="BINARY-SEMAPHORE"><a href="#BINARY-SEMAPHORE" class="headerlink" title="BINARY SEMAPHORE"></a>BINARY SEMAPHORE</h3><ul><li>顾名思义，二值信号量的值只能是0或1，通常将其初始化为1，<strong>用于实现互斥锁的功能</strong>。</li></ul><p>伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">semphore mutex = <span class="number">1</span>;</span><br><span class="line">process p&#123;</span><br><span class="line">p(mutex);            <span class="comment">//在 binary semaphore 中等价于 mutex 中的 lock</span></span><br><span class="line"><span class="comment">//critical section</span></span><br><span class="line">v(mutex);            <span class="comment">// unlock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="COUNTIING-SEMAPHORE"><a href="#COUNTIING-SEMAPHORE" class="headerlink" title="COUNTIING  SEMAPHORE"></a>COUNTIING  SEMAPHORE</h3><ul><li>计数信号量又称一般信号量，其取值可以是任意数值，用于控制并发 进程对共享资源的访问。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">semaphore road = <span class="number">2</span>;</span><br><span class="line">process Car&#123;</span><br><span class="line">P(road);</span><br><span class="line"><span class="comment">//pass the fork in road;</span></span><br><span class="line">V(road);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/oprating_system/Snipaste_2023-05-10_14-40-07.png"></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><blockquote><p>要使用信号量，请先包含头文件 semaphore.h</p><p>sem_t：信号量的数据类型</p><p><code>int sem_init(sem_t *sem, int pshared, unsigned int  val); </code><br>该函数第一个参数为信号量指针，第二个参数为信号量 类型（一般设置为0），第三个为信号量初始值。第二 个参数<code>pshared</code>为0时，该进程内所有线程可用，不为0 时不同进程间可用。 </p><p><code>int sem_wait(sem_t *sem);</code><br>该函数申请一个信号量，当前无可用信号量则等待，有可用信号量时占用一个信号量，对信号量的值减1。(相当于 P 操作)</p><p><code>int sem_post(sem_t *sem); </code><br>该函数释放一个信号量，信号量的值加1。 (相当于 V 操作)</p><p><code>int sem_destory(sem_t *sem);</code><br>该函数用于销毁信号量</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tickAmount = <span class="number">2</span>;</span><br><span class="line"><span class="type">sem_t</span> sem;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">ticketAgent</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    sem_wait(&amp;sem);</span><br><span class="line">    <span class="type">int</span> t = tickAmount;</span><br><span class="line">    <span class="keyword">if</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;One ticket sold\n&quot;</span>);</span><br><span class="line">        t--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ticket sold out\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tickAmount = t;</span><br><span class="line">    sem_post(&amp;sem);</span><br><span class="line">    pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_init(&amp;sem,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="type">pthread_t</span> arr[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(arr+i,<span class="literal">NULL</span>,ticketAgent,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        pthread_join(arr[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_destroy(&amp;sem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/oprating_system/Snipaste_2023-05-10_16-31-45.png"></p><h2 id="信号量实现同步"><a href="#信号量实现同步" class="headerlink" title="信号量实现同步"></a>信号量实现同步</h2><ul><li>同步问题实质是将异步的并发进程按照某种顺序执行</li><li>解决同步的本质就是要找到并发进程的交互点，利用P操作的等待特点来调节进程的执行速度</li><li>通常初始值为0的信号量可以让进程直接进行等待状态，直到另一个进程唤醒他。</li></ul><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><ul><li>生产者(P)与消费者(C)共用一个缓冲区，生产者不能往 “满”的缓冲区中放产品，消费者不能从“空”的缓冲区中取产品。</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-10_17-15-28.png"></p><p>使用信号量实现：当开始执行时假定<code>BUFFER</code>为空，那么 P 可以执行 C 不能执行，显然有两个控制流，故需要两个信号量来实现同步，因为 C 在程序开始时要等待，故将控制 C 的信号量初始值设为 0，当<code>BUFFER</code>满时，P将不能工作(进入忙式等待)，等实现等待的只有 P操作 ，所以将控制 P 的信号量初始值设为 BUFFER 的大小，对 P 进程执行 P操作时会使得对应的信号量减1，之后要通知 C进程，使用 V(C进程的信号量)通知C进程，C进程在 P操作后会使信号量减1，之后要通知 P进程，V(P进程的信号量)</p><h4 id="单缓冲解决方案"><a href="#单缓冲解决方案" class="headerlink" title="单缓冲解决方案"></a>单缓冲解决方案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Semaphore empty = <span class="number">1</span>;</span><br><span class="line">Semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Producer&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//product;</span></span><br><span class="line">P(empty);</span><br><span class="line"><span class="comment">//pull the product into buffer</span></span><br><span class="line">V(full);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">P(full);</span><br><span class="line"><span class="comment">//pick product from buffer</span></span><br><span class="line">V(empty);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="THE-BOUNDED-BUFFER-有界缓冲区-PROBLEM"><a href="#THE-BOUNDED-BUFFER-有界缓冲区-PROBLEM" class="headerlink" title="THE BOUNDED-BUFFER(有界缓冲区) PROBLEM"></a>THE BOUNDED-BUFFER(有界缓冲区) PROBLEM</h4><p> <img src="/img/oprating_system/Snipaste_2023-05-10_19-07-54.png"></p><p>OUT：指向消费者使用的位置</p><p>IN：    指向生产者使用的位置</p><p>IN 与 OUT 形成了循环队列，IN 相当于队头（生产者生产后IN前移），OUT相对于队尾（消费者消费后OUT前移），保证 IN &gt;&#x3D; OUT 及生产者生产的大于消费者消费的 </p><p>伪代码： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">item B[k];</span><br><span class="line">semaphore empty = k;</span><br><span class="line">semaphore full = 0;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">int in = 0 , out = 0;</span><br><span class="line">Process producer_i&#123;</span><br><span class="line">make a product</span><br><span class="line">P(empty);</span><br><span class="line">P(mutex);</span><br><span class="line">B[in] = product;     //存在共享数据的修改，加锁</span><br><span class="line">in = (in + 1) % k;</span><br><span class="line">V(mutex);</span><br><span class="line">V(full);</span><br><span class="line">&#125;</span><br><span class="line">Process consumer_i&#123;</span><br><span class="line">P(full);</span><br><span class="line">P(mutex);</span><br><span class="line">product = B[out];     //存在共享数据的修改，加锁</span><br><span class="line">out = (out + 1) % k;</span><br><span class="line">V(mutex);</span><br><span class="line">V(empty);</span><br><span class="line">consume a product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>empty 和 full 的 PV 操作并不在同一进程中，称为同步信号量</li><li>mutex 的 PV操作在同一进程中，称为互斥信号量</li></ul><h3 id="苹果橘子问题"><a href="#苹果橘子问题" class="headerlink" title="苹果橘子问题"></a>苹果橘子问题</h3><p>问题描述：</p><blockquote><p>桌上有一只盘子，每次只能放入一只水果</p><p>爸爸专向盘子中放苹果，妈妈专向盘子中放桔子</p><p>儿子专等吃盘子中的桔子，女儿专等吃盘子里的苹果</p></blockquote><p>这里爸爸 妈妈 相当于时生产者，儿子 女儿相当于是消费者</p><p>father 和 mother 是竞争关系，竞争盘子</p><p>father 和 daughter 是协作关系</p><p>mother 和 sun 是协作关系</p><p>伪代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">semaphore sp = 1;        //盘子里允许放一个水果，竞争关系</span><br><span class="line">semaphore sg1 = 0;       //盘子里没有橘子</span><br><span class="line">semaphore sg2 = 0;       //盘子里没有苹果</span><br><span class="line"></span><br><span class="line">Process father &#123; </span><br><span class="line">削⼀个苹果；</span><br><span class="line"> P(sp);      //占用盘子</span><br><span class="line"> V(sg2);     //把苹果放⼊plate；通知儿子</span><br><span class="line">&#125; </span><br><span class="line">Process mother &#123; </span><br><span class="line">剥⼀个桔⼦；</span><br><span class="line"> P(sp); </span><br><span class="line"> V(sg1);     //把桔⼦放⼊plate；通知女儿</span><br><span class="line">&#125;</span><br><span class="line">Process daughter &#123; </span><br><span class="line"> P(sg2); </span><br><span class="line"> 从plate中取苹果；</span><br><span class="line"> V(sp); </span><br><span class="line">吃苹果；通知生产者可以继续生产了</span><br><span class="line">&#125;</span><br><span class="line">Process son &#123; </span><br><span class="line"> P(sg1); </span><br><span class="line"> 从plate中取桔⼦；</span><br><span class="line"> V(sp); </span><br><span class="line">吃桔⼦；通知生产者可以继续生产了</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>其本质还是生产者消费者模型</p><p>生产者消费者：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 10</span></span><br><span class="line"><span class="type">sem_t</span> sem_empty;           <span class="comment">//生产者所使用的</span></span><br><span class="line"><span class="type">sem_t</span> sem_full;            <span class="comment">//消费者所使用的</span></span><br><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>;  <span class="comment">//表示队列中生产者生产的内存</span></span><br><span class="line"><span class="type">int</span> out = <span class="number">0</span>; <span class="comment">//表示队列中要消费的内容</span></span><br><span class="line"><span class="type">int</span> arr[BUFSIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">prodecer</span><span class="params">(<span class="type">void</span>* arg)</span>  <span class="comment">//生产者线程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;sem_empty);</span><br><span class="line"></span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        arr[in] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;prodecer : %d\n&quot;</span>, in);</span><br><span class="line">        in = (in + <span class="number">1</span>) % BUFSIZE;</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        sem_post(&amp;sem_full);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span>  <span class="comment">//消费者线程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;consumer -------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;sem_full);</span><br><span class="line"></span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;consumer: %d\n&quot;</span>, out);</span><br><span class="line">        out = (out + <span class="number">1</span>) % BUFSIZE;</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        sem_post(&amp;sem_empty);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_init(&amp;sem_empty,<span class="number">0</span>,BUFSIZE);</span><br><span class="line">    <span class="comment">//初始值是BUFSIZE保证了环形队列不会出现尾指针越过头指针的情况发生</span></span><br><span class="line">    sem_init(&amp;sem_full,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> pro[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pthread_t</span> con[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) &#123;</span><br><span class="line">        pthread_create(pro + i, <span class="literal">NULL</span>, prodecer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(con + i, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        pthread_join(con[i],<span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(pro[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;sem_empty);</span><br><span class="line">    sem_destroy(&amp;sem_full);</span><br><span class="line">    sem_destroy(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>苹果橘子问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">plate</span>&#123;</span>apple = <span class="number">1</span>, origen&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sp;   <span class="comment">//父母竞争盘子</span></span><br><span class="line"><span class="type">sem_t</span> sp1;  <span class="comment">//父亲通知女儿</span></span><br><span class="line"><span class="type">sem_t</span> sp2;   <span class="comment">//母亲通知儿子</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">plate</span> <span class="title">plate</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">father</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;sp);</span><br><span class="line">    plate = apple;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father\n&quot;</span>);</span><br><span class="line">    sem_post(&amp;sp1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mother</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;sp);</span><br><span class="line">    plate = origen;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mother\n&quot;</span>);</span><br><span class="line">    sem_post(&amp;sp2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">son</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;sp1);</span><br><span class="line">    plate = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;son\n&quot;</span>);</span><br><span class="line">    sem_post(&amp;sp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">daughter</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;sp2);</span><br><span class="line">    plate = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;daughrer\n&quot;</span>);</span><br><span class="line">    sem_post(&amp;sp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_init(&amp;sp,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;sp1,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;sp2,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> arr1[<span class="number">10</span>] ;</span><br><span class="line">    <span class="type">pthread_t</span> arr2[<span class="number">10</span>] ;</span><br><span class="line">    <span class="type">pthread_t</span> arr3[<span class="number">10</span>] ;</span><br><span class="line">    <span class="type">pthread_t</span> arr4[<span class="number">10</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        pthread_create(arr1+i,<span class="literal">NULL</span>,father,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(arr2+i,<span class="literal">NULL</span>,mother,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(arr3+i,<span class="literal">NULL</span>,son,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(arr4+i,<span class="literal">NULL</span>,daughter,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        pthread_join(arr1[i],<span class="literal">NULL</span>) ;</span><br><span class="line">        pthread_join(arr2[i],<span class="literal">NULL</span>) ;</span><br><span class="line">        pthread_join(arr3[i],<span class="literal">NULL</span>) ;</span><br><span class="line">        pthread_join(arr4[i],<span class="literal">NULL</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;sp);</span><br><span class="line">    sem_destroy(&amp;sp1);</span><br><span class="line">    sem_destroy(&amp;sp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：信号量上下</p>]]></content>
      
      
      
        <tags>
            
            <tag> oprating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决胜网络协议</title>
      <link href="/2024/07/20/%E5%86%B3%E8%83%9C%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/07/20/%E5%86%B3%E8%83%9C%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="序列号回绕"><a href="#序列号回绕" class="headerlink" title="序列号回绕"></a>序列号回绕</h3><p>我们这里假设只有 8位 用来描述<code> tcp</code> 的序列号</p><p>seq1 &#x3D; 255      seq2 &#x3D; 1</p><p>使用减法来判断包的先后顺序 ，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">before</span><span class="params">(__u32 seq1, __u32 seq2)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> (__s32)(seq1-seq2) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> after(seq2, seq1) before(seq1, seq2)</span></span><br></pre></td></tr></table></figure><p>这里就变为了 before(0b1111 , 0b1) -&gt; return 0b1110 &lt; 0 ， 采用了无符号数减法转化为有符号数来粗略的判断，当seq1 和 seq2之间的间距 大于 0xc000 时就无法判断了，就需要使用额外的东西来判断如时间戳</p><h3 id="窗口缩放"><a href="#窗口缩放" class="headerlink" title="窗口缩放"></a>窗口缩放</h3><p>tcp头部中指定了窗口大小，使用了16位，这意味着最大窗口位 64k，由于现代网络传输速度的加快，64k有时不能满足要求，于是在这上面打了补丁也就有了窗口缩放，用窗口大小乘缩放因子得到时机的窗口大小，缩放因子是在三次握手中协商的，如下报文</p><p><img src="/img/Snipaste_2024-07-10_20-12-53.png"></p><p>这里的缩放因子是 256 也就是实际的窗口大小为 516 * 256</p><h4 id="tcp的重要选项"><a href="#tcp的重要选项" class="headerlink" title="tcp的重要选项"></a>tcp的重要选项</h4><p> 在 <code>tcp</code>头部中选项和填充属于可选字段，但也有相当重要的</p><p>MSS: 最大段大小选项 , TCP 允许的从对方接收的最大报文段<br>SACK: 选择确定选项<br>Window Scale: 窗口缩放选项</p><h3 id="临时端口的分配"><a href="#临时端口的分配" class="headerlink" title="临时端口的分配"></a>临时端口的分配</h3><p> 在没有调用 bind 或者 bind 指定的端口号为 0 的时候会采用临时端口号</p><p>tcp协议栈用三个全局的 <code>inet_hash</code> 哈希表</p><ul><li>ehash: 负责有名的 socket，也就是四元组明确的 socket ， key 是源地址 源端口 目的地址 目的端口组成的 ， value 是对应的socket</li><li>bhash: 负责端口分配，key是端口号，value 是使用此端口的所有socket，一个socket 可同时在bhash 和 ehash 中使用</li><li>listening_hash: 负责 listen socket</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_hashinfo</span> &#123;</span></span><br><span class="line"><span class="comment">/* This is for sockets with full identity only.  Sockets here will</span></span><br><span class="line"><span class="comment"> * always be without wildcards and will have the following invariant:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          TCP_ESTABLISHED &lt;= sk-&gt;sk_state &lt; TCP_CLOSE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_ehash_bucket</span>*<span class="title">ehash</span>;</span></span><br><span class="line"><span class="type">spinlock_t</span>*ehash_locks;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>ehash_mask;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>ehash_locks_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ok, let&#x27;s try this, I give up, we do need a local binding</span></span><br><span class="line"><span class="comment"> * TCP hash as well as the others for fast bind/connect.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span>*<span class="title">bind_bucket_cachep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_hashbucket</span>*<span class="title">bhash</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>bhash_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The 2nd listener table hashed by local port and address */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>lhash2_mask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_listen_hashbucket</span>*<span class="title">lhash2</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>inet_ehash_bucket</code> 说是哈希表，实际就是一个数组，数组的每一个元素都是一个 <code>inet_bind_hashbuchet</code> 指针,chain 字段是一个链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_ehash_bucket</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_head</span> <span class="title">chain</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_hashbucket</span> &#123;</span></span><br><span class="line"><span class="type">spinlock_t</span>lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span><span class="title">chain</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_listen_hashbucket</span> &#123;</span></span><br><span class="line"><span class="type">spinlock_t</span>lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_head</span><span class="title">nulls_head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>bind(0) 分配端口：</p><p><img src="/img/Snipaste_2024-07-11_11-50-02.png"></p><p><img src="/img/Snipaste_2024-07-11_14-06-37.png"></p><p>connect 分配端口：</p><p>首先要分配端口，与 bind(0) 不同的是 <code>offset &amp;= ~1</code>，将offset 强制变为偶数之后与low相加检测bhash中是否有相同的 ，之后判断端口是否可用</p><p>对应 bind 端口为 0 时 ，所分配的临时端口是奇数，对应没有 bind 直接 connect ，所分配的端口是偶数</p><blockquote><p>高版本内核临时端口分配策略</p><p>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_local_port_range 文件指定了临时端口号的下界 low 和 上界 high，默认情况下 low 是偶数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@bool:~# cat /proc/sys/net/ipv4/ip_local_port_range </span><br><span class="line">3276860999</span><br></pre></td></tr></table></figure><ul><li>优先给 bind(0) 分配随机的与low奇偶性不同的端口，也就是奇数，如果奇数端口号分配完了才需要尝试分配偶数端口</li><li>优先给 connect 分配随机的与low奇偶性相同的端口，也就是偶数</li></ul></blockquote><p>协议栈端口选择导致的性能衰减：当客户端疯狂 connect 时，1w并发连接和2w并发连接的耗时完全无线性关系，而是呈现一种近指数上升的趋势。例如，1w并发链接建连1w次，耗时不到1s，如果改为2w并发链接，建连2w次，耗时突然变成了10+s。当我们完全占用偶数组的端口后，所有后续的<code>connect</code>调用，所需的源端口应该位于奇数组中，然而该函数依旧会尝试完整遍历偶数组资源，这也就是<code>__inet_check_established</code>耗时占比这么高的原因。简而言之，就是自kernel 4.2开始，端口资源的分配策略改了，目前奇数端口留给<code>bind</code>，偶数端口留给<code>connect</code>为了均衡资源的占用，但是显然，这种策略不适合本文所述的特殊场景，并且对于<code>bind</code>而言，也存在性能衰减的问题。</p><p>为什么 SYN &#x2F; FIN段不携带数据却要消耗一个序列号？</p><ul><li>不占用序列号的段是不需要确认的，比如纯 ACK 包</li><li>SYN 段需要双方确认，需要占用一个序列号，若不进行确认，对端将无法辨别所发出的 SYN 是否已经被收到</li><li>凡是消耗序列号的 TCP 报文段，一定需要对端确认。如果这个段没有收到确认，会一直重传直到达到指定的次数为至</li></ul><h3 id="三次握手冷知识"><a href="#三次握手冷知识" class="headerlink" title="三次握手冷知识"></a>三次握手冷知识</h3><p>通信双方都知道对端开发的端口，同时调用 connect ， 发送 syn 包，双方进入 SYN_SEND 状态，接收到对端传来的 SYN 时进入 SYN_REVD ， 发送 SYN ACK ， 进入 ESTABLISH</p><p><img src="/img/Snipaste_2024-07-12_14-06-24.png"></p><p>TCP 自连接：</p><p>当我们执行这段脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while ture</span><br><span class="line">do </span><br><span class="line">telnet 127.0.0.1 50000</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>过一段时间会出现</p><p><img src="/img/Snipaste_2024-07-12_14-19-31.png"></p><p>原理：</p><p><img src="/img/Snipaste_2024-07-12_14-23-25.png"></p><p>自连接的危害：</p><p>存在业务系统 B会访问本机服务 A ， 服务A监听了 50000 端口</p><ol><li>业务系统B代码中增加了对服务A断开重连的逻辑</li><li>如果有一个服务A挂掉长时间没有启动，业务系统B开始不断的 connect</li><li>系统B经过一段时间的重试就会出现自连接的情况</li><li>这是服务A想要监听50000断开就会出现断开被占用的情况</li></ol><p>自连接的进程占用了端口，导致真正需要监听端口的服务程序无法正常启动，自连接的进程开启了connect成功了，实际上服务是不正常的，无法正常进行数据通信</p><h3 id="四次挥手中的同时关闭"><a href="#四次挥手中的同时关闭" class="headerlink" title="四次挥手中的同时关闭"></a>四次挥手中的同时关闭</h3><p><img src="/img/Snipaste_2024-07-13_00-01-43.png"></p><h3 id="两个队列"><a href="#两个队列" class="headerlink" title="两个队列"></a>两个队列</h3><p>半连接队列(Incomplete connection queue), 又称 SYN 队列<br>全连接队列(Completed connection queue), 又称 Accept 队列</p><p>当客户端发起 SYN 到服务端，服务端收到以后会回 ACK 和⾃⼰的 SYN。这时服务端这边的 TCP 从 listen 状态变为 SYN_RCVD (SYN  Received)，此时会将这个连接信息放⼊半连接队列</p><p><code>int listen(int fd , int backlog)</code></p><p>TCP套接字上的backlog参数的行为在Linux 2.2中发生了变化。现在，它指定等待接受的完全建立的套接字的队列长度，而不是不完整连接请求的数量。不完整套接字队列的最大长度可以使用 <code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code> 设置。当启用同步cookie时，没有逻辑上的最大长度，此设置将被忽略。</p><p>如果backlog参数大于 <code>/proc/sys/net/core/somaxconn</code> 中的值，那么它将被静默地截断为该值。自Linux 5.4以来，此文件中的默认值为4096</p><p>半连接队列的大小和传入的 backlog ， 系统参数 <code>somaxconn</code> ,<code>max_syn_backlog</code> 都有关系，通过其中最小值用于计算，盲目的调大backlog 对最终半连接队列的大小可能不会有影响</p><p>全连接队列包含了服务端所有完成了三次握⼿，但是还未被应⽤取⾛的连接队列。此时的 socket 处于 ESTABLISHED 状态。每次应⽤调⽤ accept() 函数会移除队列头的连接。如果队列为空， accept() 通常会阻塞。全连接队列也被称为 Accept 队列。</p><p>半连接队列满了以后会忽略 SYN<br>全连接队列满了之后会忽略客户端的 ACK，随后重传 SYN + ACK，可以通过 <code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code> 决定</p><ul><li><code>tcp_abort_on_overflow</code> 为 0 表示三次握⼿最后⼀步全连接队列满以后 server 会丢掉 client 发过来的 ACK，服务端随后会进⾏重传 SYN+ACK。</li><li><code>tcp_abort_on_overflow</code> 为 1 表示全连接队列满以后服务端直接 发送 RST 给客户端。</li></ul><p>但是回给客户端 RST 包会带来另外⼀个问题，客户端不知道服务端 响应的 RST 包到底是因为「该端⼝没有进程监听」，还是「该端⼝ 有进程监听，只是它的队列满了」。</p><h3 id="TCP的定时器"><a href="#TCP的定时器" class="headerlink" title="TCP的定时器"></a>TCP的定时器</h3><p><code>tcp</code> 为每条连接建立了 7 个定时器：连接建立定时器，重传定时器，延迟ACK定时器，PERSIST定时器，KEEPALIVE定时器，FINWAIT2定时器，TIME_WAIT定时器 </p><p>Persist 定时器是专⻔为零窗⼝探测⽽准备的。我们都知道 TCP 利⽤滑动窗⼝来实现流量控制，当接收端 B 接收窗⼝为 0 时，发送端 A 此时不 能再发送数据，发送端此时开启 Persist 定时器，超时后发送⼀个特殊的报⽂给接收端看对⽅窗⼝是否已经恢复，这个特殊的报⽂只有⼀个字节。</p><p>四次挥⼿过程中，主动关闭的⼀⽅收到 ACK 以后从 FINWAIT1 进⼊ FINWAIT2 状态等待对端的 FIN 包的到来，FINWAIT2 定时器的作 ⽤是防⽌对⽅⼀直不发送 FIN 包，防⽌⾃⼰⼀直傻等。这个值由 <code>/proc/sys/net/ipv4/tcp_fin_timeout</code> 决定，默认值为 60s</p><p>TIMEWAIT 定时器也称为 2MSL 定时器，可主动关闭连接的⼀⽅在 TIMEWAIT 持续 2 个 MSL 的时间，超时后端⼝号可被安全的重⽤。</p><h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><p>tcp 拥塞控制四大阶段：慢启动 ， 拥塞避免 ， 快速重传 ， 快速恢复</p><p>在连接建⽴之初，你不知道对端有多快，如果有⾜够的带宽，你可以选择⽤最快的速度传输数据，但是如果 是⼀个缓慢的移动⽹络呢？如果发送的数据过多，只是造成更⼤的⽹络延迟。这是基于整 个考虑，每个 TCP 连接都有⼀个拥塞窗⼜的限制，最初这个值很⼩，随着时间的推移， 每次发送的数据量如果在不丢包的情况下，慢慢的递增，这种机制被称为「慢启动」</p><blockquote><p> 第⼀步，三次握⼿以后，双⽅通过 ACK 告诉了对⽅ ⾃⼰的接收窗⼜（rwnd）的⼤⼩，之后就可以互相发 数据了</p><p>第⼆步，通信双⽅各⾃初始化⾃⼰的「拥塞窗⼜」 （Congestion Window，cwnd）⼤⼩</p><p>第三步，cwnd 初始值较⼩时，每收到⼀个 ACK， cwnd + 1，每经过⼀个 RTT，cwnd 变为之前的两 倍。</p></blockquote><p><img src="/img/Snipaste_2024-07-20_14-58-22.png"></p><p>慢启动拥塞窗口（cwnd）肯定不能⽆⽌境的指数级增长下去，否则拥塞控制就变成了「拥塞失控」了，它的阈值称为「慢启动阈值」（Slow Start  Threshold，ssthresh）。<code>ssthresh</code> 就是⼀道刹车，让拥塞窗⼜别涨那么快</p><ul><li>当 cwnd &lt; ssthresh 时，拥塞窗⼜按指数级增长（慢启动）</li><li>当 cwnd &gt; ssthresh 时，拥塞窗⼜按线性增长（拥塞避免），在这个阶段，每⼀ 个往返 RTT，拥塞窗⼜⼤约增加 1 个 MSS ⼤⼩，直到检测到拥塞为⽌</li></ul><p>当收到三次重复 ACK 时，进⼊快速恢复阶段。解释为⽹络轻度拥塞。</p><ul><li>拥塞阈值 ssthresh 降低为 cwnd 的⼀半：ssthresh &#x3D; cwnd &#x2F; 2</li><li>拥塞窗⼜ cwnd 设置为 ssthresh</li><li>拥塞窗⼜线性增加</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> read </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS 与 无锁队列</title>
      <link href="/2024/07/02/10.1%20cas/"/>
      <url>/2024/07/02/10.1%20cas/</url>
      
        <content type="html"><![CDATA[<h1 id="CAS-与-无锁队列"><a href="#CAS-与-无锁队列" class="headerlink" title="CAS 与 无锁队列"></a>CAS 与 无锁队列</h1><p>假设我们有一全局变量 idx ， 在执行 idx++ 时编译器会翻译为三条汇编指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov [idx] , %eax</span><br><span class="line">inc %eax</span><br><span class="line">mov %eax , [idx]</span><br></pre></td></tr></table></figure><p>当三条汇编语句紧挨着执行时，idx++ 是保证正确的，但是当存在多个线程时 idx++ 的正确性就有待考证了如：</p><table><thead><tr><th>线程一</th><th>线程二</th></tr></thead><tbody><tr><td>mov [idx] , %eax</td><td></td></tr><tr><td>inc  %eax</td><td></td></tr><tr><td></td><td>mov [idx] , %eax</td></tr><tr><td></td><td>inc %eax</td></tr><tr><td></td><td>mov %eax , [idx]</td></tr><tr><td>mov %eax , [idx]</td><td></td></tr></tbody></table><p>当线程一和线程二按照这样的方式执行时，虽然在各自的线程中都执行了 idx++ 但是 idx 的结果只增加了一次 , 解决的方法可以是为临界区代码段添加互斥锁或自旋锁，对于互斥锁：当资源已被加锁时将会切换线程而自旋锁不会，自旋锁将在此线程上一直等待直到资源可用为止，二者的选择需要从资源的竞争程度与线程切换的开销方面考虑，这并不是这篇文章的重点，我们要写一个大多数人未知的东西(至少我是这样的)<strong>原子操作</strong></p><h2 id="汇编实现原子操作："><a href="#汇编实现原子操作：" class="headerlink" title="汇编实现原子操作："></a>汇编实现原子操作：</h2><p>“最轻量级的锁”,通常也叫”原子操作”,之所以加引号是因为他们在汇编级别并不是原子操作,是用多条指令完成的,这些操作大多都是利用CPU支持的汇编指令</p><p>最常见的原子操作有Compare and Exchange,Self Increase&#x2F;Decrease等等</p><p><strong>80486 CPU 相关指令：</strong></p><blockquote><p>LOCK:这是一个指令前缀，在所对应的指令操作期间使此指令的<strong>目标操作数指定的存储区域锁定</strong>，以得到保护。</p><p>XADD:先交换两个操作数的值，再进行算术加法操作。多处理器安全，在80486及以上CPU中支持。</p><p>CMPXCHG:比较交换指令，第一操作数先和AL&#x2F;AX&#x2F;EAX比较，如果相等ZF置1，第二操作数赋给第一操作数，否则ZF清0，第一操作数赋给AL&#x2F;AX&#x2F;EAX。多处理器安全，在80486及以上CPU中支持。</p><p>XCHG:交换两个操作数,其中至少有一个是寄存器寻址.其他寄存器和标志位不受影响.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Dump of assembler code for function _Z3incPii:</span></span><br><span class="line"><span class="comment">   0x0000555555555229 &lt;+0&gt;:     endbr64 </span></span><br><span class="line"><span class="comment">   0x000055555555522d &lt;+4&gt;:     push   %rbp</span></span><br><span class="line"><span class="comment">   0x000055555555522e &lt;+5&gt;:     mov    %rsp,%rbp</span></span><br><span class="line"><span class="comment">   0x0000555555555231 &lt;+8&gt;:     mov    %rdi,-0x18(%rbp)</span></span><br><span class="line"><span class="comment">   0x0000555555555235 &lt;+12&gt;:    mov    %esi,-0x1c(%rbp)</span></span><br><span class="line"><span class="comment">   0x0000555555555238 &lt;+15&gt;:    mov    -0x18(%rbp),%rdx</span></span><br><span class="line"><span class="comment">   0x000055555555523c &lt;+19&gt;:    mov    -0x1c(%rbp),%eax</span></span><br><span class="line"><span class="comment">   0x000055555555523f &lt;+22&gt;:    lock xadd %eax,(%rdx)</span></span><br><span class="line"><span class="comment">   0x0000555555555243 &lt;+26&gt;:    mov    %eax,-0x4(%rbp)</span></span><br><span class="line"><span class="comment">   0x0000555555555246 &lt;+29&gt;:    mov    -0x4(%rbp),%eax</span></span><br><span class="line"><span class="comment">   0x0000555555555249 &lt;+32&gt;:    pop    %rbp</span></span><br><span class="line"><span class="comment">   0x000055555555524a &lt;+33&gt;:    ret </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inc</span><span class="params">(<span class="type">int</span> *value , <span class="type">int</span> add)</span> &#123;</span><br><span class="line">    <span class="type">int</span> old;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;lock; xaddl %2 , %1&quot;</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=a&quot;</span> (old)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;m&quot;</span> (*value) , <span class="string">&quot;a&quot;</span> (add)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;cc&quot;</span> , <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在c++中<code>atomic</code>类提供了 <code>cas</code> 原子操作的方法如比较交互<code>std::atomic&lt;T&gt;::compare_exchange_strong</code></p><h2 id="cpu-亲和性"><a href="#cpu-亲和性" class="headerlink" title="cpu 亲和性"></a>cpu 亲和性</h2><p><strong>硬亲和性（affinity）：</strong>简单来说就是利用 <code>linux</code> 内核提供给用户的 <code>API</code>，强行将进程或者线程绑定到某一个指定的 <code>cpu</code> 核运行。</p><p>在 Linux 内核中，所有的进程都有一个相关的数据结构，称为 <code>task_struct</code> <em>。</em>这个结构非常重要，原因有很多；其中与亲和性（affinity）相关度最高的是 <code>cpus_allowed</code> 位掩码。这个位掩码由<code> n</code> 位组成，与系统中的<code>n</code>个逻辑处理器一一对应。 具有 4 个物理 CPU 的系统可以有 4 位。如果这些 CPU 都启用了超线程，那么这个系统就有一个 8 位的位掩码。</p><p>如果为给定的进程设置了给定的位，那么这个进程就可以在相关的 <code>CPU</code> 上运行。因此，如果一个进程可以在任何 <code>CPU</code> 上运行，并且能够根据需要在处理器之间进行迁移，那么位掩码就全是 1。实际上，这就是 Linux 中进程的缺省状态。</p><p>Linux 内核 API 提供了一些方法，让用户可以修改位掩码或查看当前的位掩码：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">#<span class="keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">sched_setaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> cpusetsize , <span class="type">const</span> <span class="type">cpu_set_t</span> *mask)</span>;</span><br><span class="line"><span class="comment">/*sched_setaffinity（）将ID为pid的线程的CPU关联掩码设置为掩码指定的值。  </span></span><br><span class="line"><span class="comment">如果pid为零，则使用调用线程。  参数cpusetsize是掩码指向的数据的长度（字节）。  通常这个参数会被指定为sizeof（cpu_set_t）。*/</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">sched_getaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> cpusetsize , <span class="type">cpu_set_t</span> *mask)</span>;</span><br><span class="line"><span class="comment">/*sched_getaffinity（）将ID为pid的线程的关联掩码写入掩码指向的cpu_set_t结构中。   cpusetsize参数指定掩码的大小（以字节为单位）。  如果pid为零，则返回调用线程的掩码。*/</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_affinity</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;                <span class="comment">// 设置进程 cpu 亲和性</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> tid = <span class="built_in">syscall</span>(__NR_gettid);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;tid : &quot;</span> &lt;&lt; tid &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">cpu_set_t</span> mask;</span><br><span class="line">    <span class="built_in">CPU_ZERO</span>(&amp;mask);</span><br><span class="line">    <span class="built_in">CPU_SET</span>(tid % num , &amp;mask);</span><br><span class="line">    <span class="built_in">sched_setaffinity</span>(tid , <span class="keyword">sizeof</span> mask , &amp;mask);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置了进程的亲和性并不保证进程中创建的新线程在此cpu上运行，只能保证进程中的主线程在cpu上运行</span></span><br><span class="line"><span class="comment">// 本质就是 gettid，在对应cpu上执行对应 tid 的执行流</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_affinity</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;                <span class="comment">// 设置线程 cpu 亲和性</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;tid : &quot;</span> &lt;&lt; tid &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">cpu_set_t</span> mask;</span><br><span class="line">    <span class="built_in">CPU_ZERO</span>(&amp;mask);</span><br><span class="line">    <span class="built_in">CPU_SET</span>(tid % num , &amp;mask);</span><br><span class="line">    <span class="built_in">pthread_setaffinity_np</span>(<span class="built_in">pthread_self</span>() , <span class="keyword">sizeof</span> mask , &amp;mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process_affinity</span>(num);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">sysconf</span>(_SC_NPROCESSORS_CONF);</span><br><span class="line">    std::cout &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;num/<span class="number">2</span> ; ++i) &#123;</span><br><span class="line">        <span class="function">std::thread <span class="title">t</span><span class="params">(func , num)</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">1000000000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>htop</code> 可以看到在 <code>usleep</code> 结束之前有两个 cpu 的占用率是 100% 而其他线程占用几乎为 0，这说明两个线程分别绑定到了两个逻辑核心上</p><p>补充:</p><blockquote><p><code>main</code> 函数结束后相当于调用 <code>exit</code> ，这将导致整个进程结束，意味着其他线程如 detach 后的线程也跟着结束，由于这里尝试多次没有看到希望的效果，当然也可以使用 <code>posix_exit()</code> 令主线程退出，而不影响其他线程</p></blockquote><h2 id="无锁队列-zeromq"><a href="#无锁队列-zeromq" class="headerlink" title="无锁队列(zeromq)"></a>无锁队列(zeromq)</h2><h3 id="为什么需要无锁队列："><a href="#为什么需要无锁队列：" class="headerlink" title="为什么需要无锁队列："></a>为什么需要无锁队列：</h3><blockquote><p>Cache 损坏<br>拿互斥锁来说，采用休眠等待，线程被频繁抢占产生的Cache损坏将导致应用程序性能下降。</p><p>在同步机制上的争抢队列<br>由于锁机制，当资源争取发生的频率很高时，任务将大量的时间 (睡眠，等待，唤醒)浪费在获得保护队列数据的互斥锁，而不是处理队列中的数据上。</p><p>动态内存分配<br>当一个任务从堆中分配内存时，标准的内存分配机制会 阻塞所有与这个任务共享地址空间的其它任务(进程中的所有线程)</p></blockquote><h3 id="提供的原子操作"><a href="#提供的原子操作" class="headerlink" title="提供的原子操作"></a>提供的原子操作</h3><p><code>atom_op.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CAS(a_ptr, a_oldVal, a_newVal) __sync_bool_compare_and_swap(a_ptr, a_oldVal, a_newVal)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AtomicAdd(a_ptr,a_count) __sync_fetch_and_add (a_ptr, a_count)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AtomicSub(a_ptr,a_count) __sync_fetch_and_sub (a_ptr, a_count)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span> <span class="comment">// sched_yield()</span></span></span><br><span class="line"></span><br><span class="line">对应函数原型：</span><br><span class="line"><span class="type">bool</span> __sync_bool_compare_and_swap (T* __p， U __compVal， V __exchVal， ...);</span><br><span class="line">此函数将 __compVal 的值与 __p 指向的变量的值进行比较。 如果它们相等，那么 __exchVal 的值将存储在 __p指定的地址中; 否则，不会执行任何操作,如果 __compVal 的值与 __p 指向的变量的值相等，那么该函数返回 <span class="literal">true</span>; 否则，返回 <span class="literal">false</span>。</span><br><span class="line">T __sync_fetch_and_add ( T * __p , U __v , ...);</span><br><span class="line">该函数以原子方式将__v的值添加到__p指向的变量中。结果存储在__p指定的地址中，该函数返回__p指向的变量的初始值。</span><br></pre></td></tr></table></figure><p><code>atomic_ptr.hpp</code> 中对模板类型参数T的指针提供了原子操作，那其中一条进行分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> T *<span class="title function_">cas</span> <span class="params">(T *cmp_, T *val_)</span>    <span class="comment">// if(cmp == ptr) 则 ptr=val 返回旧值 ， 不相等直接返回ptr</span></span><br><span class="line">&#123;</span><br><span class="line">T *old;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;lock; cmpxchg %2, %3&quot;</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=a&quot;</span> (old), <span class="string">&quot;=m&quot;</span> (ptr)<span class="comment">// 输出操作数：old绑定到EAX寄存器，ptr绑定到内存位置</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;r&quot;</span> (val_), <span class="string">&quot;m&quot;</span> (ptr), <span class="string">&quot;0&quot;</span> (cmp_) <span class="comment">// 输入操作数：val_可以使用任意寄存器，ptr绑定到内存位置，cmp_绑定到EAX寄存器</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;cc&quot;</span>)</span>;   <span class="comment">// 声明修改条件码寄存器</span></span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line"><span class="keyword">volatile</span> T *ptr;</span><br></pre></td></tr></table></figure><h3 id="无锁队列的实现（单读单写）"><a href="#无锁队列的实现（单读单写）" class="headerlink" title="无锁队列的实现（单读单写）"></a>无锁队列的实现（单读单写）</h3><p><strong>yqueue 数据结构</strong></p><p>yqueue是一种高效的队列实现。 主要目标是最大限度地减少所需的分配&#x2F;解除分配次数。 因此，yqueue以N批为单位分配&#x2F;解除分配元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">yqueue_t</span>;</span><br></pre></td></tr></table></figure><p>yqueue 内部是由一个个 chunk_t 组成的，使用双向链表的数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">chunk_t</span></span><br><span class="line">&#123;</span><br><span class="line">    T values[N]; <span class="comment">//每个chunk_t可以容纳N个T类型的元素，以后就以一个chunk_t为单位申请内存</span></span><br><span class="line">    <span class="type">chunk_t</span> *prev;</span><br><span class="line">    <span class="type">chunk_t</span> *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>chunk_t的组织方式</p><p><img src="/img/%E4%BB%8E0%E5%88%B01/Snipaste_2024-06-30_00-50-29.png"></p><p><strong>ypipe</strong></p><p>ypipe_t在yqueue_t的基础上构建一个单写单读的无锁队列</p><p>ypipe内维护的成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">yqueue_t</span>&lt;T, N&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Points to the first un-flushed item. This variable is used</span></span><br><span class="line">    <span class="comment">//  exclusively by writer thread.</span></span><br><span class="line">    T *w; <span class="comment">//指向第一个未刷新的元素,只被写线程使用  要从哪里刷</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Points to the first un-prefetched item. This variable is used</span></span><br><span class="line">    <span class="comment">//  exclusively by reader thread.</span></span><br><span class="line">    T *r; <span class="comment">//指向第一个还没预提取的元素，只被读线程使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Points to the first item to be flushed in the future.</span></span><br><span class="line">    T *f; <span class="comment">//指向下一轮要被刷新的一批元素中的第一个  要刷到哪里</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  The single point of contention between writer and reader thread.</span></span><br><span class="line">    <span class="comment">//  Points past the last flushed item. If it is NULL,</span></span><br><span class="line">    <span class="comment">//  reader is asleep. This pointer should be always accessed using</span></span><br><span class="line">    <span class="comment">//  atomic operations.</span></span><br><span class="line">    <span class="type">atomic_ptr_t</span>&lt;T&gt; c; <span class="comment">//读写线程共享的指针，指向每一轮刷新的起点。当c为空时，表示读线程睡眠（只会在读线程中被设置为空）</span></span><br></pre></td></tr></table></figure><p>构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ypipe_t</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  Insert terminator element into the queue.</span></span><br><span class="line">    queue.<span class="built_in">push</span>(); <span class="comment">//yqueue_t的尾指针加1，开始back_chunk为空，现在back_chunk指向第一个chunk_t块的第一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Let all the pointers to point to the terminator.</span></span><br><span class="line">    <span class="comment">//  (unless pipe is dead, in which case c is set to NULL).</span></span><br><span class="line">    r = w = f = &amp;queue.<span class="built_in">back</span>(); <span class="comment">//就是让r、w、f、c四个指针都指向这个end迭代器</span></span><br><span class="line">    c.<span class="built_in">set</span>(&amp;queue.<span class="built_in">back</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>write  unwrite:写入可以单独写，也可以批量写。可以看到如果incomplete_ &#x3D; true，则说明在批量写，直到incomplete_ &#x3D; false时，进行写提交刷新 f 指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Write an item to the pipe.  Don&#x27;t flush it yet. If incomplete is</span></span><br><span class="line"><span class="comment">//  set to true the item is assumed to be continued by items</span></span><br><span class="line"><span class="comment">//  subsequently written to the pipe. Incomplete items are neverflushed down the stream.</span></span><br><span class="line"><span class="comment">// 写入数据，incomplete参数表示写入是否还没完成，在没完成的时候不会修改flush指针，即这部分数据不会让读线程看到。    </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> T &amp;value_, <span class="type">bool</span> incomplete_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  Place the value to the queue, add new terminator element.</span></span><br><span class="line">    queue.<span class="built_in">back</span>() = value_;</span><br><span class="line">    queue.<span class="built_in">push</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Move the &quot;flush up to here&quot; poiter.</span></span><br><span class="line">    <span class="keyword">if</span> (!incomplete_)</span><br><span class="line">    &#123;</span><br><span class="line">        f = &amp;queue.<span class="built_in">back</span>(); <span class="comment">// 记录要刷新的位置</span></span><br><span class="line">        <span class="comment">// printf(&quot;1 f:%p, w:%p\n&quot;, f, w);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  printf(&quot;0 f:%p, w:%p\n&quot;, f, w);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Pop an incomplete item from the pipe. Returns true is such</span></span><br><span class="line"><span class="comment">//  item exists, false otherwise.</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="built_in">unwrite</span>(T *value_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == &amp;queue.<span class="built_in">back</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    queue.<span class="built_in">unpush</span>();</span><br><span class="line">    *value_ = queue.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flush</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Flush all the completed items into the pipe. Returns false if</span></span><br><span class="line"><span class="comment">//  the reader thread is sleeping. In that case, caller is obliged to</span></span><br><span class="line"><span class="comment">//  wake the reader up before using the pipe again.</span></span><br><span class="line"><span class="comment">// 刷新所有已经完成的数据到管道，返回false意味着读线程在休眠，在这种情况下调用者需要唤醒读线程。</span></span><br><span class="line"><span class="comment">// 批量刷新的机制， 写入批量后唤醒读线程；</span></span><br><span class="line"><span class="comment">// 反悔机制 unwrite</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  If there are no un-flushed items, do nothing.</span></span><br><span class="line">    <span class="keyword">if</span> (w == f) <span class="comment">// 不需要刷新，即是还没有新元素加入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Try to set &#x27;c&#x27; to &#x27;f&#x27;.</span></span><br><span class="line">    <span class="comment">// read时如果没有数据可以读取则c的值会被置为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (c.<span class="built_in">cas</span>(w, f) != w) <span class="comment">// 尝试将c设置为f，即是准备更新w的位置</span></span><br><span class="line">    &#123;<span class="comment">// 进入此分支：在flush之前进行了 check_read但是失败了，c被置为 NULL</span></span><br><span class="line">        <span class="comment">//  Compare-and-swap was unseccessful because &#x27;c&#x27; is NULL.</span></span><br><span class="line">        <span class="comment">//  This means that the reader is asleep. Therefore we don&#x27;t</span></span><br><span class="line">        <span class="comment">//  care about thread-safeness and update c in non-atomic</span></span><br><span class="line">        <span class="comment">//  manner. We&#x27;ll return false to let the caller know</span></span><br><span class="line">        <span class="comment">//  that reader is sleeping.</span></span><br><span class="line">        c.<span class="built_in">set</span>(f); <span class="comment">// 更新为新的f位置</span></span><br><span class="line">        w = f;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//线程看到flush返回false之后会发送一个消息给读线程，这需要写业务去做处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 读端还有数据可读取</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  Reader is alive. Nothing special to do now. Just move</span></span><br><span class="line">        <span class="comment">//  the &#x27;first un-flushed item&#x27; pointer to &#x27;f&#x27;.</span></span><br><span class="line">        w = f;             <span class="comment">// 更新w的位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下参考文章中提供了多读多写的基于数据的无锁队列实现，以及理论分析</p><p>内联汇编：<a href="https://www.jianshu.com/p/1782e14a0766">https://www.jianshu.com/p/1782e14a0766</a></p><p>cas 单例模式：<a href="https://blog.csdn.net/q5707802/article/details/79251491">https://blog.csdn.net/q5707802/article/details/79251491</a></p><p><a href="https://www.yuque.com/linuxer/xngi03/cegcer#bgHkH">说说无锁(Lock-Free)编程那些事 (yuque.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/33985732">基于数组的无锁队列(译) - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 从0到1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>io_uring</title>
      <link href="/2024/02/05/8.1io_uring/"/>
      <url>/2024/02/05/8.1io_uring/</url>
      
        <content type="html"><![CDATA[<h1 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h1><p>在linux 5.1 版本之后，Linux内核提供了异步IO的框架支持，提供了三个系统调用 <code> io_uring_enter  io_uring_register  io_uring_setup</code> 在liburing.h头文件中对此系统调用进行了封装，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_enter</span><span class="params">(<span class="type">int</span> ring_fd, <span class="type">unsigned</span> <span class="type">int</span> to_submit,</span></span><br><span class="line"><span class="params">                   <span class="type">unsigned</span> <span class="type">int</span> min_complete, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) syscall(__NR_io_uring_enter, ring_fd, to_submit, min_complete,</span><br><span class="line">                         flags, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中系统调用号<code>__NR_io_uring_enter</code> 在<code>unistd_64.h</code>中被定义：<code>#define __NR_io_uring_enter 426</code></p><h2 id="性能："><a href="#性能：" class="headerlink" title="性能："></a>性能：</h2><p>由于调用系统调用时，会从用户态切换到内核态，从而进行上下文切换，而上下文切换会消耗一定的 CPU 时间。<code>io_uring</code> 为了减少或者摒弃系统调用，采用了用户态与内核态共享内存的方式来通信(用户态对共享内存进行读写操作是不需要使用系统调用的，所以不会发生上下文切换的情况)。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_setup</span><span class="params">(u32 entries, <span class="keyword">struct</span> io_uring_params *p)</span>;</span><br></pre></td></tr></table></figure><p>用户通过调用 <code>io_uring_setup </code>初始化一个新的 <code>io_uring</code> 上下文。该函数返回一个 file descriptor，并将 <code>io_uring</code> 支持的功能、以及各个数据结构在 <code>fd</code> 中的偏移量存入 <code>params</code>。用户根据偏移量将 <code>fd</code> 映射到内存 (mmap) 后即可获得一块内核用户共享的内存区域。这块内存区域中，有 <code>io_uring</code> 的上下文信息：提交队列信息 (<code>SQ_RING</code>) 和完成队列信息 (<code>CQ_RING</code>)；还有一块专门用来存放提交队列元素的区域 (SQEs)。<code>SQ_RING</code> 中只存储 SQE 在 SQEs 区域中的序号，<code>CQ_RING</code> 存储完整的任务完成数据。</p><p><img src="/img/v2-ad01522fd88442e9164001926b3d839c_r.png"></p><p><code>io_uring</code> 在创建时有两个选项(flag)，对应着 <code>io_uring</code> 处理任务的不同方式：</p><ul><li>开启 <code>IORING_SETUP_IOPOLL</code> 后，<code>io_uring</code> 会使用轮询的方式执行所有的操作。</li><li>开启 <code>IORING_SETUP_SQPOLL</code> 后，<code>io_uring</code> 会创建一个内核线程专门用来收割用户提交的任务。</li><li>都不开启，通过 <code>io_uring_enter</code> 提交任务，收割任务无需 syscall。</li></ul><p><code>io_uring_setup</code> 设计的巧妙之处在于，内核通过一块和用户共享的内存区域进行消息的传递。在创建上下文后，任务提交、任务收割等操作都通过这块共享的内存区域进行，在 <code>IO_SQPOLL</code> 模式下，可以完全绕过 Linux 的 syscall 机制完成需要内核介入的操作（比如读写文件），大大减少了 syscall 切换上下文、刷 TLB 的开销。</p><h2 id="任务的定义"><a href="#任务的定义" class="headerlink" title="任务的定义"></a>任务的定义</h2><p><code>io_uring</code> 定义的异步 io 请求，对应宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OP_NOP0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OP_READV1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OP_WRITEV2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OP_FSYNC3</span></span><br></pre></td></tr></table></figure><p>内核中定义了<code>io_op_defs</code>数组用与描述对应的异步 io 请求所需要的条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">io_op_def</span> <span class="title">io_op_defs</span>[] =</span> &#123;</span><br><span class="line">[IORING_OP_NOP] = &#123;&#125;,</span><br><span class="line">[IORING_OP_READV] = &#123;</span><br><span class="line">.needs_file= <span class="number">1</span>,<span class="comment">//表示该操作需要文件描述符。</span></span><br><span class="line">.unbound_nonreg_file= <span class="number">1</span>, <span class="comment">//表示该操作需要非正则文件</span></span><br><span class="line">.pollin= <span class="number">1</span>,<span class="comment">//表示该操作需要poll in。</span></span><br><span class="line">.buffer_select= <span class="number">1</span>,<span class="comment">//表示该操作需要buffer_select</span></span><br><span class="line">.needs_async_setup= <span class="number">1</span>,<span class="comment">//表示该操作需要异步设置。</span></span><br><span class="line">.plug= <span class="number">1</span>,   <span class="comment">//表示该操作需要plug。 </span></span><br><span class="line">.async_size= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_async_rw),<span class="comment">//表示该操作的异步结构体大小</span></span><br><span class="line">&#125;,</span><br><span class="line">[IORING_OP_WRITEV] = &#123;</span><br><span class="line">.needs_file= <span class="number">1</span>,</span><br><span class="line">.hash_reg_file= <span class="number">1</span>,</span><br><span class="line">.unbound_nonreg_file= <span class="number">1</span>,</span><br><span class="line">.pollout= <span class="number">1</span>,</span><br><span class="line">.needs_async_setup= <span class="number">1</span>,</span><br><span class="line">.plug= <span class="number">1</span>,</span><br><span class="line">.async_size= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_async_rw),</span><br><span class="line">&#125;,</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>io_uring</code> 中几乎每个操作都有对应的准备和执行函数。比如 <code>read</code> 操作就对应 <code>io_read_prep</code> 和 <code>io_read</code> 函数。除了同步操作，内核还支持异步调用的操作，对于这些操作，<code>io_uring</code>中还会有一个对应的异步准备函数以 <code>_async</code> 结尾</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">io_sendmsg_prep_async</span><span class="params">(<span class="keyword">struct</span> io_kiocb *req)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">io_rw_prep_async</span><span class="params">(<span class="keyword">struct</span> io_kiocb *req, <span class="type">int</span> rw)</span>;</span><br></pre></td></tr></table></figure><h2 id="任务的创建"><a href="#任务的创建" class="headerlink" title="任务的创建"></a>任务的创建</h2><p><strong>用户将需要进行的操作写入 <code>io_uring</code> 的 SQ 中。在 CQ 中，用户可以收割任务的完成情况。</strong></p><p>sqe的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> &#123;</span></span><br><span class="line">__u8opcode;<span class="comment">/* type of operation for this sqe */</span></span><br><span class="line">__u8flags;<span class="comment">/* IOSQE_ flags */</span></span><br><span class="line">__u16ioprio;<span class="comment">/* ioprio for the request */</span></span><br><span class="line">__s32fd;<span class="comment">/* file descriptor to do IO on */</span></span><br><span class="line">__u64off;<span class="comment">/* offset into file */</span></span><br><span class="line">__u64addr;<span class="comment">/* pointer to buffer or iovecs */</span></span><br><span class="line">__u32len;<span class="comment">/* buffer size or number of iovecs */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">__kernel_rwf_t</span>rw_flags;</span><br><span class="line">__u32fsync_flags;</span><br><span class="line">__u16poll_events;</span><br><span class="line">__u32sync_range_flags;</span><br><span class="line">__u32msg_flags;</span><br><span class="line">__u32timeout_flags;</span><br><span class="line">&#125;;</span><br><span class="line">__u64user_data;<span class="comment">/* data to be passed back at completion time */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__u16buf_index;<span class="comment">/* index into fixed buffers, if used */</span></span><br><span class="line">__u64__pad2[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如要进行<code>readv</code> 操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sqe-&gt;fd = filefd;<span class="comment">//需要操作的文件描述符</span></span><br><span class="line">sqe-&gt;flags = <span class="number">0</span>;</span><br><span class="line">sqe-&gt;opcode = IORING_OP_READV; <span class="comment">//readv对应option_code</span></span><br><span class="line">sqe-&gt;addr = &amp;iovecs;  <span class="comment">//存放的起始地址</span></span><br><span class="line">sqe-&gt;len = blocks;<span class="comment">//对应 iovec 数组的长度</span></span><br><span class="line">sqe-&gt;off = <span class="number">0</span>;<span class="comment">//从文件偏移位置为0处开始</span></span><br></pre></td></tr></table></figure><p>通常来说，使用 <code>io_uring</code> 的程序都需要用到 64 位的 <code>user_data</code> 来唯一标识一个操作。<code>user_data</code> 是 SQE 的一部分。<code>io_uring</code> 执行完某个操作后，会将这个操作的 <code>user_data</code> 和操作的返回值一起写入 CQ 中。一般携带指向堆内存的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> &#123;</span></span><br><span class="line">__u64user_data;<span class="comment">/* sqe-&gt;data submission passed back */</span></span><br><span class="line">__s32res;<span class="comment">/* result code for this event */</span></span><br><span class="line">__u32flags;<span class="comment">// 未使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <code>io_ uring</code> 是一个异步接口，<code>errno</code> 将不用于传回错误信息。与此对应，<code>res</code> 将保存在成功的情况下等效的系统调用将要返回的内容，而在出错的情况下 <code>res</code> 将包含<code>-errno</code>。例如，如果正常读取系统调用返回<code>-1</code>并将<code>errno</code>设置为<code>EINVAL</code>，则<code>res</code>将包含<code>-EINVAL</code>。</p><h2 id="任务的提交与收割"><a href="#任务的提交与收割" class="headerlink" title="任务的提交与收割"></a>任务的提交与收割</h2><p><code>io_uring</code> 通过环形队列和用户交互。</p><p><img src="/img/v2-f688ede3a66c848fb4e3333767dfd9cc_r.png"></p><p>我们的先以用户提交任务为例，介绍 <code>io_uring</code> 的内核用户交互方式。用户提交任务的过程如下：</p><ul><li>将 SQE 写入 SQEs 区域，而后将 SQE 编号写入 SQ。（对应图中绿色第一步）</li><li>更新用户态记录的队头。（对应图中绿色第二步）</li><li>如果有多个任务需要同时提交，用户不断重复上面的过程。</li><li>将最终的队头编号写入与内核共享的 <code>io_uring</code> 上下文。（对应图中绿色第三步）</li></ul><p>接下来我们简要介绍内核获取任务、内核完成任务、用户收割任务的过程。</p><ul><li>内核态获取任务的方式是，从队尾读取 SQE，并更新 <code>io_uring</code> 上下文的 SQ tail。</li></ul><p><img src="/img/v2-670198a5e28380ee33809eec41d39e04_r.png"></p><ul><li>内核态完成任务：往 CQ 中写入 CQE，更新上下文 CQ head。</li><li>用户态收割任务：从 CQ 中读取 CQE，更新上下文 CQ tail。</li></ul><p><code>io_uring</code> 在创建时有两个选项，对应着 <code>io_uring</code> 处理任务的不同方式：</p><ul><li>开启 <code>IORING_SETUP_IOPOLL</code> 后，<code>io_uring</code> 会使用轮询的方式执行所有的操作。</li><li>开启 <code>IORING_SETUP_SQPOLL</code> 后，<code>io_uring</code> 会创建一个内核线程专门用来收割用户提交的任务。</li></ul><p>这些选项的设定会影响之后用户与 <code>io_uring</code> 交互的方式：</p><ul><li>都不开启，通过 <code>io_uring_enter</code> 提交任务，收割任务无需 syscall。</li><li>只开启 <code>IORING_SETUP_IOPOLL</code>，通过 <code>io_uring_enter</code> 提交任务和收割任务。</li><li>开启 <code>IORING_SETUP_SQPOLL</code>，无需任何 syscall 即可提交、收割任务。内核线程在一段时间无操作后会休眠，可以通过 <code>io_uring_enter</code> 唤醒。</li></ul><h2 id="liburing"><a href="#liburing" class="headerlink" title="liburing"></a>liburing</h2><p>使用流程：</p><ol><li><p>使用io_uring_queue_init，完成io_uring相关结构的初始化。在这个函数的实现中，会调用多个mmap来初始化一些内存。</p></li><li><p>初始化完成之后，为了提交IO请求，需要获取里面queue的一个项，使用io_uring_get_sqe。</p></li><li><p>获取到了空闲项之后，使用io_uring_prep_readv、io_uring_prep_writev初始化读、写请求。和前文所提preadv、pwritev的思想差不多，这里直接以不同的操作码委托io_uring_prep_rw，io_uring_prep_rw只是简单地初始化io_uring_sqe。</p></li><li><p>准备完成之后，使用io_uring_submit提交请求。</p></li><li><p>提交了IO请求时，可以通过非阻塞式函数io_uring_peek_cqe、阻塞式函数io_uring_wait_cqe获取请求完成的情况。默认情况下，完成的IO请求还会存在内部的队列中，需要通过io_uring_cqe_seen表标记完成操作。</p></li><li><p>使用完成之后要通过io_uring_queue_exit来完成资源清理的工作。</p></li></ol><h3 id="link-operation"><a href="#link-operation" class="headerlink" title="link operation"></a>link operation</h3><p>在io_uring中完成的任务并不是按照提交顺序返回的，有时我们需要按顺序的完成一组任务，这需要设置<code>sqe</code>对应的flag，为<code>flag</code>添加 <code>IOSQE_IO_LINK</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">io_uring_prep_write(sqe, fd, STR, <span class="built_in">strlen</span>(STR), <span class="number">0</span> );</span><br><span class="line">sqe-&gt;flags |= IOSQE_IO_LINK;<span class="comment">//添加link flag</span></span><br><span class="line"></span><br><span class="line">sqe = io_uring_get_sqe(ring);</span><br><span class="line"><span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">io_uring_prep_read(sqe, fd, buff, <span class="built_in">strlen</span>(STR),<span class="number">0</span>);</span><br><span class="line">sqe-&gt;flags |= IOSQE_IO_LINK;<span class="comment">//添加link flag</span></span><br><span class="line"></span><br><span class="line">sqe = io_uring_get_sqe(ring);</span><br><span class="line"><span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">io_uring_prep_close(sqe, fd);</span><br><span class="line">io_uring_submit(ring);</span><br></pre></td></tr></table></figure><p><code>IOSQE_IO_LINK</code>使得本<code>sqe</code>与下一提交的<code>sqe</code>相关联，即两个任务之间有了先后顺序，如上代码就保证了，先读后写最后关闭</p><p>倘若我们操作的文件没有对应的权限，如没有写权限，文件以 O_WRONLY 打开，那么read操作将失败，这将导致后续link的操作全部失败</p><p>当涉及链接操作时，一个操作的失败将导致所有后续链接操作失败，并出现 errno“Operation cancelled”</p><h3 id="regster"><a href="#regster" class="headerlink" title="regster"></a>regster</h3><p>注册文件或用户缓冲区允许内核长期引用内部数据结构或创建应用程序内存的长期映射，从而大大减少每个I&#x2F;O的开销。</p><p>应用程序可以增加或减少已注册缓冲区的大小或数量，方法是首先取消注册现有缓冲区，然后使用新缓冲区发出对io_uring_register（）的新调用。注册缓冲区将等待环空闲。如果应用程序当前有正在处理的请求，注册将等待这些请求完成后再继续。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_register_buffers</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">const</span> <span class="keyword">struct</span> iovec *iovecs, <span class="type">unsigned</span> nr_iovecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">io_uring_prep_write_fixed</span><span class="params">(<span class="keyword">struct</span> io_uring_sqe *sqe,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> fd,</span></span><br><span class="line"><span class="params">                               <span class="type">const</span> <span class="type">void</span> *buf,</span></span><br><span class="line"><span class="params">                               <span class="type">unsigned</span> nbytes,</span></span><br><span class="line"><span class="params">                               __u64 offset,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> buf_index)</span>;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">io_uring_prep_read_fixed</span><span class="params">(<span class="keyword">struct</span> io_uring_sqe *sqe,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> fd,</span></span><br><span class="line"><span class="params">                               <span class="type">void</span> *buf,</span></span><br><span class="line"><span class="params">                               <span class="type">unsigned</span> nbytes,</span></span><br><span class="line"><span class="params">                               __u64 offset,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> buf_index)</span>;</span><br></pre></td></tr></table></figure><p>在register后，对映射后的内存进行read &#x2F; write 操作时，避免一次数据copy，register可以理解为将iovec mmap 到内核中，这样在进行read 或 write 后就少了一次copy</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(FILE_NAME, O_RDWR|O_TRUNC|O_CREAT, <span class="number">0644</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    iov[i].iov_base = <span class="built_in">malloc</span>(BUF_SIZE);</span><br><span class="line">    iov[i].iov_len = BUF_SIZE;</span><br><span class="line">    <span class="built_in">memset</span>(iov[i].iov_base, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ret = io_uring_register_buffers(ring, iov, <span class="number">4</span>);</span><br><span class="line">sqe = io_uring_get_sqe(ring);</span><br><span class="line">io_uring_prep_write_fixed(sqe, fd, iov[<span class="number">0</span>].iov_base, str1_sz, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">io_uring_submit(ring);</span><br><span class="line">io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line">io_uring_cqe_seen(ring, cqe);</span><br></pre></td></tr></table></figure><p>注册文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_register_files</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">const</span> <span class="type">int</span> *files , <span class="type">unsigned</span> nr_files)</span>;</span><br></pre></td></tr></table></figure><p>在用于提交的SQE中，您在使用文件描述符数组中的文件描述符索引而不是在像<code> io_uring_prep_readv（）</code>和<code>io_uring_prep_writev（）</code>这样的调用中使用文件描述符本身时设置了<code>IOSQE_FIXED_FILE</code> 标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">   <span class="type">int</span> ret = io_uring_register_files(ring, fds, <span class="number">1</span>);</span><br><span class="line">   sqe = io_uring_get_sqe(ring);</span><br><span class="line">   io_uring_prep_write(sqe, <span class="number">0</span>, buff1, str1_sz, <span class="number">0</span>);</span><br><span class="line">   <span class="comment">//这里的0表示注册的一组文件描述符的索引只有在设置flag |= IOSQE_FIXED_FILE 有效</span></span><br><span class="line">   sqe-&gt;flags |= IOSQE_FIXED_FILE;</span><br><span class="line">io_uring_submit(ring);</span><br></pre></td></tr></table></figure><h3 id="queue-polling"><a href="#queue-polling" class="headerlink" title="queue polling"></a>queue polling</h3><p>减少系统调用的数量是IO的一个主要目标。为此，<code>io_uring</code>允许提交I&#x2F;O请求，而无需进行单个系统调用。这是通过<code>io_uring</code>支持的一个特殊的提交队列轮询特性完成的。在这种模式下，在程序设置轮询模式后，<code>o_uring</code>启动一个特殊的内核线程，该线程轮询共享提交队列中程序可能添加的条目。这样，您只需将条目提交到共享队列中，内核线程应该看到它并拾取提交队列条目，而无需您的程序进行io_uring_enter（）系统调用。这是在用户空间和内核之间共享队列的一个好处。</p><p>通过在io_uring_params结构的flags成员中设置IORING_SETUP_SQPOLL标志，可以告诉io_uring要使用此模式。如果内核线程在一段时间内没有看到任何提交，它将退出，需要再次调用io_uring_enter（）系统调用来唤醒内核线程，这里的时间由 io_uring_param 的成员 <code>sq_thread_idle</code> 所决定</p><p>在使用liburing时，您永远不会直接调用 <code> io_uring_enter（）</code>系统调用。这通常是由<code>liburing</code>的<code> io_uring_submit（）</code>函数来处理的。它会自动判断你是否在使用轮询模式，并处理你的程序何时需要调用<code> io_uring_enter（）</code>，而你不必为此费心。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> <span class="title">params</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;params, <span class="number">0</span>, <span class="keyword">sizeof</span>(params));</span><br><span class="line">params.flags |= IORING_SETUP_SQPOLL;<span class="comment">// 设置poll模式</span></span><br><span class="line">params.sq_thread_idle = <span class="number">2000</span>;</span><br><span class="line">io_uring_queue_init_params(<span class="number">8</span>, &amp;ring, &amp;params);</span><br></pre></td></tr></table></figure><h3 id="eventfd"><a href="#eventfd" class="headerlink" title="eventfd"></a>eventfd</h3><p>首先我们回顾下 eventfd 系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">eventfd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> initval, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>读操作：</p><p>每次成功的 read(2) 操作都会返回一个 8 字节的整数。如果提供的缓冲区大小小于 8 字节，则 read(2) 会失败并返回错误 EINVAL。</p><p>read(2) 返回的值采用主机字节序，即主机上用于整数的本机字节序。</p><p>read(2) 的行为取决于 eventfd 计数器当前是否具有非零值以及创建 eventfd 文件描述符时是否指定了 EFD_SEMAPHORE 标志：</p><ul><li><p>如果未指定 EFD_SEMAPHORE 并且 eventfd 计数器具有非零值，则 read(2) 会返回 8 字节的数据，其中包含该值，并将计数器的值重置为零。</p></li><li><p>如果指定了 EFD_SEMAPHORE 并且 eventfd 计数器具有非零值，则 read(2) 会返回 8 字节的数据，其中包含值 1，并将计数器的值减 1。</p></li><li><p>如果在调用 read(2) 时 eventfd 计数器为零，则调用会阻塞，直到计数器变为非零（此时 read(2) 会按上述方式进行）；如果文件描述符已被设置为非阻塞，则会失败并返回错误 EAGAIN。</p></li></ul><p>写操作：</p><p>write(2) 调用会将其缓冲区中提供的 8 字节整数值<strong>添加</strong>到计数器中。计数器中可以存储的最大值是最大无符号 64 位值减 1（即 0xfffffffffffffffe）。如果加法会导致计数器的值超过最大值，那么 write(2) 会阻塞，直到对文件描述符执行 read(2) 操作，或者如果文件描述符已被设置为非阻塞，则会失败并返回错误 EAGAIN。</p><p>liburing提供了封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_register_eventfd</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p><code>io_uring_register_eventfd</code> 将eventfd的文件描述符fd注册到io_uring环上，当完成队列中有事件时，会对event执行write操作</p><p>如果不再需要通知，可以调用io_uring_unregister_eventfd（3）来删除eventfd注册。  不需要eventfd参数，因为一个环只能注册一个eventfd。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFF_SZ   512</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buff[BUFF_SZ + <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_exit</span><span class="params">(<span class="type">char</span> *message)</span> &#123;</span><br><span class="line">    perror(message);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">listener_thread</span><span class="params">(<span class="type">void</span> *data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="type">int</span> efd = (<span class="type">int</span>) data;</span><br><span class="line">    <span class="type">eventfd_t</span> v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Waiting for completion event...\n&quot;</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = eventfd_read(efd, &amp;v);                <span class="comment">//首次调用会 block , 可读以为这有事件完成了</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) error_exit(<span class="string">&quot;eventfd_read&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Got completion event.\n&quot;</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">    ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error waiting for completion: %s\n&quot;</span>,</span><br><span class="line">                strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Now that we have the CQE, let&#x27;s process it */</span></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in async operation: %s\n&quot;</span>, strerror(-cqe-&gt;res));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result of the operation: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">    io_uring_cqe_seen(&amp;ring, cqe);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Contents read from file:\n%s\n&quot;</span>, buff);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setup_io_uring</span><span class="params">(<span class="type">int</span> efd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = io_uring_queue_init(<span class="number">8</span>, &amp;ring, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to setup io_uring: %s\n&quot;</span>, strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    io_uring_register_eventfd(&amp;ring, efd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_file_with_io_uring</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">    io_uring_prep_read(sqe, fd, buff, BUFF_SZ, <span class="number">0</span>);</span><br><span class="line">    io_uring_submit(&amp;ring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="type">int</span> efd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create an eventfd instance */</span></span><br><span class="line">    efd = eventfd(<span class="number">0</span>, <span class="number">0</span>);            <span class="comment">//创建eventfd</span></span><br><span class="line">    <span class="keyword">if</span> (efd &lt; <span class="number">0</span>)</span><br><span class="line">        error_exit(<span class="string">&quot;eventfd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create the listener thread */</span></span><br><span class="line">    pthread_create(&amp;t, <span class="literal">NULL</span>, listener_thread, (<span class="type">void</span> *)efd);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup io_uring instance and register the eventfd */</span></span><br><span class="line">    setup_io_uring(efd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initiate a read with io_uring */</span></span><br><span class="line">    read_file_with_io_uring();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for th listener thread to complete */</span></span><br><span class="line">    pthread_join(t, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All done. Clean up and exit. */</span></span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://unixism.net/loti/index.html">https://unixism.net/loti/index.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/361955546">浅析开源项目之io_uring - 知乎 (zhihu.com)</a></p><p><a href="https://mp.weixin.qq.com/s/1wZpFhwJR-LNkQm-QzFxRQ">图解原理｜Linux I&#x2F;O 神器之 io_uring (qq.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/380726590">https://zhuanlan.zhihu.com/p/380726590</a></p><p><a href="https://zhuanlan.zhihu.com/p/334658432">https://zhuanlan.zhihu.com/p/334658432</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 从0到1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程和原子操作</title>
      <link href="/2024/01/18/3.2%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/01/18/3.2%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="线程和原子操作"><a href="#线程和原子操作" class="headerlink" title="线程和原子操作"></a>线程和原子操作</h1><h2 id="线程thread基本使用"><a href="#线程thread基本使用" class="headerlink" title="线程thread基本使用"></a>线程thread基本使用</h2><p>动或按值复制线程函数的参数。如果需要传递引用参数给线程函数，那么必须包装它（例如用 <a href="https://zh.cppreference.com/w/cpp/utility/functional/ref">std::ref</a> 或 <a href="https://zh.cppreference.com/w/cpp/utility/functional/ref">std::cref</a>）。</p><p>忽略来自函数的任何返回值。如果函数抛出异常，那么就会调用 <a href="https://zh.cppreference.com/w/cpp/error/terminate">std::terminate</a>。<strong>需要将返回值或异常传递回调用方线程时可以使用 <a href="https://zh.cppreference.com/w/cpp/thread/promise">std::promise</a> 或 <a href="https://zh.cppreference.com/w/cpp/thread/async">std::async</a>。</strong></p><p>传值和传引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; a +b &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> &amp; a)</span> </span>&#123;</span><br><span class="line">a += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func1 , <span class="number">10</span> , <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">10</span></span><br><span class="line">std::thread <span class="built_in">t2</span>(func2 , std::<span class="built_in">ref</span>(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::ref</code> 用于包装按引用传递的值。<br><code>std::cref</code> 用于包装按<code>const</code>引用传递的值。</p><p><img src="/img/%E4%BB%8E0%E5%88%B01/Snipaste_2023-10-11_12-07-38.png"></p><p>创建一个可运行(<strong>创建时传入线程函数</strong>)的线程对象后，必须对该线程对象进行处理，<strong>要么调用join()，要么调用detach()<strong>，否则线程对象析构时</strong>程序</strong>将直接退出。</p><blockquote><p><code>std::thread::~thread</code>销毁 thread 对象。若 *this 拥有关联线程（ joinable() &#x3D;&#x3D; true ），则调用std::terminate。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; cout &lt;&lt; a &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(f,<span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码将收到<code>Abort</code>信号，因为，线程对象t1在作用域中没有调用join或detach，当t1出作用域时，将会抛出异常导致程序退出</p><h3 id="线程遇到重载函数"><a href="#线程遇到重载函数" class="headerlink" title="线程遇到重载函数"></a>线程遇到重载函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; std:: cout &lt;&lt; a &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::string a)</span> </span>&#123; std::cout &lt;&lt;a &lt;&lt; std::endl;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">((<span class="type">void</span>(*)(<span class="type">int</span>))f , <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">((<span class="type">void</span>(*)(std::string))f , <span class="string">&quot;aaa&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h2><p>每个 <code>std::atomic</code> 模板的实例化和全特化定义一个原子类型。如果一个线程写入原子对象，同时另一线程从它读取，那么行为良好定义，<code>std::atomic</code> 既不可复制也不可移动。</p><p><code>std::atomic</code>模板可用于任何满足可复制构造，可复制赋值，可平凡复制类型T的特化，不支持复制初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::is_trivially_copyable&lt;T&gt;::value</span><br><span class="line">std::is_copy_constructible&lt;T&gt;::value</span><br><span class="line">std::is_move_constructible&lt;T&gt;::value</span><br><span class="line">std::is_copy_assignable&lt;T&gt;::value</span><br><span class="line">std::is_move_assignable&lt;T&gt;::value</span><br></pre></td></tr></table></figure><p>上述值为<code>false</code>非良构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">foo</span><span class="params">(<span class="number">0</span>)</span></span>;  <span class="comment">//直接初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    foo.<span class="built_in">store</span>(x , std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        x = foo.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    &#125; <span class="keyword">while</span>(x == <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt;<span class="string">&quot;foo :&quot;</span> &lt;&lt;x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">first</span><span class="params">(print_foo)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">second</span><span class="params">(set_foo , <span class="number">10</span>)</span></span>;</span><br><span class="line">    first.<span class="built_in">join</span>();</span><br><span class="line">    second.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main finish \n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>std::atomic<T>::store</li></ul><p><code>void store(T desired , std::memort_order order = std::memory_order_seq_cst) noexcept</code>以 desired 原子地替换当前值。按照 order 的值影响内存。order必须是 std::memory_order_relaxed .  std::memory_order_release ,  std::memory_order_seq_cst</p><ul><li>std::atomic<T>::load</li></ul><p><code>void load(std::memort_order order = std::memory_order_seq_cst) const noexcept</code>，原子地加载并返回原子变量的当前值。按照 order 的值影响内存。返回原子变量的当前值。</p><ul><li>std::atomic<T>::operator&#x3D;</li></ul><p><code>T operator=( T desired ) noexcept;</code>将 desired 原子地赋给原子变量。等价于 store(desired)。返回 desired</p><h3 id="std-call-once-std-once-flag"><a href="#std-call-once-std-once-flag" class="headerlink" title="std::call_once std::once_flag"></a>std::call_once std::once_flag</h3><p>定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Callable, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">(std::once_flag&amp; flag , Callable&amp;&amp; f , Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>如果在调用 <code>std::call_once</code> 的时刻，flag 指示 f 已经调用过，那么 <code>std::call_once</code> 会立即返回（称这种对 <code>std::call_once</code> 的调用为<em>消极</em>）。</p></li><li><p>否则，std::call_once 会调用 INVOKE(std::forward<Callable>(f), std::forward<Args>(args)…)。与 std::thread 的构造函数或 std::async 不同，不会移动或复制参数，因为不需要转移它们到另一执行线程（称这种对 std::call_once 的调用为积极）。</p><ul><li>如果该调用抛出了异常，那么将异常传播给 <code>std::call_once</code> 的调用方，并且不翻转 flag，这样还可以尝试后续调用（称这种对 <code>std::call_once</code> 的调用为<em>异常</em>）。</li><li>如果该调用正常返回（称这种对 <code>std::call_once</code> 的调用为<em>返回</em>），那么翻转 flag，并保证以同一 flag 对 <code>std::call_once</code> 的其他调用为<em>消极</em>。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::once_flag flag1, flag2;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simple_do_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(flag1, []()&#123; std::cout &lt;&lt; <span class="string">&quot;简单样例：调用一次\n&quot;</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">may_throw_function</span><span class="params">(<span class="type">bool</span> do_throw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (do_throw)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;抛出：call_once 会重试\n&quot;</span>; <span class="comment">// 这会出现不止一次</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;没有抛出，call_once 不会再重试\n&quot;</span>; <span class="comment">// 保证一次</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_once</span><span class="params">(<span class="type">bool</span> do_throw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag2, may_throw_function, do_throw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">st1</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st2</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st3</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st4</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    st1.<span class="built_in">join</span>();</span><br><span class="line">    st2.<span class="built_in">join</span>();</span><br><span class="line">    st3.<span class="built_in">join</span>();</span><br><span class="line">    st4.<span class="built_in">join</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(do_once, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t4</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">简单样例：调用一次   </span></span><br><span class="line"><span class="comment">抛出：call_once 会重试</span></span><br><span class="line"><span class="comment">抛出：call_once 会重试</span></span><br><span class="line"><span class="comment">抛出：call_once 会重试</span></span><br><span class="line"><span class="comment">没有抛出，call_once 不会再重试</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><h3 id="future"><a href="#future" class="headerlink" title="future"></a>future</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt; <span class="keyword">class</span> <span class="title class_">future</span>;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt; <span class="keyword">class</span> <span class="title class_">future</span>&lt;T&amp;&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;          <span class="keyword">class</span> <span class="title class_">future</span>&lt;<span class="type">void</span>&gt;;</span><br><span class="line"><span class="comment">//asynchronous 异步</span></span><br><span class="line"><span class="comment">//future   未来</span></span><br><span class="line"><span class="comment">//promise   承诺</span></span><br></pre></td></tr></table></figure><p>类模板 <code>std::future</code> 提供访问异步操作<strong>结果</strong>的机制</p><p>通过<code>std::async  std::packaged_task  std::promise</code>创建的异步操作能提供一个<code>std::future</code>对象给该异步操作的创建者，然后，异步操作的创建者能用各种方法查询 等待 或从<code>std::future</code>中提取值。若异步操作认为提供值，则这些方法可能阻塞。异步操作准备好发送结果给创建者时，它能通过修改链接到创建者的 <code>std::future</code> 的共享状态，<code>std::future</code> 所引用的共享状态不与另一异步返回对象共享</p><ul><li>get()：<code>get</code> 方法等待直至 <code>future</code> 拥有合法结果并（依赖于使用哪个模板）获取它。它等效地调用 <a href="https://zh.cppreference.com/w/cpp/thread/future/wait">wait()</a> 等待结果，泛型模板和二个模板特化各含单个 <code>get</code> 版本。 <code>get</code> 的三个版本仅在返回类型有别。若调用此函数前 <a href="https://zh.cppreference.com/w/cpp/thread/future/valid">valid()</a> 为 false 则行为未定义。</li></ul><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args &gt;</span><br><span class="line">std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="keyword">typename</span> std::decay&lt;Function&gt;::<span class="built_in">type</span>(</span><br><span class="line">        <span class="keyword">typename</span> std::decay&lt;Args&gt;::type...)&gt;::type&gt;</span><br><span class="line">    <span class="built_in">async</span>( Function&amp;&amp; f, Args&amp;&amp;... args );</span><br></pre></td></tr></table></figure><p><strong>函数模板</strong> <code>std::async</code> 异步地运行函数 f（有可能在可能是线程池一部分的分离线程中），并返回最终将保有该函数调用结果的<code>std::future</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_result_to_add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 用来测试异步延迟的影响</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;find_result_to_add&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(find_result_to_add);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;valid:&quot;</span>&lt;&lt; result.<span class="built_in">valid</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//    std::future&lt;decltype (find_result_to_add())&gt; result = std::async(find_result_to_add);</span></span><br><span class="line"><span class="comment">//    auto result = std::async(find_result_to_add);  // 推荐的写法</span></span><br><span class="line">    <span class="built_in">do_other_things</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;  <span class="comment">// 延迟是否有影响？</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;valid:&quot;</span>&lt;&lt; result.<span class="built_in">valid</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> ...Args &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">packaged_task</span>&lt;<span class="built_in">R</span>(Args...)&gt;;</span><br></pre></td></tr></table></figure><p><strong>类模板</strong> std::packaged_task 包装任何可调用 (Callable) 目标（函数、 lambda 表达式、 bind 表达式或其他函数对象），使得能异步调用它。<strong>其返回值或所抛异常被存储于能通过 std::future 对象访问的共享状态中</strong>。</p><p><code>std::function</code> <code>std::packaged_task</code> 是多态、具分配器的容器：可在堆上或以提供的分配器分配存储的可调用对象。</p><ul><li><p>operator()：如果以<code>INVOKE&lt;R&gt;(f ,args...)</code>调用存储的任务 f。任务返回值或任何抛出的异常被存储于共享状态。令共享状态就绪，并解除阻塞任何等待此操作的线程。</p></li><li><p>get_future()：返回与 *this 共享同一共享状态的 <code>future</code> 。<code>get_future</code> 只能对每个 <code>packaged_task</code> 调用一次。</p></li><li><p>reset()：重置状态，抛弃先前执行的结果。构造共享状态。等价于 *this &#x3D; packaged_task(std::move(f)) ，其中 <code>f</code> 是存储的任务。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;call add\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_other_things</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;do_other_things&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(add)</span></span>; <span class="comment">// 封装任务，不运行</span></span><br><span class="line"><span class="built_in">do_other_things</span>();</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();<span class="comment">//将result与task的future关联，不运行</span></span><br><span class="line"><span class="built_in">task</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">//任务执行，否则在get()获取future的值时会一直阻塞</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;result:&quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>传统的线程返回值：传递一个指针给线程，表示该线程将会把返回值写入指针指向的内存空间。此时主线程将用条件变量等待值被写入，当线程把值写入指针指定的内存后，将唤醒(signal)条件变量，然后主线程将被唤醒，然后从指针指向的内存中获取返回值。</p><p>为了实现获取一个返回值的需求，使用传统的方法，我们需要条件变量(condition variable), 互斥量(mutex)，和指针三个对象。</p><p>C++11的方法：使用<strong>std::future</strong>和<strong>std::promise</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">R</span> &gt; <span class="keyword">class</span> <span class="title class_">promise</span>;</span><br></pre></td></tr></table></figure><p>类模板 <code>std::promise</code> 提供存储值或异常的设施，之后通过 <code>std::promise</code> 对象所创建的 <code>std::future</code>对象异步获得结果。注意 <code>std::promise</code> 只应当使用一次。</p><ul><li><p>std::future<T> get_future：返回与 *this 关联同一状态的 future 对象。若 *this 无共享状态，或已调用 <code>get_future</code> 则抛出异常</p></li><li><p>set_value(const R&amp; value)：原子地存储 <code>value</code> 到共享状态，并令状态就绪。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::promise&lt;std::string&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">set_value</span>(<span class="string">&quot;There is the result whitch you want.&quot;</span>);<span class="comment">//设置线程返回值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::promise&lt;std::string&gt; promise;</span><br><span class="line">std::future&lt;std::string&gt; result = promise.<span class="built_in">get_future</span>();<span class="comment">//将promise中的future与result相关联</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(print, std::ref(promise))</span></span>;  </span><br><span class="line">    <span class="comment">//新建线程，并传入 promise 的 引用，promise 无法复制故要传入引用</span></span><br><span class="line"><span class="built_in">do_some_other_things</span>();</span><br><span class="line">std::cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;<span class="comment">//从result中获取结果</span></span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 从0到1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程实战</title>
      <link href="/2024/01/16/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
      <url>/2024/01/16/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="网络编程实战"><a href="#网络编程实战" class="headerlink" title="网络编程实战"></a>网络编程实战</h1><h2 id="第四讲"><a href="#第四讲" class="headerlink" title="第四讲"></a>第四讲</h2><p>调用 connect 函数将激发 TCP 的三次握手过程，而且仅在连接建立成功或出错时才返回。其中出错返回可能有以下几种情况：</p><ol><li>三次握手无法建立，客户端发出的 SYN 包没有任何响应，于是返回 TIMEOUT 错误。这种情况比较常见的原因是对应的服务端 IP 写错。</li><li>客户端收到了 RST（复位）回答，这时候客户端会立即返回 CONNECTION REFUSED 错误。这种情况比较常见于客户端发送连接请求时的请求端口写错，因为 RST 是 TCP 在发生错误时发送的一种 TCP 分节。关闭时也会产出<code>RST</code>报文与<code>SO_LINGER</code>选项有关<br>产生 RST 的三个条件是：<br>目的地为某端口的 SYN 到达，然而该端口上没有正在监听的服务器（如前所述）；<br>TCP 想取消一个已有连接；<br>TCP 接收到一个根本不存在的连接上的分节。</li><li>客户发出的 SYN 包在网络上引起了”destination unreachable”，即目的不可达的错误。这种情况比较常见的原因是客户端和服务器端路由不通。</li></ol><p>为什么tcp建立连接需要三次握手解释如下<br>tcp连接的双方要确保各自的<strong>收发消息</strong>的能力都是正常的。 客户端第一次发送握手消息到服务端， 服务端接收到握手消息后把<code>ack</code>和自己的<code>syn</code>一同发送给客户端，这是第二次握手， 当客户端接收到服务端发送来的第二次握手消息后，客户端可以确认“服务端的收发能力OK，客户端的收发能力OK”，但是服务端只能确认 “客户端的发送OK，服务端的接收OK” ， 所以还需要第三次握手，客户端收到服务端的第二次握手消息后，发起第三次握手消息，服务端收到客户端发送的第三次握手消息后，就能够确定“服务端的发送OK，客户端的接收OK”， 至此，客户端和服务端都能够确认自己和对方的收发能力OK，，<code>tcp</code>连接建立完成。</p><h2 id="第五讲"><a href="#第五讲" class="headerlink" title="第五讲"></a>第五讲</h2><p>阻塞式套接字最终发送返回的实际写入字节数和请求字节数是相等的即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = write(sockfd , <span class="type">void</span>* buffer , <span class="type">int</span> len);</span><br></pre></td></tr></table></figure><p>当<code>sockfd</code>是<strong>阻塞状态</strong>时，只有将buffer中len字节数据放入输出缓冲区后write函数才返回。</p><p>既然缓冲区如此重要，我们可不可以把缓冲区搞得大大的，这样不就可以提高应用程序的吞吐量了么？你可以想一想这个方法可行吗？另外你可以自己总结一下，一段数据流从应用程序发送端，一直到应用程序接收端，总共经过了多少次拷贝？<br>无限大肯定是不行的，这要从为什么使用缓存这个角度考虑。内核协议栈不确定用户一次要发多少数据，如果用户来一次就发一次，如果数据多还好说，如果少了，那网络I&#x2F;O很频繁，而真正发送出去的数据也不多，所以为了减少网络I&#x2F;O使用了缓存的策略。但为啥不呢无限大呢，网卡一次发出去的数据报它是有一个最大长度的，所以你不管累积再多数据最后还是要分片发送的，这样一来缓冲区太大也没什么意义，而且数据传输也是有延时要求的，不可能总是在缓冲区里待着等数据，这样就总会有空出来的缓冲区存放新数据，所以无限大缓冲区也没意义，反而还浪费资源。<br>发送端，假设数据能一次性复制完，那么从用户态内存拷贝到内核态内存是一次（这里应该直接拷贝到发送换冲区了），传输层组TCP包是第二次拷贝，因为要加包头，而发送缓冲区的都是紧凑内存全是应用层数据，那么分装包就需要一次拷贝，第三次，一个TCP包封装为IP报文这里可能也会需要一次拷贝，毕竟这里走到协议栈的下一层了。</p><h2 id="第六讲"><a href="#第六讲" class="headerlink" title="第六讲"></a>第六讲</h2><p>实际上不存在<code>UDP</code>发送缓冲区，因为发往<code>UDP</code>发送缓冲区的包只要超过一定阈值(值很小)就可以发往对端。所以我们一般认为<code>UDP</code>是没有发送缓冲区的。</p><p><code>UDP</code> 报文的大小</p><p>主要影响 <code>UDP</code> 报文大小的三大因素：</p><ul><li><code>UDP</code> 协议规定报文长度为 16 位，所以 <code>UDP</code> 的报文长度不能超过 2^16 &#x3D; 65536 字节</li><li>以太网(Ethernet)数据帧的长度，这是由以太网的物理特性决定，也叫数据链路层的 <code>MTU</code>(最大传输单元)</li><li>socket 的 <code>UDP</code> 发送缓冲区大小</li></ul><p><code>UDP </code>最大数据包长度</p><p>根据 <code>UDP</code> 协议，从 <code>UDP</code> 数据包的包头可以看出，<code>UDP</code> 的最大包长度是 2^16-1 个字节。用<code>sendto</code>函数最大能发送数据的长度为：<code>65535- IP头(20) - UDP头(8)＝65507字节</code>。用<code>sendto</code>函数发送数据时，如果发送数据长度大于该值，则函数会返回错误。</p><p>由于 <code>UDP</code> 包头占 8 个字节，而在 <code>IP</code>层进行封装后的 <code>IP</code> 包头占去 20 字节，所以这个是 <code>UDP</code> 数据包的最大理论长度是 2^16 - 1 - 8 - 20 &#x3D; 65507 字节。</p><p>同时 <code>UDP</code> 发送缓冲区大小（<code>linux</code>下<code>UDP</code>发送缓冲区大小为：<code>cat /proc/sys/net/core/wmem_default</code>）相关，肯定不能超过缓冲区大小。</p><p><code>UDP</code> 理想数据包长度</p><p>每个以太网帧都有最小的大小 46 字节，最大不能超过 1500 字节。</p><p>除去链路层的首部和尾部的 18 个字节，链路层的数据区范围是 46-1500 字节，</p><p>那么链路层的数据区，即 <code>MTU</code>(最大传输单元)为 1500 字节。</p><p>事实上这个 1500 字节就是网络层 <code>IP</code> 数据报的长度限制。</p><p>因为 <code>IP</code> 数据报的首部为 20 字节，所以 <code>IP</code> 数据报的数据区长度最大为 1480 字节。而这个 1480 字节就是用来放 TCP 传来的 <code>TCP</code> 报文段或 <code>UDP</code> 传来的 <code>UDP</code> 数据报的。</p><p>除去 <code>UDP</code> 包头占 8 个 字节，那么 <code>UDP</code> 数据报的数据区最大长度为 1472 字节。</p><p><strong>结论1：局域网环境下，建议将 <code>UDP</code> 数据控制在 1472 字节以下</strong></p><p>Unix 网络编程第一卷里说：<code>ipv4</code> 协议规定 <code>ip</code> 层的最小重组缓冲区大小为 576 字节，所以将 <code>UDP</code> 数据报的数据区最大长度控制在 548 字节(576-8-20)以内。</p><p><strong>结论2：<code>Internet </code>编程时，建议将 <code>UDP</code> 数据控制在 548 字节以下</strong></p><h2 id="第十讲"><a href="#第十讲" class="headerlink" title="第十讲"></a>第十讲</h2><p>TIME_WAIT的作用： 1. 确保主动断开方的最后一个ACK成功发到对方 2. 确保残留的TCP包自然消亡</p><p>优化<code>TIME_WAIT</code>，可以通过设置套接字选项来设置调用close或shutdown关闭连接时的行为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval,<span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span><span class="comment">//linger 英文停留</span></span><br><span class="line">　<span class="type">int</span>　 l_onoff;　　　　<span class="comment">/* 0=off, nonzero=on */</span></span><br><span class="line">　<span class="type">int</span>　 l_linger;　　　 <span class="comment">/* linger time, POSIX specifies units as seconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>设置 linger 参数有几种可能：</p><ul><li><p>如果<code>l_onoff</code>为 0，那么关闭本选项。l_linger的值被忽略，这对应了默认行为，<code>close</code> 或 <code>shutdown</code> 立即返回。如果在套接字发送缓冲区中有数据残留，系统会将试着把这些数据发送出去。</p></li><li><p>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值也为 0，那么调用 <code>close</code> 后，会立该发送一个 <code>RST</code> 标志给对端，该 <code>TCP</code> 连接将跳过四次挥手，也就<strong>跳过了 <code>TIME_WAIT</code> 状态，直接关闭</strong>。这种关闭的方式称为“强行关闭”。 在这种情况下，排队数据不会被发送，被动关闭方也不知道对端已经彻底断开。只有当被动关闭方正阻塞在<code>recv()</code>调用上时，接受到 <code>RST</code> 时，会立刻得到一个<code>“connet reset by peer”</code>的异常。</p></li><li><p>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>的值也非 0，那么调用 <code>close</code> 后，调用 <code>close</code> 的线程就将阻塞，直到数据被发送出去，或者设置的<code>l_linger</code>计时时间到。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">so_linger</span>;</span></span><br><span class="line">so_linger.l_onoff = <span class="number">1</span>;</span><br><span class="line">so_linger.l_linger = <span class="number">1</span>;</span><br><span class="line">setsockopt(s,SOL_SOCKET,SO_LINGER, &amp;so_linger,<span class="keyword">sizeof</span>(so_linger));</span><br></pre></td></tr></table></figure></li></ul><p>对于设置端口重用选项 SO_REUSEADDR 并不是用于解决 TIME_WAIT 状态，而是告诉内核即使是TIME_WAIT状态的套接字，也可以将它继续使用作为新的套接字使用</p><h2 id="第十一讲"><a href="#第十一讲" class="headerlink" title="第十一讲"></a>第十一讲</h2><p>close 函数具体是如何关闭两个方向的数据流呢？<br>在输入方向，系统内核会将该套接字设置为<strong>不可读</strong>，任何读操作都会返回异常。<br>在输出方向，系统内核尝试将发送缓冲区的数据发送给对端，并最后向对端发送一个 FIN 报文，接下来如果再对该套接字进行写操作会返回异常。<br>如果对端没有检测到套接字已关闭，还继续发送报文，就会收到一个 RST 报文</p><p>由于close将输入设置为不可读，当服务端要做耗时任务时，由于客户端调用close()导致输入方向不可读，此时服务端运算完成返回tcp报文，但是客户端socket不可读，故内核协议栈回复RST报文</p><p>关于signal函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure><ul><li>如果处理方式设置为 <code>SIG_IGN</code>，则信号被忽略。        </li><li>如果处理方式设置为 <code>SIG_DFL</code>，则与信号相关的默认操作（参考 signal(7)）发生。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    SIG_DFL     ((__sighandler_t)  0)    <span class="comment">/* Default action.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    SIG_IGN     ((__sighandler_t)  1)    <span class="comment">/* Ignore signal.  */</span></span></span><br></pre></td></tr></table></figure><blockquote><p>你可以看到在今天的服务器端程序中，直接调用exit(0)完成了 FIN 报文的发送，这是为什么呢？为什么不调用 close 函数或 shutdown 函数呢？</p></blockquote><p>因为在调用exit之后进程会退出，而进程相关的所有的资源，文件，内存，信号等内核分配的资源都会被释放，在<code>linux</code>中，一切皆文件，本身socket就是一种文件类型，内核会为每一个打开的文件创建<code>file</code>结构并维护指向改结构的引用计数，每一个进程结构中都会维护本进程打开的文件数组，数组下标就是<code>fd</code>，内容就指向上面的<code>file</code>结构，<code>close</code>本身就可以用来操作所有的文件，做的事就是，删除本进程打开的文件数组中指定的<code>fd</code>项，并把指向的<code>file</code>结构中的引用计数减一，等引用计数为 0 的时候，就会调用内部包含的文件操作<code>close</code>，针对于<code>socket</code>，它内部的实现就是调用<code>shutdown</code>，只是参数是关闭读写端，从而比较粗暴的关闭连接。</p><h2 id="第十二讲"><a href="#第十二讲" class="headerlink" title="第十二讲"></a>第十二讲</h2><p>socket设置保活选项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Socket::setKeepAlive</span><span class="params">(<span class="type">bool</span> on)</span> <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ::setsockopt(sockfd_, SOL_SOCKET, SO_KEEPALIVE,</span><br><span class="line">                 &amp;optval, static_cast&lt;<span class="type">socklen_t</span>&gt;(<span class="keyword">sizeof</span> optval));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p><p>上述的可定义变量，分别被称为保活时间、保活时间间隔和保活探测次数。在 <code>Linux</code> 系统中，这些变量分别对应 <code>sysctl</code> 变量<code>net.ipv4.tcp_keepalive_time</code>、<code>net.ipv4.tcp_keepalive_intvl</code>、 <code>net.ipv4.tcp_keepalve_probes</code>，默认设置是 7200 秒（2 小时）、75 秒和 9 次探测。</p><p>由于TCP自身的<code>KeepAlive</code>机制所需的时间太长，对很多对时延要求敏感的系统中，这个时间间隔是不可接受的。所以通常自实现心跳机制</p><h2 id="第十三讲"><a href="#第十三讲" class="headerlink" title="第十三讲"></a>第十三讲</h2><p>Nagle算法 和 延迟ACK 的组合：</p><p>客户端分两次将一个请求发送出去，由于请求的第一部分的报文未被确认，Nagle 算法开始起作用；同时延时 ACK 在服务器端起作用，假设延时时间为 200ms，服务器等待 200ms 后，对请求的第一部分进行确认；接下来客户端收到了确认后，Nagle 算法解除请求第二部分的阻止，让第二部分得以发送出去，服务器端在收到之后，进行处理应答，同时将第二部分的确认捎带发送出去。</p><p><img src="/%5Cimg%5CSnipaste_2023-12-18_22-51-37.png"></p><p>Nagle 算法和延时确认组合在一起，增大了处理时延，实际上，两个优化彼此在阻止对方。从上面的例子可以看到，在有些情况下 Nagle 算法并不适用， 比如对时延敏感的应用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> on = <span class="number">1</span>; <span class="comment">//关闭 Nagle 算法</span></span><br><span class="line">setsockopt(sock , IPPROTO_TCP , TCP_NODELAY , (vodi*)&amp;on , <span class="keyword">sizeof</span>(on));</span><br></pre></td></tr></table></figure><p>值得注意的是，除非我们对此有十足的把握，否则不要轻易改变默认的 TCP Nagle 算法。因为在现代操作系统中，针对 Nagle 算法和延时 ACK 的优化已经非常成熟了，有可能在禁用 Nagle 算法之后，性能问题反而更加严重。</p><h2 id="第十五讲"><a href="#第十五讲" class="headerlink" title="第十五讲"></a>第十五讲</h2><p>重用套接字选项，通过给套接字配置可重用属性，告诉操作系统内核，这样的 TCP 连接完全可以复用 TIME_WAIT 状态的连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br></pre></td></tr></table></figure><p><code>SO_REUSEADDR</code> 套接字选项还有一个作用，那就是本机服务器如果有多个地址(ip地址)，可以在不同地址上使用相同的端口提供服务。</p><p>要在创建socket和bind之间设置 <code>SO_REUSEADDR</code> 套接字选项 因为<code>SO_REUSEADDR</code> 是针对新建立的连接才起作用，对已建立的连接设置是无效的。</p><h2 id="第十七讲"><a href="#第十七讲" class="headerlink" title="第十七讲"></a>第十七讲</h2><p><img src="/.%5Cimg%5CSnipaste_2023-12-27_23-10-09.png"></p><ul><li>网络中断造成的对端无 FIN 包</li></ul><p>很多原因都会造成网络中断，在这种情况下，TCP 程序并不能及时感知到异常信息。除非网络中的其他设备，如路由器发出一条 ICMP 报文，说明目的网络或主机不可达，这个时候通过 read 或 write 调用就会返回 Unreachable 的错误。</p><p>大多数时候并不是如此，在没有 ICMP 报文的情况下，TCP 程序并不能理解感应到连接异常。如果程序是阻塞在 read 调用上，那么很不幸，程序无法从异常中恢复。</p><p>如果程序先调用了 write 操作发送了一段数据流，接下来阻塞在 read 调用上，结果会非常不同。Linux 系统的 TCP 协议栈会不断尝试将发送缓冲区的数据发送出去，大概在重传 12 次、合计时间约为 9 分钟之后，协议栈会标识该连接异常，这时，阻塞的 read 调用会返回一条 TIMEOUT 的错误信息。如果此时程序还执着地往这条连接写数据，写操作会立即失败，返回一个 SIGPIPE 信号给应用程序。</p><ul><li>系统崩溃造成的对端无 FIN 包</li></ul><p>当系统突然崩溃，如断电时，网络连接上来不及发出任何东西。这里和通过系统调用杀死应用程序非常不同的是，没有任何 FIN 包被发送出来。</p><p>在没有 ICMP 报文的情况下，TCP 程序只能通过 read 和 write 调用得到网络连接异常的信息，超时错误是一个常见的结果。</p><p>系统在崩溃之后又重启，当重传的 TCP 分组到达重启后的系统，由于系统中没有该 TCP 分组对应的连接数据，系统会返回一个 RST 重置分节，TCP 程序通过 read 或 write 调用可以分别对 RST 进行错误处理。</p><p>如果是阻塞的 read 调用，会立即返回一个错误，错误信息为连接重置（Connection Reset）。</p><p>如果是一次 write 操作，也会立即失败，应用程序会被返回一个 SIGPIPE 信号。</p><ul><li>对端有FIN包发出</li></ul><p>对端如果有 FIN 包发出，可能的场景是对端调用了 close 或 shutdown 显式地关闭了连接，也可能是对端应用程序崩溃，操作系统内核代为清理所发出的。<strong>从应用程序角度上看，无法区分是哪种情形</strong>。</p><h2 id="第十八讲"><a href="#第十八讲" class="headerlink" title="第十八讲"></a>第十八讲</h2><p>当服务器完全崩溃或网络故障，如果采用阻塞读，将无法感知到套接字异常，将会一直阻塞，可以为<code>read</code>设置超时,果超过了一段时间就认为连接已经不存在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">setsockopt(connfd, SOL_SOCKET, SO_RCVTIMEO, (<span class="type">const</span> <span class="type">char</span> *) &amp;tv, <span class="keyword">sizeof</span> tv);</span><br><span class="line"><span class="type">int</span> nBytes = recv(connfd, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (nBytes == <span class="number">-1</span>) </span><br><span class="line"> <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123; ... &#125;<span class="comment">//执行超时处理，如断开连接</span></span><br></pre></td></tr></table></figure><h2 id="第十九讲"><a href="#第十九讲" class="headerlink" title="第十九讲"></a>第十九讲</h2><p>一个进程无论是正常退出（exit 或者 main 函数返回），还是非正常退出（比如，收到 SIGKILL 信号关闭，就是我们常常干的 kill -9），所有该进程打开的描述符都会被系统关闭，这也导致 TCP 描述符对应的连接上发出一个 FIN 包。</p><h2 id="第二十讲"><a href="#第二十讲" class="headerlink" title="第二十讲"></a>第二十讲</h2><p>我们可以使用 fgets 方法等待标准输入，但是一旦这样做，就没有办法在套接字有数据的时候读出数据；我们也可以使用 read 方法等待套接字有数据返回，但是这样做，也没有办法在标准输入有数据的情况下，读入数据并发送给对方。I&#x2F;O 多路复用的设计初衷就是解决这样的场景。我们可以把标准输入、套接字等都看做 I&#x2F;O 的一路，多路复用的意思，就是在任何一路 I&#x2F;O 有“事件”发生的情况下，通知应用程序去处理相应的 I&#x2F;O 事件，这样我们的程序就变成了“多面手”，在同一时刻仿佛可以处理多个 I&#x2F;O 事件。select所支持的文件描述符上线只有1024个</p><blockquote><p>你认为 select 函数里一定需要传入描述字基数这个值么？</p></blockquote><p>需要设置。<code>int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);</code> 函数select检测相当于遍历三个 fd_set，需要知道数组的上限</p><h2 id="第二十一讲"><a href="#第二十一讲" class="headerlink" title="第二十一讲"></a>第二十一讲</h2><p>poll 突破了select对文件描述符的限制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">unsigned</span> <span class="type">long</span> nfds, <span class="type">int</span> timeout)</span>; </span><br></pre></td></tr></table></figure><ul><li>pollfd 数组：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"> <span class="type">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line"> <span class="type">short</span> events; <span class="comment">/* events to look for POLLIN POOLOUT*/</span></span><br><span class="line"> <span class="type">short</span> revents; <span class="comment">/* events returned */</span></span><br><span class="line"> &#125;;</span><br><span class="line">其中对应的事件：</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLIN 0x0001 <span class="comment">/* any readable data available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLPRI 0x0002 <span class="comment">/* OOB/Urgent readable data */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDNORM 0x0040 <span class="comment">/* non-OOB/URG data available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDBAND 0x0080 <span class="comment">/* OOB/Urgent readable data */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLOUT 0x0004 <span class="comment">/* file descriptor is writeable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLWRNORM POLLOUT <span class="comment">/* no write type differentiation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLWRBAND 0x0100 <span class="comment">/* OOB/Urgent data can be written */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLERR 0x0008 <span class="comment">/* 一些错误发送 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLHUP 0x0010 <span class="comment">/* 描述符挂起*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLNVAL 0x0020 <span class="comment">/* 请求的事件无效*/</span></span></span><br></pre></td></tr></table></figure></li></ul><p>如果我们<strong>不想对某个 pollfd 结构进行事件检测，</strong>可以把它对应的 pollfd 结构的 fd 成员设置成一个负值。这样，poll 函数将忽略这样的 events 事件，检测完成以后，所对应的“returned events”的成员值也将设置为 0。在 poll 函数里，我们可以控制 pollfd 结构的数组大小，这意味着我们可以突破原来 select 函数最大描述符的限制，在这种情况下，应用程序调用者需要分配 pollfd 数组并通知 poll 函数该数组的大小。</p><h2 id="第二十二讲"><a href="#第二十二讲" class="headerlink" title="第二十二讲"></a>第二十二讲</h2><p>read &#x2F; write：</p><p>非阻塞读操作：如果套接字对应的接收缓冲区没有数据可读，在非阻塞情况下 read 调用会立即返回，一般返回 EWOULDBLOCK 或 EAGAIN 出错信息</p><p>非阻塞写操作：在非阻塞 I&#x2F;O 的情况下，如果套接字的发送缓冲区已达到了极限，不能容纳更多的字节，那么操作系统内核会<strong>尽最大可能</strong>从应用程序拷贝数据到发送缓冲区中，并立即从 write 等函数调用中返回已拷贝的字节数</p><p>accept：</p><p>当 accept 和 I&#x2F;O 多路复用 select、poll 等一起配合使用时，如果在监听套接字上触发事件，说明有连接建立完成，此时调用 accept 肯定可以返回已连接套接字。但是总有例外</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line">connect();<span class="comment">//在收到服务端回的ack时返回，进入establish状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">ling</span>;</span></span><br><span class="line">ling.l_onoff = <span class="number">1</span>; </span><br><span class="line">ling.l_linger = <span class="number">0</span>;</span><br><span class="line">setsockopt(socket_fd, SOL_SOCKET, SO_LINGER, &amp;ling, <span class="keyword">sizeof</span>(ling));</span><br><span class="line">close(socket_fd);<span class="comment">//此时服务端没有调用accept，就受到了RST报文</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(listen_fd, &amp;readset)) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;listening socket readable\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">5</span>);<span class="comment">//时延</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span></span><br><span class="line"> <span class="type">socklen_t</span> slen = <span class="keyword">sizeof</span>(ss);</span><br><span class="line"> <span class="type">int</span> fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr *) &amp;ss, &amp;slen);</span><br></pre></td></tr></table></figure><p>这里的休眠时间非常关键，这样，在监听套接字上有可读事件发生时，并没有马上调用 accept。由于客户端发生了 RST 分节，该连接被接收端内核从自己的已完成队列中删除了，此时再调用 accept，由于没有已完成连接（假设没有其他已完成连接），accept 一直阻塞，更为严重的是，该线程再也没有机会对其他 I&#x2F;O 事件进行分发，相当于该服务器无法对其他 I&#x2F;O 进行服务。如果我们将监听套接字设为非阻塞，上述的情形就不会再发生。只不过对于 accept 的返回值，需要正确地处理各种看似异常的错误，例如忽略 EWOULDBLOCK、EAGAIN 等。</p><p>connect：</p><p>非阻塞调用时会立即返回 EINPROGRESS 错误，连接后会返回 EISCONN 错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(connect() == EISCONN)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二十三讲"><a href="#第二十三讲" class="headerlink" title="第二十三讲"></a>第二十三讲</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line"> <span class="type">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line"> <span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line"> &#125;;</span><br><span class="line">* EPOLLIN：表示对应的文件描述字可以读；</span><br><span class="line"></span><br><span class="line">* EPOLLOUT：表示对应的文件描述字可以写；</span><br><span class="line"></span><br><span class="line">* EPOLLRDHUP：表示套接字的一端已经关闭，或者半关闭；</span><br><span class="line"></span><br><span class="line">* EPOLLHUP：表示对应的文件描述字被挂起；</span><br><span class="line"></span><br><span class="line">* EPOLLET：设置为 edge-triggered，默认为 level-triggered。</span><br></pre></td></tr></table></figure><p>水平触发(level-trggered)</p><ul><li>只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知，</li><li>当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知</li></ul><p>边缘触发(edge-triggered)</p><ul><li>当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知，</li><li>当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知</li></ul><p>在linux下，如果用边缘触发同时注册了读和写，当读触发的时候，内核向用户返回fd的时候同时会检查fd是否符合可写的条件（有空间容纳待写入的数据），如果满足可写的条件，同时会加上EPOLLOUT标记。</p><h2 id="第三十讲"><a href="#第三十讲" class="headerlink" title="第三十讲"></a>第三十讲</h2><p>无论是阻塞 I&#x2F;O，还是阻塞 I&#x2F;O，和基于非阻塞 I&#x2F;O 的多路复用都是<strong>同步调用技术。为什么这么说呢？因为同步调用、异步调用的说法，是对于获取数据的过程而言的，前面几种最后获取数据的 read 操作调用，都是同步的，在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，这个过程是在 read 函数中同步进行的，如果内核实现的拷贝效率很差，read 调用就会在这个同步过程中消耗比较长的时间</strong></p><p>而真正的异步调用则不用担心这个问题，我们接下来就来介绍第四种 I&#x2F;O 技术，当我们发起 io_uring之后，就立即返回，内核自动将数据从内核空间拷贝到应用程序空间，这个拷贝过程是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。</p><p><a href="https://juejin.cn/post/6844903879688060942">https://juejin.cn/post/6844903879688060942</a>  重置报文</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>share_ptr和weak_ptr</title>
      <link href="/2024/01/15/3.1share_ptr%E4%B8%8Eweak_ptr/"/>
      <url>/2024/01/15/3.1share_ptr%E4%B8%8Eweak_ptr/</url>
      
        <content type="html"><![CDATA[<h1 id="share-ptr和weak-ptr"><a href="#share-ptr和weak-ptr" class="headerlink" title="share_ptr和weak_ptr"></a>share_ptr和weak_ptr</h1><h2 id="share-ptr"><a href="#share-ptr" class="headerlink" title="share_ptr"></a>share_ptr</h2><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>shared_ptr 内部包含两个指针，一个指向对象，另一个指向控制块(control block)，控制块中包含一个引用计数(reference count), 一个弱计数(weak count)和其它一些数据。</p><p><img src="/img/%E4%BB%8E0%E5%88%B01/share_ptr%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png"></p><p>当执行：<code>share_ptr&lt;int&gt; p1(new int(1));share_ptr&lt;int&gt; p2 = p1</code> 时对应的share_ptr结构中指针将指向同一个对象以及控制块</p><p><img src="/img/%E4%BB%8E0%E5%88%B01/share_ptr%E8%B5%8B%E5%80%BC.png"></p><p>std::shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。再最后一个shared_ptr析构的时候，内存才会被释放。</p><p>share_ptr的线程安全问题： </p><blockquote><p><strong>引用计数是线程安全的</strong>，引用计数使用了原子类型，指向对象数据，如果发生修改，将不是线程安全的，若要数据安全，要在对象数据访问上增加锁机制保证对象的数据安全</p></blockquote><h3 id="基本用法，常用函数"><a href="#基本用法，常用函数" class="headerlink" title="基本用法，常用函数"></a>基本用法，常用函数</h3><p>只能通过复制构造或复制赋值其值给另一 <code>shared_ptr</code> ，将对象所有权与另一 <code>shared_ptr</code> 共享。用另一 <code>shared_ptr</code> 所占有的底层指针创建新的 <code>shared_ptr</code> 导致未定义行为。</p><p><code>std::shared_ptr</code> 可以用于不完整类型T 。然而，参数为裸指针的构造函数（ template<class Y> shared_ptr(Y * ) ）和 template<class Y> void reset(Y*) 成员函数只可以用指向完整类型的指针调用（注意 <a href="https://www.apiref.com/cpp-zh/cpp/memory/unique_ptr.html">std::unique_ptr</a> 可以从指向不完整类型的裸指针构造）。</p><ul><li>通过构造函数，<code>make_shared()</code> ，<code>reset()</code>方法来初始化<code>shared_ptr</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p3;</span><br><span class="line">p3.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>不能将一个原始指针直接赋值给一个智能指针<code>std::shared_ptr&lt;int&gt; p = new int(10)</code>这种写法将无法编译，shared_ptr不能通过“直接将原始这种赋值”来初始化，需要通过构造函数或辅助方法来初始化，因为<code>template&lt; class Y &gt; explicit shared_ptr( Y* ptr );</code>参数类型是指针的构造函数被explict修饰(指定构造函数或转换函数 (C++11 起)或推导指引显式，<strong>即它不能用于隐式转换和复制初始化</strong></p><ul><li>智能指针可以通过重载的bool类型操作符来判断</li></ul><p>提供了<code>explicit operator bool() const noexcept;</code>检查 <code>*this</code> 是否存储非空指针，即是否有 <code>get() != nullptr</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(std::shared_ptr&lt;<span class="type">int</span>&gt; ptr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ptr) &#123;</span><br><span class="line">std::cout &lt;&lt; *ptr &lt;&lt;std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;*ptr is not a valid pointer \n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>std::shared_ptr<T>::use_count，返回引用计数</li></ul><p>返回管理当前对象的不同 <code>shared_ptr</code> 实例（包含 this ）数量。若无管理对象，则返回 0。<strong>多线程环境下， use_count 返回的值是近似的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(std::shared_ptr&lt;<span class="type">int</span>&gt; sp)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;fun: sp.use_count() == &quot;</span> &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">    <span class="keyword">auto</span> sp1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1.use_count() == &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">    <span class="comment">//sp1.use_count() == 1</span></span><br><span class="line">    <span class="built_in">fun</span>(sp1);</span><br><span class="line">    <span class="comment">//fun: sp.use_count() == 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>reset方法</li></ul><p>对于无参数reset，<code>void reset() noexcept</code>释放被管理对象的所有权，若存在。调用后， *this 不管理对象。等价于 shared_ptr().swap( *this)</p><p>对于存在一个参数的reset，<code>template&lt; class Y &gt;void reset( Y* ptr );</code>以 <code>ptr</code> 所指向的对象替换被管理对象，以 delete 表达式为删除器。合法的 delete 表达式必须可用，即 delete ptr 必须为良式，拥有良好定义行为且不抛任何异常。等价于 shared_ptr<T>(ptr).swap(*this); 。</p><ul><li>获取原始指针get方法</li></ul><p>当需要获取原始指针时，可以通过get方法来返回原始指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">1</span>&#125;)</span></span>;</span><br><span class="line"><span class="type">int</span> *p = ptr.<span class="built_in">get</span>();<span class="comment">//获取原始指针</span></span><br></pre></td></tr></table></figure><p>谨慎使用<code>p.get()</code>的返回值：</p><blockquote><p>不要保存ptr.get()的返回值 ，无论是保存为裸指针还是shared_ptr都是错误的 。保存为裸指针不知什么时候就会变成空悬指针，保存为shared_ptr则产生了独立指针</p><p>不要delete ptr.get()的返回值 ，会导致对一块内存delete两次的错误</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> * p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(p)</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1.get())</span></span>;<span class="comment">//错误将会double free</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如上代码是错误的</strong>，<code>p1.get()</code>返回指针类型，故调用<code>template&lt; class Y &gt; explicit shared_ptr( Y* ptr )</code>，对于此构造函数，只是构造 <code>shared_ptr</code> ，管理 <code>ptr</code> 所指向的对象，此构造过程并不会产生共享对象，<code>shared_ptr( const shared_ptr&amp; r ) noexcept;</code>和<code>operator=</code>会产生共享对象</p><p><strong>不要将this指针作为shared_ptr返回出来</strong>，原理同上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">shared_ptr&lt;A&gt; <span class="title">GetSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;A&gt;(<span class="keyword">this</span>); <span class="comment">// 不要这么做</span></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>()&#123; cout &lt;&lt; <span class="string">&quot;Destructor A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">shared_ptr&lt;A&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">shared_ptr&lt;A&gt; sp2 = sp1-&gt;<span class="built_in">GetSelf</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确返回this的shared_ptr的做法是：让目标类通过std::enable_shared_from_this类，然后使用基类的 成员函数shared_from_this()来返回this的shared_ptr</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;A&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">shared_ptr&lt;A&gt; <span class="title">GetSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">shared_from_this</span>(); </span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>()&#123;cout &lt;&lt; <span class="string">&quot;Destructor A&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">shared_ptr&lt;A&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">shared_ptr&lt;A&gt; sp2 = sp1-&gt;<span class="built_in">GetSelf</span>(); <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要在函数实参中创建 <code>share_ptr</code></li></ul><p>如：<code> function(std::shared_ptr&lt;int&gt; (new int(10)) , g() )</code>因为C++的函数参数的计算顺序在不同的编译器不同的约定下可能是不一样的，一般是从右到左，但也 可能从左到右，所以，可能的过程是先<code>new int</code>，然后调用<code>g()</code>，如果恰好<code>g()</code>发生异常，而<code>shared_ptr</code>还没有创建， 则<code>int</code>内存泄漏了，正确的写法应该是先创建智能指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">function</span>(p, <span class="built_in">g</span>());</span><br></pre></td></tr></table></figure><ul><li>避免循环引用</li></ul><p>循环引用导致ap和bp的引用计数为2，在离开作用域之后，ap和bp的引用计数减为1，并不回减为0，导致两个指针都不会被析构，产生内存泄漏，解决的办法是把A和B任何一个成员变量改为weak_ptr</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; bptr;</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A is deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; aptr;</span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B is deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;A&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;B&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> B)</span></span>;</span><br><span class="line">        ap-&gt;bptr = bp;</span><br><span class="line">        bp-&gt;aptr = ap;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main leave&quot;</span> &lt;&lt; endl; <span class="comment">// 循环引用导致ap bp退出了作用域都没有析构</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p><code>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 </code>Shared_ptr<code> 管理的对象. 进行该对象的内存管理的是那个强引用的</code>shared_ptr<code>，</code> weak_ptr&#96;只是提供了对管理对象的一个访问手段。</p><h3 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h3><ul><li>通过use_count()方法获取当前观察资源的引用计数</li></ul><p>返回共享被管理对象所有权的 <code>shared_ptr</code> 实例数量，或 0 ，若被管理对象已被删除，即 <code>*this</code> 为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp = sp;</span><br><span class="line">    cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt;endl;      <span class="comment">//1</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; sp1 = sp;</span><br><span class="line">    cout &lt;&lt;wp.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过expired()方法判断所观察资源是否已经释放</li></ul><p><code>bool expired() const noexcept;</code>等价于 <code>use_count() == 0</code> 。可能仍未对被管理对象调用析构函数，但此对象的析构已经临近（或可能已发生），若被管理对象已被删除则为 true ，否则为 false 。若被管理对象在线程间共享，则此函数内在地不可靠，通常 false 结果可能在能用之前就变得过时。 true 结果可靠。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(wp.<span class="built_in">expired</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;weak_ptr无效,资源已释放&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;weak_ptr有效&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>通过lock方法获取监视的shared_ptr</li></ul><p><code>std::shared_ptr&lt;T&gt; lock() const noexcept</code>，创建新的 <code>std::shared_ptr</code> 对象，它共享被管理对象的所有权。若无被管理对象，即 <code>*this</code> 为空，则返回亦为<code>nullptr</code>的 <code>shared_ptr</code>，等效地返回 <code>expired() ? shared_ptr&lt;T&gt;() : shared_ptr&lt;T&gt;(*this)</code> ，<strong>原子地执行</strong></p><p>在多线程环境下：</p><p>线程一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; gw;</span><br><span class="line">gw = sp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> spt = gw.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> ( gw.<span class="built_in">expired</span>() ) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; gw Invalid , resource released&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; gw Vaild , *spt = &quot;</span> &lt;&lt; *spt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>在线程二中资源有可能释放，为了保证线程一不出错，要使用weak_ptr观察，要<strong>先上锁后检查</strong>，根据加锁情况分类</p><ul><li>weak_ptr解决循环引用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;B&gt; bptr; <span class="comment">// 修改为weak_ptr</span></span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123; cout &lt;&lt; <span class="string">&quot;A is deleted&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; aptr;</span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    &#123; cout &lt;&lt; <span class="string">&quot;B is deleted&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;A&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;B&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> B)</span></span>;</span><br><span class="line">        ap-&gt;bptr = bp;</span><br><span class="line">        bp-&gt;aptr = ap;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main leave&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在对B的成员赋值时，即执行<code>bp-&gt;aptr=ap;</code>时，由于<code>aptr</code>是<code>weak_ptr</code>，它并不会增加引用计数，所以ap的引用计数仍然会是1，在离开作用域之后，ap的引用计数为减为0，A指针会被析构，析构后其内部的<code>bptr</code>的引用计数会被减为1，然后在离开作用域后<code>bp</code>引用计数又从1减为0，B对象也被析构，不会发生内存泄漏</p><p><a href="https://www.cnblogs.com/Solstice/archive/2013/01/28/2879366.html">https://www.cnblogs.com/Solstice/archive/2013/01/28/2879366.html</a>多线程环境下share_ptr写时加锁原因</p>]]></content>
      
      
      
        <tags>
            
            <tag> 从0到1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dpdk收发数据</title>
      <link href="/2023/12/30/2.%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE/"/>
      <url>/2023/12/30/2.%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="使用dpdk收发数据"><a href="#使用dpdk收发数据" class="headerlink" title="使用dpdk收发数据"></a>使用dpdk收发数据</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rte_eal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rte_ethdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rte_mbuf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_MBUFS (4096-1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BURST_SIZE32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENABLE_SEND 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_SEND</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> gSrcIp;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> gDstIp;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> gSrcMac[RTE_ETHER_ADDR_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> gDstMac[RTE_ETHER_ADDR_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> gSrcPort;</span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> gDstPort;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> gDpdkPortId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_conf</span> <span class="title">port_conf_default</span> =</span> &#123;</span><br><span class="line">.rxmode = &#123;.max_rx_pkt_len = RTE_ETHER_MAX_LEN &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ng_init_port</span><span class="params">(<span class="keyword">struct</span> rte_mempool *mbuf_pool)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> nb_sys_ports= rte_eth_dev_count_avail(); <span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (nb_sys_ports == <span class="number">0</span>) &#123;</span><br><span class="line">rte_exit(EXIT_FAILURE, <span class="string">&quot;No Supported eth found\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_info</span> <span class="title">dev_info</span>;</span></span><br><span class="line">rte_eth_dev_info_get(gDpdkPortId, &amp;dev_info); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> num_rx_queues = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> num_tx_queues = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_conf</span> <span class="title">port_conf</span> =</span> port_conf_default;</span><br><span class="line">rte_eth_dev_configure(gDpdkPortId, num_rx_queues, num_tx_queues, &amp;port_conf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rte_eth_rx_queue_setup(gDpdkPortId, <span class="number">0</span> , <span class="number">128</span>, <span class="comment">//队列和mbuf_pool有关联</span></span><br><span class="line">rte_eth_dev_socket_id(gDpdkPortId),<span class="literal">NULL</span>, mbuf_pool) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">rte_exit(EXIT_FAILURE, <span class="string">&quot;Could not setup RX queue\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_SEND</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_txconf</span> <span class="title">txq_conf</span> =</span> dev_info.default_txconf;</span><br><span class="line">txq_conf.offloads = port_conf.rxmode.offloads;</span><br><span class="line"><span class="keyword">if</span> (rte_eth_tx_queue_setup(gDpdkPortId, <span class="number">0</span> , <span class="number">1024</span>, <span class="comment">//gDpdkPortId号网卡的第0号队列，最大容纳128个包</span></span><br><span class="line">rte_eth_dev_socket_id(gDpdkPortId) , &amp;txq_conf) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> rte_exit(EXIT_FAILURE, <span class="string">&quot;Could not setup TX queue\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rte_eth_dev_start(gDpdkPortId) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">rte_exit(EXIT_FAILURE, <span class="string">&quot;Could not start\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//rte_eth_promiscuous_enable(gDpdkPortId);//混杂模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ng_encode_udp_pkt</span><span class="params">(<span class="type">uint8_t</span>* msg , <span class="type">unsigned</span> <span class="type">char</span>* data , <span class="type">uint16_t</span> total_len)</span> &#123;</span><br><span class="line"><span class="comment">//在msg所指的位置用data替代</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//eth</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ether_hdr</span>* <span class="title">eth</span> =</span> (<span class="keyword">struct</span> rte_ether_hdr*)msg;</span><br><span class="line">rte_memcpy(&amp;eth-&gt;s_addr , &amp;gSrcMac , RTE_ETHER_ADDR_LEN);</span><br><span class="line">rte_memcpy(&amp;eth-&gt;d_addr, &amp;gDstMac, RTE_ETHER_ADDR_LEN);</span><br><span class="line">eth-&gt;ether_type = htons(RTE_ETHER_TYPE_IPV4);</span><br><span class="line"><span class="comment">//ip</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ipv4_hdr</span>* <span class="title">ip</span> =</span> (<span class="keyword">struct</span> rte_ipv4_hdr*)(msg + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ether_hdr));</span><br><span class="line">ip-&gt;version_ihl = <span class="number">0x45</span>;</span><br><span class="line">ip-&gt;type_of_service = <span class="number">0</span>;</span><br><span class="line">ip-&gt;total_length = htonl(total_len - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ether_hdr));</span><br><span class="line">ip-&gt;packet_id = <span class="number">0</span>;</span><br><span class="line">ip-&gt;fragment_offset = <span class="number">0</span>;</span><br><span class="line">ip-&gt;time_to_live = <span class="number">64</span>;</span><br><span class="line">ip-&gt;next_proto_id = IPPROTO_UDP;</span><br><span class="line">ip-&gt;src_addr = gSrcIp;</span><br><span class="line">ip-&gt;dst_addr = gDstIp;</span><br><span class="line">ip-&gt;hdr_checksum = <span class="number">0</span>;</span><br><span class="line">ip-&gt;hdr_checksum = rte_ipv4_cksum(ip);</span><br><span class="line"><span class="comment">//udp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_udp_hdr</span>* <span class="title">udp</span> =</span> (<span class="keyword">struct</span> rte_udp_hdr*)(ip + <span class="number">1</span>);</span><br><span class="line">udp-&gt;src_port = gSrcPort;</span><br><span class="line">udp-&gt;dst_port = gDstPort;</span><br><span class="line">udp-&gt;dgram_len = htons(total_len - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ether_hdr) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ipv4_hdr));</span><br><span class="line"><span class="type">uint16_t</span> udp_len = total_len - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ether_hdr) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ipv4_hdr);</span><br><span class="line">rte_memcpy(udp+<span class="number">1</span> , data , udp_len);</span><br><span class="line">udp-&gt;dgram_cksum= <span class="number">0</span>;</span><br><span class="line">udp-&gt;dgram_cksum = rte_ipv4_udptcp_cksum(ip ,udp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> rte_mbuf* <span class="title function_">ng_send</span><span class="params">(<span class="keyword">struct</span> rte_mempool* mbuf_pool, <span class="type">unsigned</span> <span class="type">char</span>* msg , <span class="type">uint16_t</span> length)</span> &#123;</span><br><span class="line"><span class="comment">//从mbufpool 中获取 mbuf</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> total_len = <span class="number">14</span> + <span class="number">20</span> + <span class="number">8</span> + length;<span class="comment">//eth + ip + udp + 应用数据</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span>* <span class="title">mbuf</span> =</span> rte_pktmbuf_alloc(mbuf_pool);</span><br><span class="line">mbuf-&gt;pkt_len = total_len;</span><br><span class="line">mbuf-&gt;data_len = total_len;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span>* pktdata = rte_pktmbuf_mtod(mbuf, <span class="type">uint8_t</span>*);</span><br><span class="line">ng_encode_udp_pkt(pktdata , msg ,length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mbuf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rte_eal_init(argc, argv) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">rte_exit(EXIT_FAILURE, <span class="string">&quot;Error with EAL init\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;init success!! \n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">mbuf_pool</span> =</span> rte_pktmbuf_pool_create(<span class="string">&quot;mbuf pool&quot;</span>, NUM_MBUFS,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, RTE_MBUF_DEFAULT_BUF_SIZE, rte_socket_id());</span><br><span class="line"><span class="keyword">if</span> (mbuf_pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">rte_exit(EXIT_FAILURE, <span class="string">&quot;Could not create mbuf pool\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rte_eth_macaddr_get(gDpdkPortId , (<span class="keyword">struct</span> rte_ether_addr*)gSrcMac);</span><br><span class="line"></span><br><span class="line">ng_init_port(mbuf_pool);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mbuf_pool init success!! \n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span>* <span class="title">mbufs</span>[<span class="title">BUFSIZ</span>];</span></span><br><span class="line"><span class="type">unsigned</span> num_recvd = rte_eth_rx_burst(gDpdkPortId , <span class="number">0</span> , mbufs , BUFSIZ);</span><br><span class="line"><span class="keyword">if</span>(num_recvd &gt; BUFSIZ) &#123;</span><br><span class="line">rte_exit(EXIT_FAILURE , <span class="string">&quot;Error receiving from eth \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span> ; i&lt;num_recvd ; ++i) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ether_hdr</span>* <span class="title">ehdr</span> =</span> rte_pktmbuf_mtod(mbufs[i] , <span class="keyword">struct</span> rte_ether_hdr*);</span><br><span class="line"><span class="keyword">if</span>(ehdr-&gt;ether_type != rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV4)) &#123;</span><br><span class="line">rte_pktmbuf_free(mbufs[i]);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ipv4_hdr</span>* <span class="title">iphdr</span> =</span> rte_pktmbuf_mtod_offset(mbufs[i] , <span class="keyword">struct</span> rte_ipv4_hdr* , <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ether_hdr));</span><br><span class="line"><span class="keyword">if</span>(iphdr-&gt;next_proto_id == IPPROTO_UDP) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_udp_hdr</span>* <span class="title">udphdr</span> =</span> (<span class="keyword">struct</span> rte_udp_hdr*)((<span class="type">char</span>*)iphdr + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rte_ipv4_hdr));</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_SEND</span></span><br><span class="line">rte_memcpy(&amp;gDstMac , &amp;ehdr-&gt;d_addr , RTE_ETHER_ADDR_LEN);</span><br><span class="line">gSrcIp = iphdr-&gt;dst_addr;</span><br><span class="line">gDstIp = iphdr-&gt;src_addr;</span><br><span class="line">gSrcPort = udphdr-&gt;dst_port;</span><br><span class="line">gDstPort = udphdr-&gt;src_port;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> length = htons(udphdr-&gt;dgram_len);</span><br><span class="line">*((<span class="type">char</span>*)(udphdr + length)) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.s_addr = iphdr-&gt;src_addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;src:%s %d &quot;</span> , inet_ntoa(addr) , ntohs(udphdr-&gt;src_port));</span><br><span class="line"></span><br><span class="line">addr.s_addr = iphdr-&gt;dst_addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dst:%s %d length=%d:%s\n&quot;</span> , inet_ntoa(addr) , ntohs(udphdr-&gt;dst_port) , </span><br><span class="line">length , (<span class="type">char</span>*)((<span class="type">char</span>*)udphdr + <span class="keyword">sizeof</span>(udphdr)));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_SEND</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span>* <span class="title">txbuf</span> =</span> ng_send(mbuf_pool , (<span class="type">unsigned</span> <span class="type">char</span>*)(udphdr + <span class="number">1</span>) , length);</span><br><span class="line">rte_eth_tx_burst(gDpdkPortId , <span class="number">0</span> , &amp;txbuf , <span class="number">1</span>);</span><br><span class="line">rte_pktmbuf_free(txbuf);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">rte_pktmbuf_free(mbufs[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用API"><a href="#使用API" class="headerlink" title="使用API"></a>使用API</h2><p>在DPDK中，rte前缀代表<strong>Runtime Environment</strong>，即运行环境。DPDK的主要对外函数接口都以rte_作为前缀，抽象化函数接口是典型软件设计思路，可以帮助DPDK运行在多个操作系统上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_eal_init</span><span class="params">(<span class="type">int</span> argc,    <span class="type">char</span> ** argv )</span>;</span><br></pre></td></tr></table></figure><p>此函数用于初始化环境抽象层，函数成功时返回值大于或等于0，所有参数 argv[x] (x &lt; 返回值) 可能已经被这个函数修改，失败返回 -1，并设置<code>rte_error</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rte_exit</span><span class="params">(<span class="type">int</span> exit_code , <span class="type">const</span> <span class="type">char</span>* format)</span>;</span><br></pre></td></tr></table></figure><p>此函数用于立即终止应用程序，打印错误信息并将退出码返回shell</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rte_mempool* <span class="title function_">rte_pktmbuf_pool_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name , <span class="type">unsigned</span> cache_size , <span class="type">uint16_t</span> priv_size </span></span><br><span class="line"><span class="params">                                            , <span class="type">uint16_t</span> data_room_size , <span class="type">int</span> socket_id)</span>;</span><br></pre></td></tr></table></figure><ul><li>name：内存池的名称。</li><li>n：内存池中的元素数量。</li><li>cache_size：每个 CPU 缓存的大小，单位为元素数目，如果为 0 则表示禁用缓存。</li><li>priv_size：每个元素的私有数据空间大小。可以使用 0 表示没有私有数据。</li><li>data_room_size：每个元素中存储数据的空间大小。</li><li>socket_id：内存池所在的 NUMA 节点编号。</li></ul><p>该函数返回一个指向新创建的 mempool 的指针。这个 mempool 可以通过 rte_pktmbuf_alloc 和 rte_pktmbuf_free 命令进行分配和释放。</p><p>dpdk中一个进程确定一个内存池，将发送数据和接收数据都放在内存池中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">rte_socket_id</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>返回当前正常运行此函数网卡对应的socketid</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">rte_eth_dev_count_avail</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>获取可用于dpdk的网卡的个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_eth_dev_configure</span><span class="params">(<span class="type">uint16_t</span>  port_id , <span class="type">uint16_t</span>  nb_rx_queue,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> nb_tx_queue, <span class="type">const</span> <span class="keyword">struct</span> rte_eth_conf* eth_conf )</span></span><br></pre></td></tr></table></figure><p>此函数用于配置网卡设备，此函数必须被调用在任何与网卡api有关的接口之前</p><ul><li>port_id：要配置的网卡对应的id</li><li>nb_rx_queue：接收队列的个数</li><li>nb_tx_queue：发送队列的个数</li><li>eth_conf：指向要对网卡进行的配置操作的结构体</li></ul><p>成功返回 0 失败返回 &lt; 0 的错误号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rte_eth_rx_queue_setup</span><span class="params">(<span class="type">uint16_t</span> port_id  ,  <span class="type">uint16_t</span> rx_queue_id,</span></span><br><span class="line"><span class="params">   <span class="type">uint16_t</span> nb_rx_desc ,  <span class="type">unsigned</span> <span class="type">int</span> socket_id,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> rte_eth_rxconf *rx_conf  ,  <span class="keyword">struct</span> rte_mempool *mb_pool  )</span></span><br></pre></td></tr></table></figure><p>该函数从与 socket_id 关联的内存区域中分配一个连续的内存块，用于存放 nb_rx_desc 个接收描述符，并使用从内存池 mb_pool 中分配的网络缓冲区初始化每个接收描述符。</p><ul><li>port_id：以太网设备的端口标识符。每个物理网卡都有一个唯一的端口 ID，用于在 DPDK 中标识该设备。</li><li>rx_queue_id：要设置的接收队列的索引。每个物理网卡可以有多个接收队列，用于并行处理接收到的数据包。该值必须在之前调用 rte_eth_dev_configure() 函数时指定的范围 [0, nb_rx_queue - 1] 内。</li><li>nb_rx_desc：要为接收环分配的接收描述符的数量。接收描述符用于描述数据包在接收环中的位置和状态。该值通常由应用程序的性能需求和物理网卡的特性决定。</li><li>socket_id：在 NUMA 系统中，指定用于分配接收描述符的内存所在的 NUMA 节点 ID。如果没有 NUMA 限制，则可以设置为 SOCKET_ID_ANY。</li><li>rx_conf：指向要用于接收队列的配置数据的指针。如果设置为 NULL，则使用默认的接收配置</li><li>mb_pool：指向内存池的指针，用于分配 rte_mbuf 网络内存缓冲区，以填充接收环的每个描述符。rte_mbuf 是 DPDK 中用于存储数据包数据的结构。</li></ul><p>返回 0 表示成功</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> <span class="title function_">rte_eth_rx_burst</span><span class="params">(<span class="type">uint16_t</span> port_id,<span class="type">uint16_t</span> queue_id,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> rte_mbuf** rx_pkts , <span class="type">const</span> <span class="type">uint16_t</span> nb_pkts )</span></span><br></pre></td></tr></table></figure><p>从对应的网卡对应的队列中收数据包，被检索到的数据包被存放到<code>rx_pkts</code>数组中指向的<code>rte_mbuf</code>结构体中，此函数是非阻塞调用，这意味着它会立即返回，即使没有可用的输入数据包。如果没有可用的输入数据包，它将返回 0。</p><ul><li><code>port_id</code>：以太网设备端口标识符。</li><li><code>queue_id</code>：要检索数据包的接收队列索引。该值必须在之前提供给 <code>rte_eth_dev_configure()</code> 的范围 <code>[0, nb_rx_queue - 1]</code> 内。</li><li><code>rx_pkts</code>：用于存储检索到的数据包的 <code>rte_mbuf</code> 结构指针数组。</li><li><code>nb_pkts</code>：要检索的最大数据包数。</li></ul><p>返回实际检索到的数据包数，指示 <code>rx_pkts</code> 数组中填充了多少 <code>rte_mbuf</code> 指针。<strong>无错误通知</strong>：该函数不提供错误通知以避免开销。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define rte_pktmbuf_mtod(m, t) rte_pktmbuf_mtod_offset(m, t, 0)</span><br><span class="line">#define rte_pktmbuf_mtod_offset(m, t, o)\</span><br><span class="line">((t)((char *)(m)-&gt;buf_addr + (m)-&gt;data_off + (o)))</span><br></pre></td></tr></table></figure><p><code>rte_pktmbuf_mtod()</code> 是 DPDK 中用于将 <code>rte_mbuf</code> 结构指针转换为特定类型指针的接口。全称是 <strong>rte_mbuf to data pointer</strong>，即“<code>rte_mbuf</code> 结构指针到数据指针”。</p>]]></content>
      
      
      
        <tags>
            
            <tag> dpdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dpdk环境搭建</title>
      <link href="/2023/12/29/1.%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/12/29/1.%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="dpdk环境搭建"><a href="#dpdk环境搭建" class="headerlink" title="dpdk环境搭建"></a>dpdk环境搭建</h1><ol><li><p>将虚拟机对应虚拟网卡驱动设置为 <code> vmxnet3</code><br>因为vmxnet3是支持多队列的网卡,多队列网卡意味着，可以出发cpu的多个中断</p></li><li><p>修改网卡名：</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/default/grub</span><br><span class="line">将GRUB_CMDLINE_LINUX修改为：</span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;net.ifnames=0 biosdevname=0&quot; </span><br></pre></td></tr></table></figure><p>重建grub配置文件<br>执行命令：<code>sudo grub-mkconfig -o /boot//grub/g</code>rub.cfg</p><p>重启后网卡名就修改好了 如 eth0</p><ol start="3"><li>网络配置文件： &#x2F;etc&#x2F;network&#x2F;interfaces，使对应网卡采用dhcp自动获取ip</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The loopback network interface</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The primary network interface</span></span><br><span class="line">auto eth0</span><br><span class="line">iface etho inet dhcp</span><br><span class="line"></span><br><span class="line">auto eth1</span><br><span class="line">iface eth1 inet dhcp</span><br><span class="line"></span><br><span class="line">auto eth2</span><br><span class="line">iface eth2 inet dhcp</span><br></pre></td></tr></table></figure><ol start="4"><li><p>添加网卡，但是在ifconfig时，发现无eth0，执行 <code>ifconfig eth0 up</code>此时 eth0 被开启，但是无 <code>ip </code>被分配，执行 <code>dhclient eth0</code> 为<code>eth0</code> 分配ip</p></li><li><p>在启动参数内添加巨页信息：</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default_hugepages=1G hugepagesz=2M hugepages=1024 isolcpus=0-2</span><br></pre></td></tr></table></figure><p>重建grub配置文件<br>执行命令：<code>sudo grub-mkconfig -o /boot//grub/grub.cfg</code></p><ol start="6"><li>查看是否支持多队列网卡</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/interrupts存在如下内容</span><br><span class="line"></span><br><span class="line">  56:        114       1015   PCI-MSI 1114112-edge      0000:02:04.0</span><br><span class="line">  57:          2        258   PCI-MSI 1572864-edge      eth0-rxtx-0</span><br><span class="line">  58:          5          0   PCI-MSI 1572865-edge      eth0-rxtx-1</span><br><span class="line">  59:          0          0   PCI-MSI 1572866-edge      eth0-event-2</span><br><span class="line">  60:          5        305   PCI-MSI 5767168-edge      eth1-rxtx-0</span><br><span class="line">  61:          8          9   PCI-MSI 5767169-edge      eth1-rxtx-1</span><br><span class="line">  62:          0          0   PCI-MSI 5767170-edge      eth1-event-2</span><br></pre></td></tr></table></figure><p>可以看到eth0 eth1都是多队列网卡，并且有两个都对应两个中断(因为虚拟机我只分配了2个核心)</p><ol start="7"><li>下载dpdk代码，并设置环境变量<br><code>export RTE_SDK=/home/satellite/share/dpdk-stable-19.08.2</code><br><code> export RTE_TARGET=x86_64-native-linux-gcc</code><br>执行：<code>/usertools/dpdk-setup.sh</code></li></ol><ul><li><p>dhclient命令来自英文词组DHCP client的缩写，其功能是动态获取或释放IP地址。使用dhclient命令前，需要将网卡模式设置成DHCP自动获取，否则静态模式的网卡不会主动向服务器获取如IP地址等网卡信息‍。</p></li><li><p><code>/etc/default/grub</code> 是ubuntu开机引导文件，修改<code> GRUB_CMDLINE_LINUX</code> 就是修改了内核的启动参数</p><p>grup是GNU GRand Unified Bootloader的缩写。GRand代表”Generalized”和”Randomized”。在GRUB的背景中，”GRand”意味着它是一个通用且灵活的引导加载程序，可以适用于各种操作系统和硬件平台。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> dpdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议栈</title>
      <link href="/2023/10/12/6.3%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/"/>
      <url>/2023/10/12/6.3%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="网络协议栈"><a href="#网络协议栈" class="headerlink" title="网络协议栈"></a>网络协议栈</h1><p><img src="/img/Snipaste_2023-08-17_00-08-10.png"></p><p>客户端调用connect函数发起连接，此时服务端调用完成listen函数，进入监听状态，这个过程可以类比客户和饭馆，客服先在饭店门口取用餐号(饭店进行记录)，饭店通知客户进来用餐，客户进饭店用餐。在协议栈的实现中，当第一个syn发来时，将对应节点加入服务端的syn半连接队列，当最后一个ack发来时，从对应半连接状态中找到对应节点加入服务端的accept全连接队列。这个节点被称为tcb控制块</p><p>accept函数要做的是：从accept全连接队列A中取出一个节点并为其分配一个文件描述符fd</p><blockquote><p>三次握手客户端在哪个函数？<br>connect</p><p>三次握手服务端在哪个函数？<br>并不是listen，listen只是将连接保存在半连接队列，此时三次握手没有完成。所以，服务器并没有发生在那个函数中而是在listen和accept之间完成的，服务端是被动完成的握手</p><p>如何在半连接队列中找到对应的tcb(tcp control block)节点？<br>tcp的每个过程都伴随着tcp头部字段，其中包含了五元组(sip,sport,dip,dport,proto)，根据五元组是否相同筛选出位于半连接队列的的tcb控制块，将其移到全连接队列中</p><p>send返回一个正数，是不是发送成功了？<br>send函数仅仅只是将buffer中的数据从用户空间拷贝到内核空间，与内核空间是否发送没有关系</p><p>listenfd可不可以收发数据？<br>listenfd可以收发数据，位于三次握手阶段，用于接收syn与发ack</p></blockquote><h2 id="四次挥手问题"><a href="#四次挥手问题" class="headerlink" title="四次挥手问题"></a>四次挥手问题</h2><p>四次挥手不区分客户端还是服务端，<strong>只区分主动还是被动</strong>。主动方先发送FIN，被动方ACK确认，被动方发送FIN，主动发发送ACK确认</p><p><img src="/img/Snipaste_2023-08-17_09-21-47.png"></p><p>主动方与被动方同时处于established状态，主动方调用close函数进入fin_wait1状态，被动方调用recv函数返回0，并返回确认包使主动方进入fin_wait_2状态，被动方进入close_wait状态，被动方调用close函数发送设置fin标志的数据包进入last_ack状态，主动方收到带有fin标注的数据包计入time_wait状态，主动方回复确认包结束被动方last_ack状态</p><p>close()函数就是将FIN写入包结构中，如send() 后立即close() ，那么最后一个数据包中就包含了FIN位，对应的客户端会从FIN_WAIT_1状态直接尽然TIME_WAIT状态，close()仅仅只是关闭fd并发送FIN，会使tcb走向回收，但此时还没有被回收</p><blockquote><p>如果出现大量close_wait如何解决？<br>说明客户端调用close()后服务端recv() &#x3D;&#x3D; 0 由于业务原因没有及时调用close()，可以将业务和网络分离开，使close()及时被调用</p><p>有没有可能双方同时调用close()?</p><p>为什么会有time_wait状态？<br>TIME_WAIT状态存在的原因有两点：<br>可靠地终止TCP连接。<br>保证让迟来的TCP报文段有足够的时间被识别并丢弃。<br>第一个原因很好理解。假设用于确认服务器结束丢失，那么服务器将重发结束报文段。因此客户端需要停留在某个状态以处理重复收到的结束报文段（即向服务器发送确认报文段）。否则，客户端将以复位报文段来回应服务器，服务器则认为这是一个错误，因为它期望的是一个像TCP报文段7那样的确认报文段。 在Linux系统上，一个TCP端口不能被同时打开多次（两次及以 上）。当一个TCP连接处于TIME_WAIT状态时，我们将无法立即使用该连接占用着的端口来建立一个新连接。反过来思考，如果不存在 TIME_WAIT状态，则应用程序能够立即建立一个和刚关闭的连接相似的连接（这里说的相似，是指它们具有相同的IP地址和端口号）。这 个新的、和原来相似的连接被称为原来的连接的化身（incarnation）。 新的化身可能接收到属于原来的连接的、携带应用程序数据的TCP报文段（迟到的报文段），这显然是不应该发生的。这就是TIME_WAIT状态存在的第二个原因。</p></blockquote><h2 id="tcp状态转移"><a href="#tcp状态转移" class="headerlink" title="tcp状态转移"></a>tcp状态转移</h2><p><img src="/img/%E4%BB%8E0%E5%88%B01/Snipaste_2023-10-12_11-53-44.png"></p><p>CLOSED是一个假想的起始点，并不是一个实际的状态。</p><p>服务器通过listen系统调用进入LISTEN状态，被动等待客户端连接，因此执行的是所谓的被动打开。服务器一旦监听到某个连接请求（收到同步报文段），就将该连接放入内核<strong>等待队列</strong>中， 并向客户端发送带SYN标志的确认报文段。此时该连接处于SYN_RCVD状态。如果服务器成功地接收到客户端发送回的确认报文段，则该连接转移到ESTABLISHED状态。ESTABLISHED状态是连接双方能够进行双向数据传输的状态。</p><p>当客户端主动关闭连接时（通过close或shutdown系统调用向服务器发送结束报文段），服务器通过返回确认报文段使连接进入 CLOSE_WAIT状态。这个状态的含义很明确：等待服务器应用程序关闭连接。通常，服务器检测到客户端关闭连接后，也会立即给客户端 发送一个结束报文段来关闭连接。这将使连接转移到LAST_ACK状态，以等待客户端对结束报文段的最后一次确认。一旦确认完成，连接就彻底关闭了。</p><p>客户端通过connect系统调用主动与服务器建立连接。 connect系统调用首先给服务器发送一个同步报文段，使连接转移到 SYN_SENT状态。如果connect连接的目标端口不存在（未被任何进程监听），或者该端口仍被处于TIME_WAIT状态的连接所占用（见后文），则服务 器将给客户端发送一个复位报文段，connect调用失败。如果目标端口存在，但connect在超时时间内未收到服务器的确 认报文段，则connect调用失败。</p><p>connect调用失败将使连接立即返回到初始的CLOSED状态。如果客户端成功收到服务器的同步报文段和确认，则connect调用成功返 回，连接转移至ESTABLISHED状态。</p><p>当客户端执行主动关闭时，它将向服务器发送一个结束报文段， 同时连接进入FIN_WAIT_1状态。若此时客户端收到服务器专门用于确 认目的的确认报文段，则连接转移至 FIN_WAIT_2状态。当客户端处于FIN_WAIT_2状态时，服务器处于 CLOSE_WAIT状态，这一对状态是可能发生半关闭的状态。此时如果服务器也关闭连接（发送结束报文段），则客户端将给予确认并进入 TIME_WAIT状态。</p><p>状态转移图还给出了客户端从FIN_WAIT_1状态直接进入TIME_WAIT状态的一条线路（不经过FIN_WAIT_2状态），前提是处于FIN_WAIT_1 状态的服务器直接收到带确认信息的结束报文段（而不是先收到确认报文段，再收到结束报文段）。</p><h2 id="数据的传输"><a href="#数据的传输" class="headerlink" title="数据的传输"></a>数据的传输</h2><p>对于数据的发送，有三种情况</p><ol><li>一次send()</li><li>连续send()</li><li>send()发送大文件</li></ol><p><code>send(fd , buf , len , 0)</code>仅仅是将数据拷贝到fd所指向的tcb控制块的发送缓冲区中，对于发送是由协议栈自己决定什么时候发送，所以对于连续send()可能出现，两次send()的数据结合为一个数据包发送，也有可能连续send()导致一次send中的数据被分在两个数据包中，这就是所谓的<strong>分包和粘包</strong></p><p>基于tcp的流式数据即数据顺序不会改变，就有了两种解决分包和粘包的方法</p><ol><li>在应用层协议头中指定包长度</li><li>为每一个包加上分隔符</li></ol><blockquote><p>网线断了，连接会消失吗？<br>网卡会重启，协议栈会清空，再次连接网线时需要重新建立tcp连接</p><p>服务端进程崩溃，客户端会发生什么?<br>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP四次挥手的过程。</p><p>服务端主机宕机后，客户端会发生什么？</p><p>当服务端的主机突然断电了，这种情况就是属于服务端主机宕机了。<br>当服务端的主机发生了宕机，是没办法和客户端进行四次挥手的，所以在服务端主机发生宕机的那一时刻，客户端是没办法立刻感知到服务端主机宕机了，只能在后续的数据交互中来感知服务端的连接已经不存在了。<br>因此，我们要分两种情况来讨论：</p><ul><li>服务端主机宕机后，客户端会发送数据；</li><li>服务端主机宕机后，客户端一直不会发送数据；</li></ul><p><strong>服务端主机宕机后，如果客户端会发送数据</strong></p><p>在服务端主机宕机后，客户端发送了数据报文，由于得不到响应，在等待一定时长后，客户端就会触发超时重传机制，重传未得到响应的数据报文。</p><p>当重传次数达到达到一定阈值后，内核就会判定出该 TCP 连接有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是客户端的 TCP 连接就会断开。</p><p><strong>服务端主机宕机后，如果客户端一直不发数据</strong></p><p>在服务端主机发送宕机后，如果客户端一直不发送数据，那么还得看是否开启了 TCP keepalive 机制 （TCP 保活机制）。</p><p>如果没有开启 TCP keepalive 机制，在服务端主机发送宕机后，如果客户端一直不发送数据，那么客户端的 TCP 连接将一直保持存在，所以我们可以得知一个点，在没有使用 TCP 保活机制，且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态时，并不代表另一方的 TCP 连接还一定是正常的。</p><p>而如果开启了 TCP keepalive 机制，在服务端主机发送宕机后，即使客户端一直不发送数据，在持续一段时间后，TCP 就会发送探测报文，探测服务端是否存活：</p><ul><li>如果对端是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。</li><li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。</li></ul><p>所以，TCP keepalive 机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。</p><p>应用程序如果想使用 TCP 保活机制，需要通过 socket 接口设置 SO_KEEPALIVE 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。</p></blockquote><h2 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h2><p><code>Nagle</code>算法主要用来预防小分组的产生。在广域网上，大量TCP小分组极有可能造成网络的拥塞。</p><p><code>Nagle</code>是针对每一个TCP连接的。它要求一个TCP连接上最多只能有一个未被确认的小分组。在改分组的确认到达之前不能发送其他小分组。TCP会搜集这些小的分组，然后在之前小分组的确认到达后将刚才搜集的小分组<strong>合并</strong>发送出去。</p><p>有时候我们必须要关闭<code>Nagle</code>算法，特别是在一些对时延要求较高的交互式操作环境中，所有的小分组必须尽快发送出去。</p><p>我们可以通过编程取消<code>Nagle</code>算法，利用<code>TCP_NODELAY</code>选项来关闭<code>Nagle</code>算法</p><p>参考：<br>《Linux高性能服务器编程》<br><a href="https://www.51cto.com/article/718024.html">https://www.51cto.com/article/718024.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 从0到1 </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络IO</title>
      <link href="/2023/10/11/6.2%E7%BD%91%E7%BB%9Cio/"/>
      <url>/2023/10/11/6.2%E7%BD%91%E7%BB%9Cio/</url>
      
        <content type="html"><![CDATA[<h1 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h1><h2 id="阻塞与非阻塞io"><a href="#阻塞与非阻塞io" class="headerlink" title="阻塞与非阻塞io"></a>阻塞与非阻塞io</h2><p>read &#x2F; write 有两个职责(检测与拷贝)，read检测读buffer中是否有可读数据并根据情况完成内核到用户的拷贝，write检测写buffer中是否有可写位置并根据情况完成用户到内核数据的拷贝</p><p><img src="/img/%E4%BB%8E0%E5%88%B01/Snipaste_2023-10-10_10-37-11.png"></p><p>连接的 fd 阻塞属性决定了 io 函数是否阻塞，对于阻塞IO检测到读buffer中无数据 或 写buffer中已满，会阻塞等待知道读buffer中有数据或写buffer中有位置后在完成数据的拷贝，当然这可能会出现，实际读写的数据少于想要读写的数据即：<code>ret = read(fd , buf , sz) </code>中<code>ret &lt; sz</code>。对于非阻塞IO检测到读buffer中无数据 或 写buffer中已满时会立即返回。具体差异在：IO 函数在数据未就绪时是否立刻返回</p><h2 id="非阻塞IO处理方式"><a href="#非阻塞IO处理方式" class="headerlink" title="非阻塞IO处理方式"></a>非阻塞IO处理方式</h2><p>所有的IO函数都有一个参数fd，这意味着IO函数只能检测一条连接的就绪状态以及操作一条IO的数据</p><h3 id="连接的建立"><a href="#连接的建立" class="headerlink" title="连接的建立"></a>连接的建立</h3><p>connect：</p><p>其中connect分为两种，一种是接收客户端的连接，另一种是服务器作为客户端主动去连接其他服务器如mysql服务器</p><p>客户端非阻塞IO连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">int</span> fd = socket(AF_INET , SOCK_STREAM , <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    inet_pton(AF_INET,argv[<span class="number">1</span>],&amp;servaddr.sin_addr);</span><br><span class="line">    <span class="type">int</span> flag = fcntl(fd , F_GETFL);</span><br><span class="line">    fcntl(fd , F_SETFL , flag | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        connect(fd, &amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect:%s errno:%d \n&quot;</span>,strerror(errno) , errno);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">输出：</span><br><span class="line">connect:Operation now in progress errno:<span class="number">115</span></span><br><span class="line">connect:Operation now in progress errno:<span class="number">115</span></span><br><span class="line">connect:Transport endpoint is already connected errno:<span class="number">106</span></span><br><span class="line">connect:Transport endpoint is already connected errno:<span class="number">106</span></span><br></pre></td></tr></table></figure><p>对于非阻塞IO的<code>connect</code>需要循环连接，其中<code>errno</code>由<code>EINPROGRESS(正在建立)</code>转变为<code>EISCONN(已经连接)</code></p><p>listen：</p><p>会创建半连接队列和全连接队列</p><p>accept：</p><p>对于非阻塞fd，首先<strong>检测</strong>全连接队列中没有可用的连接，会返回-1并设置<code>errno</code>为<code>EWOULDBLOCK</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET , SOCK_STREAM , <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> flag = fcntl(listenfd , F_GETFL);</span><br><span class="line">    fcntl(listenfd , F_SETFL , flag | O_NONBLOCK);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr , <span class="number">0</span> , <span class="keyword">sizeof</span> addr);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">-1</span> == bind(listenfd , &amp;addr , <span class="keyword">sizeof</span>(addr)) ) perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == listen(listenfd , <span class="number">20</span>)) perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span> client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> cfd = accept(listenfd, &amp;client, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(errno == EWOULDBLOCK)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;cfd:%d accept:%s errno:%d \n&quot;</span>,cfd,strerror(errno) , errno);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">输出：</span><br><span class="line">cfd:<span class="number">-1</span> accept:Resource temporarily unavailable errno:<span class="number">11</span></span><br><span class="line">cfd:<span class="number">-1</span> accept:Resource temporarily unavailable errno:<span class="number">11</span></span><br><span class="line">cfd:<span class="number">-1</span> accept:Resource temporarily unavailable errno:<span class="number">11</span></span><br></pre></td></tr></table></figure><h3 id="连接断开"><a href="#连接断开" class="headerlink" title="连接断开"></a>连接断开</h3><p>连接建立，若某一端关闭连接，而另一端仍然向它写数据，第一次写数据后会收到RST(Reset the connection)响应，此后再写数据，内核将向进程发出SIGPIPE信号，通知进程此连接已经断开。而SIGPIPE信号的默认处理是终止程序</p><p>主动断开：close shutdown</p><p>被动断开：对端读端关闭 read() &#x3D; 0 对端写端关闭 write() &#x3D; -1 &amp;&amp; errno &#x3D; EPIPE</p><h2 id="reactor"><a href="#reactor" class="headerlink" title="reactor"></a>reactor</h2><p>reactor将对IO的操作转化为了对事件的处理</p><p>reactor由io多路复用和非阻塞IO组成，IO多路复用负责检测IO事件，非阻塞IO用于操作IO</p><p>reactor为什么要搭配非阻塞IO？</p><blockquote><ol><li>多线程环境下， 会将一个listenfd添加到多个epoll中，这里只有一个listenfd，对应只会有一个全连接队列，但是有多个epoll从这个全连接队列中获取节点，当有多个线程同时对一个节点进行accept时，只会有一个accept成功，若listenfd是阻塞IO其他线程会阻塞在accept上等待返回，若是非阻塞会返回-1并将errno设为EWOULDBLOCK</li><li>在边缘触发下必须使用非阻塞IO，边缘触发要求每次将readbuf中的数据读完，需要借助非阻塞IO read返回 -1 时的errno来判断结束条件</li><li>当reactor使用select时，select存在一个bug，当某个socket接收缓冲区有新数据分节到达，然后select报告这个socket描述符可读，但随后协议栈检查到这个新节点检验和错误，然后丢弃这个节点，这时候调用read则无数据可读，如果socket没有被设置为非阻塞，则此read会阻塞线程</li></ol></blockquote><p>无论是C++还是Java编写的网络框架，大多数都是基于Reactor模型进行设计和开发，Reactor模型基于事件驱动，特别适合处理海量的I&#x2F;O事件。</p><p>Reactor模型中定义的三种角色：</p><ul><li>Reactor：负责监听和分配事件，将I&#x2F;O事件分派给对应的Handler。新的事件包含连接建立就绪、读就绪、写就绪等。</li><li>Acceptor：处理客户端新连接，并分派请求到处理器链中。</li><li>Handler：将自身与事件绑定，执行非阻塞读&#x2F;写任务，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。可用资源池来管理。</li></ul><p>Reactor处理请求的流程：</p><p>读取操作：</p><ol><li>应用程序注册读就绪事件和相关联的事件处理器</li><li>事件分离器等待事件的发生</li><li>当发生读就绪事件的时候，事件分离器调用第一步注册的事件处理器</li></ol><p>写入操作类似于读取操作，只不过第一步注册的是写就绪事件。</p><h4 id="1-单Reactor单线程模型"><a href="#1-单Reactor单线程模型" class="headerlink" title="1.单Reactor单线程模型"></a>1.单Reactor单线程模型</h4><p>Reactor线程负责多路分离套接字，accept新连接，并分派请求到handler。<a href="https://cloud.tencent.com/product/crs?from_column=20065&from=20065">Redis</a>使用单Reactor单进程的模型。</p><p><img src="/img/%E4%BB%8E0%E5%88%B01/Snipaste_2023-10-11_11-54-08.png"></p><p>消息处理流程：</p><ol><li>Reactor对象通过select监控连接事件，收到事件后通过dispatch进行转发。</li><li>如果是连接建立的事件，则由acceptor接受连接，并创建handler处理后续事件。</li><li>如果不是建立连接事件，则Reactor会分发调用Handler来响应。</li><li>handler会完成read-&gt;业务处理-&gt;send的完整业务流程。</li></ol><p>单Reactor单线程模型只是在代码上进行了组件的区分，但是整体操作还是单线程，不能充分利用硬件资源。handler业务处理部分没有异步。</p><p>对于一些小容量应用场景，可以使用单Reactor单线程模型。但是对于高负载、大并发的应用场景却不合适，主要原因如下：</p><ol><li>即便Reactor线程的CPU负荷达到100%，也无法满足海量消息的编码、解码、读取和发送。</li><li>当Reactor线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重Reactor线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈。</li><li>一旦Reactor线程意外中断或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。</li></ol><p>为了解决这些问题，演进出单Reactor多线程模型。</p><h4 id="2-单Reactor多线程模型"><a href="#2-单Reactor多线程模型" class="headerlink" title="2.单Reactor多线程模型"></a>2.单Reactor多线程模型</h4><p>该模型在事件处理器（Handler）部分采用了多线程（线程池）。</p><p><img src="/img/%E4%BB%8E0%E5%88%B01/Snipaste_2023-10-11_11-54-14.png" alt="img"></p><p>消息处理流程：</p><ol><li>Reactor对象通过Select监控客户端请求事件，收到事件后通过dispatch进行分发。</li><li>如果是建立连接请求事件，则由acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后续的各种事件。</li><li>如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应。</li><li>Handler只负责响应事件，不做具体业务处理，通过Read读取数据后，会分发给后面的Worker线程池进行业务处理。</li><li>Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理。</li><li>Handler收到响应结果后通过send将响应结果返回给Client。</li></ol><p>相对于第一种模型来说，在处理业务逻辑，也就是获取到IO的读写事件之后，交由线程池来处理，handler收到响应后通过send将响应结果返回给客户端。这样可以降低Reactor的性能开销，从而更专注的做事件分发工作了，提升整个应用的吞吐。</p><p>但是这个模型存在的问题：</p><ol><li>多线程数据共享和访问比较复杂。如果子线程完成业务处理后，把结果传递给主线程Reactor进行发送，就会涉及共享数据的互斥和保护机制。</li><li>Reactor承担所有事件的监听和响应，只在主线程中运行，可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。</li></ol><p>为了解决性能问题，产生了第三种主从Reactor多线程模型。</p><h4 id="3-主从Reactor多线程模型"><a href="#3-主从Reactor多线程模型" class="headerlink" title="3.主从Reactor多线程模型"></a>3.主从Reactor多线程模型</h4><p>比起第二种模型，它是将Reactor分成两部分：</p><ol><li>mainReactor负责监听server socket，用来处理网络IO连接建立操作，将建立的socketChannel指定注册给subReactor。</li><li>subReactor主要做和建立起来的socket做数据交互和事件业务处理操作。通常，subReactor个数上可与CPU个数等同。</li></ol><p>Nginx、Swoole、Memcached和Netty都是采用这种实现。</p><p><img src="/img/%E4%BB%8E0%E5%88%B01/Snipaste_2023-10-11_11-54-19.png"></p><p>消息处理流程：</p><ol><li>从主线程池中随机选择一个Reactor线程作为acceptor线程，用于绑定监听端口，接收客户端连接</li><li>acceptor线程接收客户端连接请求之后创建新的SocketChannel，将其注册到主线程池的其它Reactor线程上，由其负责接入认证、IP黑白名单过滤、握手等操作</li><li>步骤2完成之后，业务层的链路正式建立，将SocketChannel从主线程池的Reactor线程的多路复用器上摘除，重新注册到Sub线程池的线程上，并创建一个Handler用于处理各种连接事件</li><li>当有新的事件发生时，SubReactor会调用连接对应的Handler进行响应</li><li>Handler通过Read读取数据后，会分发给后面的Worker线程池进行业务处理</li><li>Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理</li><li>Handler收到响应结果后通过Send将响应结果返回给Client</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Reactor模型具有如下的优点：</p><ol><li>响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的；</li><li>编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程的切换开销；</li><li>可扩展性，可以方便地通过增加Reactor实例个数来充分利用CPU资源；</li><li>可复用性，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性。</li></ol><p>部分转载：<a href="https://cloud.tencent.com/developer/article/1488120">https://cloud.tencent.com/developer/article/1488120</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 从0到1 </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hash与bloomfilter</title>
      <link href="/2023/09/08/3.hash%E4%B8%8Ebloomfilter/"/>
      <url>/2023/09/08/3.hash%E4%B8%8Ebloomfilter/</url>
      
        <content type="html"><![CDATA[<h1 id="hash与bloomfilter"><a href="#hash与bloomfilter" class="headerlink" title="hash与bloomfilter"></a>hash与bloomfilter</h1><h2 id="hash冲突的处理"><a href="#hash冲突的处理" class="headerlink" title="hash冲突的处理"></a>hash冲突的处理</h2><p>链表法：</p><blockquote><p>引用链表来处理哈希冲突；也就是将冲突元素用链表链接起来；这也是常用的处理冲突的方式；但是可能出现一种极端情 况，冲突元素比较多，该冲突链表过长，这个时候可以将这个链表转换为红黑树、最小堆；由原来链表时间复杂度转 换为红黑树时间复杂度 ；那么判断该链表过长的依据是多少？可以采用超过 256（经验值）个节点的时候将链表结构转换为红黑树或堆结构</p></blockquote><p>开放寻址法:</p><blockquote><p>将所有的元素都存放在哈希表的数组中，不使用额外的数据结构；一般使用线性探查的思路解决；</p><ol><li><p>当插入新元素的时，使用哈希函数在哈希表中定位元素位置</p></li><li><p>检查数组中该槽位索引是否存在元素。如果该槽位为空，则 插入，否则3；</p></li><li><p>在 2 检测的槽位索引上加一定步长接着检查2； 加一定步长 分为以下几种：</p><ul><li>i+1,i+2,i+3,i+4, … ,i+n  </li><li>i-1^2 , i+2^2 ,i-3^2 ,1+4^2 , …</li></ul><p>这两种都会导致同类 hash 聚集；也就是近似值它的hash值也近似，那么它的数组槽 位也靠近，形成 hash 聚集；第一种同类聚集冲突在前， 第二种只是将聚集冲突延后； 另外还可以使用<strong>双重哈希</strong>来解决上面出现hash聚集现象：</p></li></ol></blockquote><p>当负载因子不在合理范围如：<code>userd / size &gt; 0.9</code><code>userd /size &lt; 0.1</code> 要进行适当的扩容或缩容，在进行完扩容或缩容后要进行<code>rehash</code></p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>有些时候，由于内粗是有限的，只想确定key是否存在，而关心<code>value</code>的内容，这样就可以使用<code>bloom_filter</code>，布隆过滤器，由位图实现</p><p><img src="/img/%E4%BB%8E0%E5%88%B01/Snipaste_2023-09-08_18-33-32.png"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当一个元素加入位图时，通过 k 个 hash 函数将这个元素映射到位图的 k 个点，并把它们置为 1；当检索时，再通过 k 个 hash 函数运算检测位图的 k 个点是否都为 1；如果有不为 1 的点，那么认为该 key 不存在；<strong>如果全部为 1，则可能存在</strong>，当一个key不存在时是可以通过布隆过滤器确认的</p><p>在位图中每个槽位只有两种状态（0 或者 1），一个槽位被 设置为 1 状态，但不确定它被设置了多少次；也就是不知道被多少个 key 哈希映射而来以及是被具体哪个 hash 函数映射而来，所以布隆过滤器<strong>不支持删除操作</strong></p><p>在实际应用中，该选择多少个 hash 函数？要分配多少空间的位 图？预期存储多少元素？如何控制误差？</p><blockquote><p>n – 预期布隆过滤器中元素的个数 </p><p>p – 假阳率，在0-1之间 0.000000 </p><p>m – 位图所占空间 </p><p>k – hash函数的个数 </p><p>公式如下：<br>n &#x3D; ceil(m &#x2F; (-k &#x2F; log(1 - exp(log(p) &#x2F; k))))<br>p &#x3D; pow(1 - exp(-k &#x2F; (m &#x2F; n)), k)<br>m &#x3D; ceil((n * log(p)) &#x2F; log(1 &#x2F; pow(2, log(2))));<br>k &#x3D; round((m &#x2F; n) * log(2));</p></blockquote><p>常通过<a href="https://hur.st/bloomfilter/">Bloom filter calculator (hur.st)</a>站点，输入n 和 p 计算得到所需要的bit位和哈希函数的数量</p><p>如何只用2G内存在20亿整数中寻找出现最多的数？</p><blockquote><p>首先想到散列表，存储k v键值对，v的最大值为20亿，故uint32可以满足，故一个kv占字节，这里有20亿个，故占用16GB，明显超出2G，想办法将20亿整数拆分到若干个文件中，当然不能盲目拆分，要将相同的值放到同一个文件中，可以使用hash函数来解决这个问题(相同的值经过同一个hash函数会得到相同的结果)，将hash函数的结果对文件数取余，存放到对应的文件中</p><p><strong>大文件可以用hash拆为小文件</strong></p><p><strong>单台机器无法解决，通过hash分流到多台机器</strong></p></blockquote><h2 id="分布式一致性-hash"><a href="#分布式一致性-hash" class="headerlink" title="分布式一致性 hash"></a>分布式一致性 hash</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>在主服务器从数据缓存服务器中请求数据时，往往根据数据的key求出的hash值与服务器的个数取余，以此来找到对应的服务器，当扩充数据缓存服务器时，就出现了大问题，由于服务器增加了故模数要变化，就导致对应的key找不到正确的数据服务器</p><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><p> 分布式一致性 hash 算法将哈希空间组织成一个虚拟的圆环，圆 环的大小是 ；</p><p>算法为：<code>hash(ip)</code> ，最终会得到一个 [0, ] 之间的一个无符号整型，这个整数代表服务器的编号；多个服务器都通过这种方式在 <code>hash </code>环上映射一个点来标识该服务器的位置；当用户操作某个<code> key</code>，通过同样的算法生成一个值，沿环顺时针定位某个服务器，那么该 <code>key</code> 就在该服务器中；</p><p><img src="/img/%E4%BB%8E0%E5%88%B01/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C.png"></p><p>此时有三台数据服务器，以及四个数据，<code>k1 -&gt; 10.0.0.2k2-&gt;10.0.0.3k3 k4 -&gt; 10.0.0.1</code></p><p>当增加一个服务器时</p><p><img src="/img/%E4%BB%8E0%E5%88%B01/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E6%89%A9%E5%AE%B9.png"></p><p>此时寻找 k3 会到 10.0.0.5 中寻找，但是k3存储在 10.0.0.1 中，这就造成了<strong>局部失效</strong>，虽然无法根治问题，但是只是局部失效，原方法会造成大面积的数据失效，为了解决数据失效，要<strong>进行部分的数据迁移</strong>，即：将hash后结果落在 10.0.0.3 到10.0.0.5  服务器对应hash值之间的 key 存储到新加的服务器中，并在原服务器中删除，这个hash值直接在原服务器中寻找就好了</p><h3 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h3><p>当我们的服务器过少时，节点无法均匀的分散在圆环上，这样会导致某一个服务器上存放了大量数据</p><p><img src="/img/%E4%BB%8E0%E5%88%B01/%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9.png"></p><p>为了解决这种问题，我们采用虚拟节点，即在对应的<code>ip：port</code>后添加 <code>: 编号</code>,编号从 1 - 255 ，这样一个服务器就产生了255个节点，使得节点的分布根据随机性，在数据存储时，只需将本应该存储在对应虚拟节点的数据存储在其本身节点上即可，在进行数据查找时，找到对应的<code>ip:port:编号</code>，只需将编号截取掉就是存放数据的服务器，这样解决了数据分配不均问题也使得在扩容时进行hash迁移的数据减少了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 从0到1 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2023/09/04/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2023/09/04/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="红黑色的定义"><a href="#红黑色的定义" class="headerlink" title="红黑色的定义"></a>红黑色的定义</h2><blockquote><ol><li>每个结点是红的或者黑的</li><li>根节点是黑的所有叶子节点是黑色（叶子节点是空节点）</li><li>如果一个节点是红的，则他的两个儿子节点都是黑的</li><li>对每个节点，从该节点到子孙节点的所有路径上的包含相同数量的黑节点</li></ol></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="结构定义："><a href="#结构定义：" class="headerlink" title="结构定义："></a>结构定义：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KEY_TYPE;    <span class="comment">//防止key类型写死</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree_node</span> &#123;</span><span class="comment">//节点定义</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> color;<span class="comment">//节点颜色</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">rb_tree_node</span> *<span class="title">right</span>;</span><span class="comment">//左右子树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">rb_tree_node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">rb_tree_node</span> *<span class="title">parent</span>;</span> <span class="comment">//指向父节点，用于性质调整</span></span><br><span class="line"></span><br><span class="line">    KEY_TYPE key;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; rb_tree_node;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree_node</span>* <span class="title">root</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree_node</span>* <span class="title">nil</span>;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>红黑树所有的叶子节点都可以是<strong>隐藏</strong>的且都是黑色的，竟然是隐藏的，那么就可以只有一个叶子节点，即需要叶子节点时均采用指向该叶子节点的指针，这里的叶子节点即为<code>nil</code>所指向的节点，这里不将叶子节点设为<code>NULL</code>是因为nil中具备节点所有的属性，拥有<code>parent</code>，防止了内存的非法访问</p><p>当我们看到拥有颜色，左右子树，父节点指针时，那么这个数据结构就是一颗红黑树，我们上面写的红黑树结构是不可复用的，因为，我们将业务(key value)和红黑树的实现(左右子树，颜色，父节点)放在一起了，于是，我们将红黑树的性质剥离出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="type">int</span> KEY_TYPE;</span><br><span class="line"><span class="comment">//在使用红黑树时，使用这个宏即可</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RBTREE_ENTRY(name , type) \                    </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span> \</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> color;\</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">right</span>;</span>\</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">left</span>;</span>\</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">parent</span>;</span>\</span><br><span class="line">    &#125;                                <span class="comment">//无分号</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree_node</span> &#123;</span></span><br><span class="line">    KEY_TYPE key;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">    </span><br><span class="line">    RBTREE_ENTRY( , rb_tree_node);<span class="comment">//匿名结构体，相当于释放</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    RBTREE_ENTRY( , rb_tree_node) name1;<span class="comment">//节点内也可以有</span></span><br><span class="line">    RBTREE_ENTRY( , rb_tree_node) name2;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">&#125; rb_tree_node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree_node</span>* <span class="title">root</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree_node</span>* <span class="title">nil</span>;</span>    <span class="comment">//所有的叶子节点黑色null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>当红黑树性质不满足时就要进行旋转操作</p><p><img src="/img/%E4%BB%8E0%E5%88%B01/Snipaste_2023-09-04_15-10-30.png"></p><p> 左旋：</p><blockquote><p>x的右子树指向y的左子树b</p><p>y的左子树指向x</p><p>x的parent的左子树或右子树指向y</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rbtree_left_rotate</span><span class="params">(rbtree* T , rb_tree_node* x)</span> &#123;</span><br><span class="line">    rb_tree_node* y = x-&gt;right;</span><br><span class="line">    x-&gt;right = y-&gt;left;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != T-&gt;nil)      <span class="comment">//当y的左子树不为叶子节点时，修改左子树的父节点</span></span><br><span class="line">        y-&gt;left-&gt;parent = x;    </span><br><span class="line">     </span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;parent == T-&gt;nil) &#123;    <span class="comment">//x为根节点，根节点的父节点为空节点nil</span></span><br><span class="line">        T-&gt;root = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left) &#123;    </span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入的节点都会在最底层(除叶子节点)。红黑树在插入节点以前，它已经是一颗红黑树了，在插入时要尽量少改变原有红黑树的性质，故插入节点初始上色为红色，这样不会影响从任意节点到子孙节点的所有路径上的包含相同数量的黑节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rbtree_insert</span><span class="params">(rbtree *T , rbtree_node* z)</span> &#123;</span><br><span class="line">    rbtree_node* y = T-&gt;nil;</span><br><span class="line">    rbtree_node *x = T-&gt;root;</span><br><span class="line">    <span class="keyword">while</span> (x != T-&gt;nil) &#123;      </span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span>(z-&gt;key &lt; x-&gt;key) &#123;</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &gt; x-&gt;key)&#123;</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(y == T-&gt;nil) &#123;</span><br><span class="line">        T-&gt;root = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(y-&gt;key &gt; z-&gt;key) &#123;</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;parent = y; </span><br><span class="line">    z-&gt;left = T-&gt;nil;</span><br><span class="line">    z-&gt;right = T-&gt;nil;</span><br><span class="line">    z-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">    rbtree_insert_fixup(T , z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调整：</p><p>在调整前我们可以知道，z是红色，z的父节点是红色，z的祖父节点是黑色，z的叔叔节点不确定。于是我们可以根据z的叔叔节点颜色进行分类讨论</p><ol><li>叔叔节点是红色<br><img src="/img/%E4%BB%8E0%E5%88%B01/Snipaste_2023-09-04_20-53-02.png"></li><li>叔结点是黑色的，而且当前结点是右孩子<br><img src="/img/%E4%BB%8E0%E5%88%B01/Snipaste_2023-09-04_20-54-03.png"></li><li>. 叔结点是黑色的，而且当前结点是左孩子<br><img src="/img/%E4%BB%8E0%E5%88%B01/Snipaste_2023-09-04_20-54-33.png"></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rbtree_insert_fixup</span><span class="params">(rbtree *T, rbtree_node *z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (z-&gt;parent-&gt;color == RED)</span><br><span class="line">    &#123; <span class="comment">// 插入节点为红色，且其父节点也为红色，需要调整</span></span><br><span class="line">        <span class="keyword">if</span> (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left)</span><br><span class="line">        &#123;                                              <span class="comment">// 父节点在祖父节点的左子树</span></span><br><span class="line">            rbtree_node *y = z-&gt;parent-&gt;parent-&gt;right; <span class="comment">// 叔叔节点</span></span><br><span class="line">            <span class="keyword">if</span> (y-&gt;color == RED)</span><br><span class="line">            &#123; <span class="comment">// 叔叔节点是红色的</span></span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                y-&gt;color = BLACK;</span><br><span class="line"></span><br><span class="line">                z = z-&gt;parent-&gt;parent; <span class="comment">// z时刻保持是红色的</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123; <span class="comment">// 叔叔节点是黑色的</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (z == z-&gt;parent-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    z = z-&gt;parent;</span><br><span class="line">                    rbtree_left_rotate(T, z);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                rbtree_right_rotat(T, z-&gt;parent-&gt;parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 从0到1 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬盘与显卡的访问与控制</title>
      <link href="/2023/08/19/5.%E7%A1%AC%E7%9B%98%E4%B8%8E%E6%98%BE%E5%8D%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E4%B8%8E%E6%8E%A7%E5%88%B6/"/>
      <url>/2023/08/19/5.%E7%A1%AC%E7%9B%98%E4%B8%8E%E6%98%BE%E5%8D%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E4%B8%8E%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="硬盘的访问与控制"><a href="#硬盘的访问与控制" class="headerlink" title="硬盘的访问与控制"></a>硬盘的访问与控制</h1><h2 id="给汇编程序分段"><a href="#给汇编程序分段" class="headerlink" title="给汇编程序分段"></a>给汇编程序分段</h2><p>section是nasm汇编编译器的关键字。首先nasm可以理解以汇编编译器程序，主要进行汇编语言的编译，也就是生成机器码。section成为节，主要是为了对程序进行模块化的划分，是汇编程序的结构更加的清晰。section的几个参数我们要着重了解一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">section 段名 align=对齐倍数 vstart=设置</span><br></pre></td></tr></table></figure><p>若没有align子句在32位和64位程序中段与段间按照4字节对齐，及在原有段后补充0</p><p>若没有vstart子句，则段内汇编地址就是相对程序开的的偏移量，若指定vstart则段内汇编地址从vstart开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">section data1 align=16 vstart=0</span><br><span class="line">mydata dw 0xface</span><br><span class="line"></span><br><span class="line">section data2 align=16 vstart=0</span><br><span class="line">string db &#x27;hello&#x27;</span><br><span class="line"> </span><br><span class="line">section code align=16 vstart=0</span><br><span class="line">    mov bx , mydata</span><br><span class="line">    mov si , string</span><br></pre></td></tr></table></figure><p>正如我们刚刚讨论过的，每个段都有一个汇编地址，它是相对于整 个程序开头（0）的。为了方便取得该段的汇编地址，NASM 编译器提供 了以下的表达式，可以用在你的程序中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">section.段名称.start</span><br></pre></td></tr></table></figure><p>段 “code” 相 对 于 整 个 程 序 开 头 的 汇 编 地 址 是 section.code.start。</p><h2 id="加载器和用户程序"><a href="#加载器和用户程序" class="headerlink" title="加载器和用户程序"></a>加载器和用户程序</h2><p>一般来说，加载器和用户程序是在不同的时间、不同的地方，由不同的人或公司开发的。这就意味着，它们彼此并不了解对方的结构和功能。事实上，也不需要了解。加载器必须了解一 些必要的信息，虽然不是很多，但足以知道如何加载用户程序,他们之间必须有一个协议，或者说协定，比如说，在用户程序内部的某个固定位置，包含一些基本的结构信息，每个用户程序都必须把自己的情况放在这里，而加载器也固定在这个位置读取。经验表明，把这个约定的地点放在用户程序的开头，对双方，特别是对加载器来说比较方便，这就是用户程序头部。</p><p>头部需要在源程序以一个段的形式出现<code>section header vestart=0</code>而且，因为它是“头部”，所以，该段当然必须是第一个被定义的段， 且总是位于整个源程序的开头。</p><p>用户程序头部起码要包含以下信息。</p><ol><li>用户程序的尺寸，即以字节为单位的大小。这对加载器来说是很 重要的，加载器需要根据这一信息来决定读取多少个逻辑扇区</li><li>应用程序的入口点，包括段地址和偏移地址。加载器并不清楚用 户程序的分段情况，更不知道第一条要执行的指令在用户程序中的位 置。因此，必须在头部给出第一条指令的段地址和偏移地址，这就是所 谓的应用程序入口点</li><li>段重定位表。用户程序可能包含不止一个段，比较大的程序可能 会包含多个代码段和多个数据段。这些段如何使用，是用户程序自己的 事，但前提是程序加载到内存后，每个段的地址必须重新确定一下。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SECTION header vstart=0                     ;定义用户程序头部段 </span><br><span class="line">    program_length  dd program_end          ;程序总长度[0x00]</span><br><span class="line">    </span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry      dw start                ;偏移地址[0x04]</span><br><span class="line">                    dd section.code.start   ;段地址[0x06] </span><br><span class="line">    </span><br><span class="line">    ;段重定位表项个数[0x0a]</span><br><span class="line">    realloc_tbl_len dw (header_end-realloc_begin)/4</span><br><span class="line">                                            </span><br><span class="line">    realloc_begin:</span><br><span class="line">    ;段重定位表           </span><br><span class="line">    code_segment    dd section.code.start   ;[0x0c]</span><br><span class="line">    data_segment    dd section.data.start   ;[0x14]</span><br><span class="line">    stack_segment   dd section.stack.start  ;[0x1c]</span><br><span class="line">    </span><br><span class="line">header_end:  </span><br></pre></td></tr></table></figure><h3 id="加载器的工作流程"><a href="#加载器的工作流程" class="headerlink" title="加载器的工作流程"></a>加载器的工作流程</h3><blockquote><p>读取用户程序的起始扇区</p><p>把整个用户程序都读入内存</p><p>计算段的物理地址和逻辑地址和段地址(段重定位)</p><p>转移到用户程序执行(将处理器的控制权交给用户程序)</p></blockquote><h2 id="输入输出端口的访问"><a href="#输入输出端口的访问" class="headerlink" title="输入输出端口的访问"></a>输入输出端口的访问</h2><p>处理器是通过端口（Port）来和外围设备打交道的。本质 上，端口就是一些寄存器，类似于处理器内部的寄存器。不同之处仅仅 在于，这些叫做端口的寄存器位于I&#x2F;O 接口电路中。端口是处理器和外围设备通过I&#x2F;O 接口交流的窗口，每一个I&#x2F;O 接口 都可能拥有好几个端口，分别用于不同的目的。端口可以是8 位的，也可以是16 位的或32位</p><p>比如，连接硬盘的 PATA&#x2F;SATA 接口就有几个端口，分别是命令端口（当向该端口写入0x20 时，表明是从硬盘读数据；写入0x30 时，表明是向硬盘写数据）、状态端口（处理器根据这个端口的数据来判断硬盘工作是否正常，操作是否成功，发生了哪种错误）、参数端口（处理器通过这些端口告诉硬盘读 写的扇区数量，以及起始的逻辑扇区号）和数据端口（通过这个端口连续地取得要读出的数据，或者通过这个端口连续地发送要写入硬盘的数据）。</p><p>端口在不同的计算机系统中有着不同的实现方式。在一些计算机系 统中，端口号是映射到内存地址空间的。比如，0x00000～0xE0000 是 真实的物理内存地址，而0xE0001～0xFFFFF 是从很多I&#x2F;O 接口那里映 射过来的，当访问这部分地址时，实际上是在访问I&#x2F;O 接口。</p><p>而在另一些计算机系统中，端口是独立编址的，不和内存发生关系在这种计算机中，处理器的地址线既连接内存，也连接每一个I&#x2F;O 接口。但是，处理器还有一个特殊的引脚M&#x2F;IO#，在这 里，“#”表示低电平有效。也就是说，当处理器访问内存时，它会让 M&#x2F;IO#引脚呈高电平，这里，和内存相关的电路就会打开；相反，如果处理器访问I&#x2F;O 端口，那么M&#x2F;IO#引脚呈低平，内存电路被禁止。与此同时，处理器发出的地址和M&#x2F;IO#信号一起用于打个某个I&#x2F;O 接口，如果该 I&#x2F;O 接口分配的端口号与处理器地址相吻合的话。</p><h3 id="in-out-指令"><a href="#in-out-指令" class="headerlink" title="in out 指令"></a>in out 指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in al , dx</span><br><span class="line">in ax , dx</span><br><span class="line">in al , 立即数</span><br><span class="line">in ax , 立即数</span><br></pre></td></tr></table></figure><p>in 指令的目的操作数必须是寄存器AL 或者AX，当访问8 位的端口时，使用寄存器AL；访问16 位的端口时，使用AX。in 指令的源操作数应当是寄存器DX，in 指令不允许使用别的通用寄存器，也不允许使用内存单元作为操作数。</p><p>in指令的目的操作数是立即数时，只能访问0～255（0x00～0xff）号端口，<strong>不允许访问大于255 的端口号</strong></p><p>out 指令正好和in 指令相反，目的操作数可以是8 位立即数或者寄存器DX，源操作数必须是寄存器AL 或者AX</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">out 0x37 , al    ;写0x37号端口(8位端口)</span><br><span class="line">out 0xf5 , ax ;写0xfd号端口(16位端口)</span><br><span class="line">out dx , al ;写一个8位端口，端口号在寄存器dx中</span><br><span class="line">out dx , ax      ;写一个16位端口，端口号在寄存器dx中</span><br></pre></td></tr></table></figure><p>in out指令不影响flag寄存器</p><h2 id="通过硬盘控制器端口读扇区数据"><a href="#通过硬盘控制器端口读扇区数据" class="headerlink" title="通过硬盘控制器端口读扇区数据"></a>通过硬盘控制器端口读扇区数据</h2><p>硬盘读写的基本单位是扇区。就是说，要读就至少读一个扇区，要写就至少写一个扇区</p><p>LBA模式(Logical Block Addressing)采用逻辑扇区号的方式访问硬盘，采用LBA28访问硬盘及扇区号由28位bit决定</p><p>主硬盘分配器分配了8个端口(0x1f0 ~ 0x1f7)</p><ol><li><p>设置要读取的扇区数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx , 0x1f2     ;访问0x1f2端口</span><br><span class="line">mov al , 0x01      ;设置扇区数量，当al中是0时意味着尧都区的扇区数为256</span><br><span class="line">out dx , al        ;设置读取的扇区数为1</span><br></pre></td></tr></table></figure></li><li><p>设置起始的LBA扇区号<br><img src="/img/%5B19.9%5D--%E9%80%9A%E8%BF%87%E7%A1%AC%E7%9B%98%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AB%AF%E5%8F%A3%E8%AF%BB%E6%89%87%E5%8C%BA%E6%95%B0%E6%8D%AE.pcwlenv_%E8%A7%86%E9%A2%91%E6%88%AA%E5%9B%BE_304.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;扇区号0x0  00 00 02</span><br><span class="line">mov dx , 0x1f3</span><br><span class="line">mov al , 0x02 ;LBA地址 7~0</span><br><span class="line">out dx , al  </span><br><span class="line">inc dx;0x1f4</span><br><span class="line">mov al , 0x00</span><br><span class="line">out dx , al</span><br><span class="line">inc dx;0x1f5</span><br><span class="line">out dx , al</span><br><span class="line">inc dx;0x1f6</span><br><span class="line">mov al , 0xe0;高8位 1110 第四位为0表示读写主硬盘，第六位位1表示采用LBA模式，7 5位固定为1</span><br><span class="line">out dx , al</span><br></pre></td></tr></table></figure></li><li><p>设置读命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx , 0x1f7</span><br><span class="line">mov al , 0x20</span><br><span class="line">out dx , al</span><br></pre></td></tr></table></figure></li><li><p>等待读写完成<br><img src="/img/%5B19.9%5D--%E9%80%9A%E8%BF%87%E7%A1%AC%E7%9B%98%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AB%AF%E5%8F%A3%E8%AF%BB%E6%89%87%E5%8C%BA%E6%95%B0%E6%8D%AE.pcwlenv_%E8%A7%86%E9%A2%91%E6%88%AA%E5%9B%BE_814.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov dx , 0x1f7</span><br><span class="line">.waits:</span><br><span class="line">in al , dx</span><br><span class="line">and al , 0x88</span><br><span class="line">cmp al , 0x08  ;当无错误且准备好时不跳转</span><br><span class="line">jnz .waits</span><br></pre></td></tr></table></figure></li><li><p>读硬盘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;假定DS已指向存放扇区数据的段，BX里时段内的偏移地址</span><br><span class="line">mov cx , 256</span><br><span class="line">mov dx , 0x1f0</span><br><span class="line">.readw:</span><br><span class="line">in ax , dx</span><br><span class="line">mov [bx] , ax</span><br><span class="line">add bx , 2</span><br><span class="line">loop .readw</span><br></pre></td></tr></table></figure></li></ol><h2 id="比特位移动指令"><a href="#比特位移动指令" class="headerlink" title="比特位移动指令"></a>比特位移动指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">calc_segment_base:              ;计算16位段地址</span><br><span class="line">                                ;输入：DX:AX    返回AX</span><br><span class="line">    push dx</span><br><span class="line">    </span><br><span class="line">    add ax , [cs:phy_base]</span><br><span class="line">    adc dx , [cs:phy_base+0x02]</span><br><span class="line">    shr ax , 4</span><br><span class="line">    ror dx , 4</span><br><span class="line">    and ax , dx</span><br><span class="line">    or ax , dx</span><br><span class="line">    pop dx</span><br></pre></td></tr></table></figure><p>8086最大支持1M内存寻址，故地址有20位。我们将段地址高字节存放在寄存器<code>dx</code>低字节存放在寄存器<code>ax</code>，由于只能有20位故<code>dx</code>的高12位为0，由于是段地址故<code>ax</code>的第四位为0</p><h3 id="add-adr"><a href="#add-adr" class="headerlink" title="add  adr"></a>add  adr</h3><p>8086无法进行32位加法，需要<code>add</code>和<code>adc</code>配合使用，<code>adc</code>是带进位的加法指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add ax , [cs:phy_base]</span><br><span class="line">adc dx , [cs:phy_base+0x02]</span><br></pre></td></tr></table></figure><p>在进行add后有可能产生进位，导致标志寄存器<code>CF</code>有可能为1，<code>adc</code>指令除了将操作数相加外还要加标志寄存器<code>CF</code></p><h3 id="shr-ror-shl-rol"><a href="#shr-ror-shl-rol" class="headerlink" title="shr ror shl rol"></a>shr ror shl rol</h3><p>逻辑右移指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shr 寄存器/内存 , 立即数(8位)</span><br><span class="line">shr 寄存器/内存 , cl(存放移动的位数)</span><br></pre></td></tr></table></figure><p>空余bit用0填充，标志寄存器CF&#x3D;最后一个被移出的bit</p><p><img src="/img/%5B19.14%5D--%E6%AF%94%E7%89%B9%E4%BD%8D%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%8C%87%E4%BB%A4.pcwlenv_%E8%A7%86%E9%A2%91%E6%88%AA%E5%9B%BE_898.jpg"></p><p>循环右移指令ror</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ror 寄存器/内存 , 立即数(8位)</span><br><span class="line">ror 寄存器/内存 , cl(存放移动的位数)</span><br></pre></td></tr></table></figure><p><img src="/img/%5B19.14%5D--%E6%AF%94%E7%89%B9%E4%BD%8D%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%8C%87%E4%BB%A4.pcwlenv_%E8%A7%86%E9%A2%91%E6%88%AA%E5%9B%BE_1001.jpg"></p><p>与shr ror相对应的是shl rol 逻辑左移和循环左移，<code>sh -&gt; shift(挪动)</code> <code>ro -&gt; round圆</code></p><h2 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmp short 标号 ;机器码 EB 一字节相对地址</span><br><span class="line">jmp near 标号;机器码 E9 一个字相对地址</span><br><span class="line">jmp 标号;编译器根据距离目标位置的远近决定使用近转移还是短转移</span><br></pre></td></tr></table></figure><p>16位间接近转移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 寄存器/内存  ;直接转移到目标位置</span><br></pre></td></tr></table></figure><p>16位绝对远转移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 段地址:偏移地址</span><br></pre></td></tr></table></figure><p>16位间接绝对远转移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp far 内存;在指定的内存地址处必须包含目标位置的段地址和偏移地址，第一个字是偏移地址ip，第二个字是段地址cs</span><br></pre></td></tr></table></figure><h2 id="内存保留指令"><a href="#内存保留指令" class="headerlink" title="内存保留指令"></a>内存保留指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resb 立即数 ：保留立即数字节的内存,不初始化</span><br><span class="line"></span><br><span class="line">resw 立即数：保留立即数字的内存,不初始化</span><br><span class="line"></span><br><span class="line">resd 立即数：保留立即数双字的内存,不初始化</span><br></pre></td></tr></table></figure><h2 id="retf指令"><a href="#retf指令" class="headerlink" title="retf指令"></a>retf指令</h2><p>CPU执行retf指令时，进行下面两步操作：</p><ol><li>(IP) &#x3D; ((ss) * 16 + (sp))</li><li>(SP) &#x3D; (sp) + 2</li><li>(CS) &#x3D; ((ss) * 16 + (sp))</li><li>(SP) &#x3D; (sp) + 2</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈指令及寻址方式</title>
      <link href="/2023/08/04/4.%E6%A0%88%E6%8C%87%E4%BB%A4%E5%8F%8A%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/08/04/4.%E6%A0%88%E6%8C%87%E4%BB%A4%E5%8F%8A%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="栈指令及寻址方式"><a href="#栈指令及寻址方式" class="headerlink" title="栈指令及寻址方式"></a>栈指令及寻址方式</h1><h2 id="栈指令："><a href="#栈指令：" class="headerlink" title="栈指令："></a>栈指令：</h2><p>寄存器ss内存放着栈段地址，寄存器sp中保存着相对栈段寄存器ss的偏移地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push 寄存器/内存</span><br></pre></td></tr></table></figure><ol><li>sp &#x3D; (sp - 操作数的大小) ,在16位8086中压栈出栈必须是一个字</li><li>段寄存器ss左移4位，加上sp的偏移地址，生成物理地址</li><li>将操作数写入上述地址中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop  寄存器/内存</span><br></pre></td></tr></table></figure><ol><li>段寄存器ss左移4位，加上sp里的偏移地址，生成物理地址</li><li>从上述地址处取得数据，存入由操作数体统的目标位置处</li><li>sp &#x3D; sp + 2</li></ol><h2 id="逻辑指令"><a href="#逻辑指令" class="headerlink" title="逻辑指令"></a>逻辑指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">or 寄存器/内存 , 寄存器/内存/立即数</span><br><span class="line">and 寄存器/内存 , 寄存器/内存/立即数</span><br></pre></td></tr></table></figure><p>在执行l逻辑指令后：</p><blockquote><p>OF &#x3D; 0CF &#x3D; 0</p><p>SF ZF PF依据计算结果而定，AF的状态未定义</p></blockquote><h2 id="从1加到100并显示结果"><a href="#从1加到100并显示结果" class="headerlink" title="从1加到100并显示结果"></a>从1加到100并显示结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">;从1加到100并显示累加结果</span><br><span class="line">         jmp near start</span><br><span class="line"></span><br><span class="line"> message db &#x27;1+2+3+...+100=&#x27;</span><br><span class="line">        </span><br><span class="line"> start:</span><br><span class="line">         mov ax,0x7c0           ;设置数据段的段基地址 </span><br><span class="line">         mov ds,ax</span><br><span class="line"></span><br><span class="line">         mov ax,0xb800          ;设置附加段基址到显示缓冲区</span><br><span class="line">         mov es,ax</span><br><span class="line"></span><br><span class="line">         ;以下显示字符串 </span><br><span class="line">         mov si,message          </span><br><span class="line">         mov di,0</span><br><span class="line">         mov cx,start-message</span><br><span class="line">     @g:</span><br><span class="line">         mov al,[si]</span><br><span class="line">         mov [es:di],al</span><br><span class="line">         inc di</span><br><span class="line">         mov byte [es:di],0x07</span><br><span class="line">         inc di</span><br><span class="line">         inc si</span><br><span class="line">         loop @g</span><br><span class="line"></span><br><span class="line">         ;以下计算1到100的和 </span><br><span class="line">         xor ax,ax</span><br><span class="line">         mov cx,1</span><br><span class="line">     @f:</span><br><span class="line">         add ax,cx</span><br><span class="line">         inc cx</span><br><span class="line">         cmp cx,100</span><br><span class="line">         jle @f</span><br><span class="line"></span><br><span class="line">         ;以下计算累加和的每个数位 </span><br><span class="line">         xor cx,cx              ;设置堆栈段的段基地址</span><br><span class="line">         mov ss,cx</span><br><span class="line">         mov sp,cx</span><br><span class="line"></span><br><span class="line">         mov bx,10</span><br><span class="line">         xor cx,cx</span><br><span class="line">     @d:</span><br><span class="line">         inc cx</span><br><span class="line">         xor dx,dx</span><br><span class="line">         div bx</span><br><span class="line">         or dl,0x30</span><br><span class="line">         push dx</span><br><span class="line">         cmp ax,0</span><br><span class="line">         jne @d</span><br><span class="line"></span><br><span class="line">         ;以下显示各个数位 </span><br><span class="line">     @a:</span><br><span class="line">         pop dx</span><br><span class="line">         mov [es:di],dl</span><br><span class="line">         inc di</span><br><span class="line">         mov byte [es:di],0x07</span><br><span class="line">         inc di</span><br><span class="line">         loop @a</span><br><span class="line">       </span><br><span class="line">         jmp near $ </span><br><span class="line">       </span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">                 db 0x55,0xaa</span><br></pre></td></tr></table></figure><h2 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h2><p>基址寄存器 bx bp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov dx , [bp+2];ss为段寄存器</span><br><span class="line">mov dx , [bx+2];bs为栈寄存器</span><br></pre></td></tr></table></figure><p>不需要使用段超越前缀ss，当使用基址寄存器bp进行寻址时，默认将寄存器ss中内存作为段寄存器</p><h2 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h2><p>变址寄存器&#x2F;索引寄存器 si di</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov [si+0x10] , dx</span><br><span class="line">add ax , [di]</span><br><span class="line">xor word [si] , 0x800</span><br></pre></td></tr></table></figure><p>当指令中使用了变址寄存器并且没有使用段超越前缀，默认以bx中作为段地址</p><h2 id="基址变址寻址"><a href="#基址变址寻址" class="headerlink" title="基址变址寻址"></a>基址变址寻址</h2><p>当使用基址寄存器bs时，默认使用段寄存器bx作为段地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[bx + si]</span><br><span class="line">[bx + di]</span><br><span class="line">[bx + si + 偏移量]</span><br><span class="line">[bx + di + 偏移量]</span><br></pre></td></tr></table></figure><p>当使用基址寄存器bp时，默认使用段寄存器ss作为段地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[bp + si]</span><br><span class="line">[bp + di]</span><br><span class="line">[bp + si + 偏移量]</span><br><span class="line">[bp + di + 偏移量]</span><br></pre></td></tr></table></figure><h2 id="就地反转字符串内容"><a href="#就地反转字符串内容" class="headerlink" title="就地反转字符串内容"></a>就地反转字符串内容</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    jmp start;</span><br><span class="line"></span><br><span class="line">string db &#x27;abcdefghigklmnopqrstuvwxyz&#x27;</span><br><span class="line"></span><br><span class="line">start:  </span><br><span class="line">    mov ax , 0x7c0;</span><br><span class="line">    mov ds , ax;</span><br><span class="line"></span><br><span class="line">    mov bx , string;</span><br><span class="line">    mov si , 0;</span><br><span class="line">    mov di , start - string - 1;</span><br><span class="line"></span><br><span class="line">rever:</span><br><span class="line">    mov ah , [bx + si];</span><br><span class="line">    mov al , [bx + di];</span><br><span class="line">    mov [bx + si] , al;</span><br><span class="line">    mov [bx + di] , ah;</span><br><span class="line">    inc si;</span><br><span class="line">    dec di;</span><br><span class="line">    cmp si , di;</span><br><span class="line">    jl rever;</span><br><span class="line"></span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">    times 510 - ($-$$) db 0;</span><br><span class="line">    db 0x55 , 0xaa;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机中的负数</title>
      <link href="/2023/08/01/3.%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%B4%9F%E6%95%B0/"/>
      <url>/2023/08/01/3.%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%B4%9F%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机中的负数"><a href="#计算机中的负数" class="headerlink" title="计算机中的负数"></a>计算机中的负数</h1><h2 id="sub指令"><a href="#sub指令" class="headerlink" title="sub指令"></a>sub指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub 寄存器/内存 寄存器/内存/立即数</span><br></pre></td></tr></table></figure><p>将左操作数减去右操作数结果保留在左操作数中</p><p>两个操作数宽度必须一致且不可同时为内存地址</p><h2 id="neg指令"><a href="#neg指令" class="headerlink" title="neg指令"></a>neg指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neg 寄存器/内存</span><br></pre></td></tr></table></figure><p>计算 0 - 操作数，并将结果写回操作数中</p><h2 id="无符号与有符号的运算"><a href="#无符号与有符号的运算" class="headerlink" title="无符号与有符号的运算"></a>无符号与有符号的运算</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax , -1</span><br><span class="line">mob ax , 65535</span><br></pre></td></tr></table></figure><p>这两条指令导致ax内全为1，但是ax到底表示 -1 还是 65535呢？解释很简单，计算机只是机器并不关心，程序由程序员编写，一个数是否有符号程序员应该清楚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ah , 0xf0  ;11110000 可以解释为240 / -16</span><br><span class="line">inc ah         ;11110001 可以解释为241 / -15</span><br><span class="line"></span><br><span class="line">mov ah , 0xf0  </span><br><span class="line">add ah , 0x03  ;11110011 可以解释为243 / -13</span><br></pre></td></tr></table></figure><ul><li>对于大多数指令既适用于无符号整数，也适用于有符号整数。指令执行的结果不管是用无符号整数来解释还是用用符号整数来解释都是正确的</li><li>但是也有一些指令不能同时应付无符号数和有符号数，需要根据实际情况选择对应的是否有符号版本，如：无符号数乘法<code>mul</code>有符号乘法<code>imul</code>，以及无符号除法<code>div</code>有符号除法<code>idiv</code></li></ul><h2 id="idiv指令"><a href="#idiv指令" class="headerlink" title="idiv指令"></a>idiv指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idiv 寄存器/内存</span><br></pre></td></tr></table></figure><p>规则诶呀div指令相同</p><ul><li>如果被除数和除数的符号相同，商为正数，否则商为负数</li><li>余数的符号始终和被除数相同</li></ul><h2 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a>符号扩展</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax , -6002</span><br><span class="line">mov bx , -10</span><br><span class="line">idiv bx</span><br></pre></td></tr></table></figure><p>在执行idiv之前要将ax的符号位扩展到dx上，使用以下指令</p><ul><li>cbw ： 将AL中的有符号数扩展到AX</li><li>cwde：将AX中的有符号数扩展到EAX</li><li>cdqe： 将EAX中的有符号数扩展到RAX</li><li>cwd：  将AX中有符号数扩展到DX：AX</li><li>cdq：  将EAX中有符号数扩展到EDX：EAX</li><li>cdo：  将RAX中有符号数扩展到EDX：RAX</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax , -6002</span><br><span class="line">cwd</span><br><span class="line">mov bx , -10</span><br><span class="line">idiv bx</span><br></pre></td></tr></table></figure><h2 id="flag寄存器"><a href="#flag寄存器" class="headerlink" title="flag寄存器"></a>flag寄存器</h2><p><img src="/img/%5B16.1%5D--8086%E7%9A%84%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8.pcwlenv_%E8%A7%86%E9%A2%91%E6%88%AA%E5%9B%BE_57.jpg"></p><p>CF(Carry Flag)进位标志：当一个算术操作在结果的最高位产生进位或者借位时，此标志是1否则是0</p><blockquote><p>如 <code>AL </code>内容是二进制 <code>1000 0000 </code>执行指令 <code>add al , al</code> 后，<code>CF = 1</code></p></blockquote><p>PF(parity Flag)奇偶标志：当一个算数操作数的结果在低8位中有偶数个1，此标志为1否则为0</p><blockquote><p>若AL中内容是二进制 0010 0110 则指令</p><p>xor al , 3 执行后PF&#x3D;0</p></blockquote><p>OF(Overflow Flag)溢出标志位：对任何一个算数操作，<strong>假定它进行的是有符号运算</strong>。那么，当结果超出目标位置所能容纳的最大正数或者最小负数时，此标志为1，表示有符号整数运算结果以及溢出，否则为0</p><blockquote><p>若AH中内容时二进制 1111 1101 则指令</p><p>add ah , 5 执行后，OF &#x3D; 0</p></blockquote><p>ZF(Zero Flag)零标志：当运算结果为0时，此标志为1，否则为0</p><blockquote><p>mov ax , 25</p><p>sub ax , 25    ;此指令执行后 ZF &#x3D; 1</p></blockquote><p>SF(Sign Flag)：用运算结果的最高位来设置此标志位(一般来说，这一位是有符号数的符号位，0表示正数，1表示负数)</p><blockquote><p>mov ah , 127</p><p>add ah , 1      ;此指令执行后，SF&#x3D;1</p></blockquote><p>AF(Adjust Flag)：当一个算术操作在结果的位3产生进位或者借位时，此标志是1否则是0。此标志用于二进制编码的十进制算法里(BCD编码)，用的很少</p><p>现有指令对标志位的影响：</p><ul><li>cbw&#x2F;cwde&#x2F;cdqe&#x2F;cwd&#x2F;cdq&#x2F;cqo(位拓展指令)，不影响任何标志位</li><li>cld：DF&#x3D;0，对CF OF ZF SF AF PF的影响未定义</li><li>std：DF&#x3D;1，不影响其他标志位</li><li>inc&#x2F;dec：<strong>CF标志不受影响</strong>，对OF SF ZF AF PF的影响依据计算结果</li><li>add&#x2F;sub：OF SF ZF AF CF PF 的状态依据计算结果而定</li><li>div&#x2F;idiv：对CF OF SF ZF AF PF 的影响未定义</li><li>mov&#x2F;movs：不影响任何标志位</li><li>neg：如果操作数为，则CF&#x3D;0，否则CF&#x3D;1，对OF SF ZF AF PF的影响依据计算结果</li><li>xor：OF&#x3D;0 CF&#x3D;0 对SF ZF PF依照计算结果</li></ul><h2 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h2><ul><li>js：  符号标志 SF 为1则转移<br>jns：符号标志 SF 为0则转移 </li><li>jz：  零标志ZF为1则转移<br>jnz：零标志ZF为0则转移</li><li>jo：  溢出标志位OF为1则转移<br>jno：溢出标志位OF为1则转移</li><li>jc：  进位标志位CF为1则转移<br>jnc：进位标志位CF为0则转移</li><li>jp：  奇偶标志PF为1则转移<br>jnp：奇偶标志PF为0则转移</li><li>jcxz(jump if CX is Zero)：当CX寄存器中的内容为0时则转移。执行这条指令时，处理器先测试CX是否为0<br><code>jcxz show  ;若cx为0转移到标号show</code></li></ul><p>转移指令本身不影响任何标志位</p><h2 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp 寄存器/内存 , 寄存器/内存/立即数</span><br></pre></td></tr></table></figure><p>cmp指令与sub指令相似，只是不保留计算结果，只设置标志位</p><p>常与条件转移指令结合使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp dh , 0</span><br><span class="line">jl</span><br></pre></td></tr></table></figure><p>JE、JZ：结果为零则跳转(相等时跳转)ZF&#x3D;1<br>JNE、JNZ：结果不为零则跳转(不相等时跳转) ZF&#x3D;0<br>JS ：结果为负则跳转SF&#x3D;1<br>JNS ：结果为非负则跳转SF&#x3D;0<br>JP, JPE：结果中1的个数为偶数则跳转PF&#x3D;1<br>JNP, JPO：结果中1的个数为偶数则跳转PF&#x3D;0<br>JO：结果溢出了则跳转OF&#x3D;1<br>JNO：结果没有溢出则跳转OF&#x3D;0<br>JB, JNAE：小于则跳转 (无符号数)CF&#x3D;1<br>JNB, JAE：大于等于则跳转 (无符号数)CF&#x3D;0<br>JBE, JNA：小于等于则跳转 (无符号数)CF&#x3D;1 or ZF&#x3D;1<br>JNBE, JA：大于则跳转(无符号数)CF&#x3D;0 and ZF&#x3D;0<br>JL, JNGE：小于则跳转 (有符号数)SF≠ OF<br>JNL, JGE：大于等于则跳转 (有符号数)SF&#x3D;OF<br>JLE, JNG：小于等于则跳转 (有符号数)ZF&#x3D;1 or SF≠ OF<br>JNLE, JG：大于则跳转(有符号数)ZF&#x3D;0 and SF&#x3D;OF</p><p><img src="/img/Snipaste_2023-08-01_17-25-58.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环批量传送和条件转移</title>
      <link href="/2023/07/31/2.%E5%BE%AA%E7%8E%AF%E6%89%B9%E9%87%8F%E4%BC%A0%E9%80%81%E5%92%8C%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB/"/>
      <url>/2023/07/31/2.%E5%BE%AA%E7%8E%AF%E6%89%B9%E9%87%8F%E4%BC%A0%E9%80%81%E5%92%8C%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="循环批量传送和条件转移"><a href="#循环批量传送和条件转移" class="headerlink" title="循环批量传送和条件转移"></a>循环批量传送和条件转移</h1><h2 id="串传送指令"><a href="#串传送指令" class="headerlink" title="串传送指令"></a>串传送指令</h2><p><strong>movsb 和 movsw</strong></p><p>传送前的准备工作：</p><p>设置元数据和目标数据位置</p><blockquote><p>DS：SI：原始数据串的段地址：偏移地址</p><p>ES：DI： 目标位置的短地址：偏移地址</p></blockquote><p>设置传送方向：</p><blockquote><p>通过设置flags寄存器第10位DF(direction flag)标志位,可以通过<code>cld</code>指令将DF标志位置为0，此时传送方向是从低地址到高地址(正向)。<code>std</code>指令将DF标志位置为1此时传送方向是从高地址到低地址(逆向)</p><p>在设置完方向后，每次执行movsb或movsw后对于的si di会指向下一待处理位置</p></blockquote><p>设置重复次数：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rep 指令    ;rep=repeat重复</span><br></pre></td></tr></table></figure><p>重复对应的指令，重复的次数位于寄存器cx中，每次执行检测cx中的值，只有在cx不为0时才执行这条指令</p></blockquote><h2 id="和"><a href="#和" class="headerlink" title="$ 和 $$"></a>$ 和 $$</h2><p>$：当前指令的汇编地址</p><p>$$：当前所在段的起始的汇编地址</p><h2 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loop 标号</span><br></pre></td></tr></table></figure><p>loop指令的机器码：E2 8位相对偏移量</p><p>在8086中，loop指令的执行过程</p><blockquote><p>将寄存器 cx 的内容减一</p><p>如果 cx 的内容不为零，转移到指定的位置处执行，否则按顺序执行后面的指令</p></blockquote><h2 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h2><ul><li>寄存器BX在设计之初的作用之一就是用来提供数据访问的基地址，所以又叫基址寄存器(Base Address Register)</li><li>在设计8086cpu时，每个寄存器都有自己的太特殊用途，比如AX时累加器(Accumulator)，与它有关的指令还会做指令长度的优化；CX是计数寄存器(count)；DX是数据(Date)寄存器，除了作为通用寄存器使用外还专门用于和外设之间进行数据传送；SI是原索引寄存器(Source Index);DI是目标索引(Destination Index)寄存器，用于数据传送操作</li></ul><h2 id="inc-dec指令"><a href="#inc-dec指令" class="headerlink" title="inc  dec指令"></a>inc  dec指令</h2><p>inc &#x3D; incream 递增</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inc 寄存器/内存</span><br><span class="line">dec 寄存器/内存</span><br></pre></td></tr></table></figure><p>inc 用于将寄存器或内存地址中的值加一</p><p>dec 用于将寄存器或内存地址中的值减一</p><p>在8086中如果要用寄存器来提供偏移地址，只能使用 <strong>bx si di bp</strong>，不能采用其他寄存器</p><blockquote><p>mov [ax] , dl   ;非法</p><p>mov [dx] , bl   ;非法</p><p>mov word [bx] , 0x10  ;合法</p></blockquote><h2 id="基址变址寻址"><a href="#基址变址寻址" class="headerlink" title="基址变址寻址"></a>基址变址寻址</h2><p>基址寄存器bx bp</p><p>变址寄存器si di</p><p>在8086中只允许几种基址变址的组合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bx + si</span><br><span class="line">bx + di</span><br><span class="line">bp + si</span><br><span class="line">bp + di</span><br></pre></td></tr></table></figure><h2 id="jns指令"><a href="#jns指令" class="headerlink" title="jns指令"></a>jns指令</h2><p>当SF标志位为0时跳转，为1时不跳转继续执行下面指令</p><p>SF位为符号位，当运算结果最高位为0时SF为0，当运算结果最高位为1时SF为1</p><h2 id="用合理的方法显示数字"><a href="#用合理的方法显示数字" class="headerlink" title="用合理的方法显示数字"></a>用合理的方法显示数字</h2><p>使用循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">    jmp start</span><br><span class="line"></span><br><span class="line">mytest db &#x27;L&#x27; , 0x07,&#x27;a&#x27;,0x07,&#x27;b&#x27;,0x07,&#x27;e&#x27;,0x07,&#x27;l&#x27;,0x07,&#x27; &#x27;,0x07,&#x27;o&#x27;,0x07,</span><br><span class="line">       db &#x27;f&#x27; , 0x07,&#x27;f&#x27;,0x07,&#x27;s&#x27;,0x07,&#x27;e&#x27;,0x07,&#x27;t&#x27;,0x07,&#x27;:&#x27;,0x07</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    ;---------------------------显示Labe offset:</span><br><span class="line">    mov ax , 0x7c0</span><br><span class="line">    mov ds , ax</span><br><span class="line"></span><br><span class="line">    mov ax , 0xb800</span><br><span class="line">    mov es , ax</span><br><span class="line"></span><br><span class="line">    cld              ;将DF标志位清0表示方向为从低字节到高字节    </span><br><span class="line">    mov si , mytest</span><br><span class="line">    mov di , 0</span><br><span class="line"></span><br><span class="line">    mov cx , (start - mytest)/2  ;设置循环次数</span><br><span class="line">    rep movsw                    ;执行movsw cx内数据的次数</span><br><span class="line">    </span><br><span class="line">    ;-----------------------------------------------</span><br><span class="line">    mov ax , number             ;得到标号的汇编地址</span><br><span class="line"></span><br><span class="line">    ;分解各个数位</span><br><span class="line">    mov bx , ax</span><br><span class="line">    mov cx , 5                    ;循环次数</span><br><span class="line">    mov si , 10                   ;除数</span><br><span class="line"></span><br><span class="line">dight:</span><br><span class="line">    xor dx , dx                   ;与ax一起形成被除数</span><br><span class="line">    div si</span><br><span class="line">    mov [bx] , dl                 ; 保存数位</span><br><span class="line">    inc bx</span><br><span class="line">    loop dight</span><br><span class="line"></span><br><span class="line">    mov cx , 5</span><br><span class="line">    ;显示各个数位</span><br><span class="line"> show:</span><br><span class="line">    dec bx              ;取到对于的字符数字</span><br><span class="line">    mov al , [bx]     </span><br><span class="line">    add al , 0x30       ;转换为对应的字符</span><br><span class="line">    mov ah , 04         ;对应的字符属性</span><br><span class="line">    mov [es:di] , ax    ;es是显存对应的段地址，di是rep movsw后的di</span><br><span class="line">    add di , 2          ;找到写下一个字符的位置</span><br><span class="line">    loop show</span><br><span class="line"></span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">number db 0,0,0,0,0</span><br><span class="line"></span><br><span class="line">    times 510-($-$$) db 0</span><br><span class="line">    db 0x55 , 0xaa</span><br></pre></td></tr></table></figure><p>使用跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">    jmp start</span><br><span class="line"></span><br><span class="line">mytest db &#x27;L&#x27; , 0x07,&#x27;a&#x27;,0x07,&#x27;b&#x27;,0x07,&#x27;e&#x27;,0x07,&#x27;l&#x27;,0x07,&#x27; &#x27;,0x07,&#x27;o&#x27;,0x07, ; \是续行符编译器将其合并位一行</span><br><span class="line">       db &#x27;f&#x27; , 0x07,&#x27;f&#x27;,0x07,&#x27;s&#x27;,0x07,&#x27;e&#x27;,0x07,&#x27;t&#x27;,0x07,&#x27;:&#x27;,0x07</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    ;---------------------------显示Labe offset:</span><br><span class="line">    mov ax , 0x7c0</span><br><span class="line">    mov ds , ax</span><br><span class="line"></span><br><span class="line">    mov ax , 0xb800</span><br><span class="line">    mov es , ax</span><br><span class="line"></span><br><span class="line">    cld              ;将DF标志位清0表示方向为从低字节到高字节    </span><br><span class="line">    mov si , mytest</span><br><span class="line">    mov di , 0</span><br><span class="line"></span><br><span class="line">    mov cx , (start - mytest)/2  ;设置循环次数</span><br><span class="line">    rep movsw                    ;执行movsw cx内数据的次数</span><br><span class="line">    </span><br><span class="line">    ;-----------------------------------------------</span><br><span class="line">    mov ax , number             ;得到标号的汇编地址</span><br><span class="line"></span><br><span class="line">    ;分解各个数位</span><br><span class="line">    mov bx , ax</span><br><span class="line">    mov cx , 5                    ;循环次数</span><br><span class="line">    mov si , 10                   ;除数</span><br><span class="line"></span><br><span class="line">dight:</span><br><span class="line">    xor dx , dx                   ;与ax一起形成被除数</span><br><span class="line">    div si</span><br><span class="line">    mov [bx] , dl                 ; 保存数位</span><br><span class="line">    inc bx</span><br><span class="line">    loop dight</span><br><span class="line"></span><br><span class="line">    mov bx , number</span><br><span class="line">    mov si , 4</span><br><span class="line"></span><br><span class="line">show:</span><br><span class="line">    mov al , [bx + si]            ;基址和变址的组合</span><br><span class="line">    add al , 0x30</span><br><span class="line">    mov ah , 0x04</span><br><span class="line">    mov [es:di] , ax</span><br><span class="line">    add di , 2</span><br><span class="line">    dec si</span><br><span class="line">    jns show</span><br><span class="line"></span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">number db 0,0,0,0,0</span><br><span class="line"></span><br><span class="line">    times 510-($-$$) db 0</span><br><span class="line">    db 0x55 , 0xaa</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在屏幕上显示数字</title>
      <link href="/2023/07/30/1.%E5%B0%86%E6%95%B0%E5%AD%97%E6%89%93%E5%8D%B0%E5%88%B0%E5%B1%8F%E5%B9%95%E4%B8%8A/"/>
      <url>/2023/07/30/1.%E5%B0%86%E6%95%B0%E5%AD%97%E6%89%93%E5%8D%B0%E5%88%B0%E5%B1%8F%E5%B9%95%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="在屏幕上显示数字"><a href="#在屏幕上显示数字" class="headerlink" title="在屏幕上显示数字"></a>在屏幕上显示数字</h1><h2 id="div除法指令"><a href="#div除法指令" class="headerlink" title="div除法指令"></a>div除法指令</h2><p> 无符号除法指令，div</p><p> 指令：div 除数所在的寄存器或者内存地址</p><ul><li><p>如果在指令中指定的是8位寄存器或者8位操作数的内存地址，意味着被除数在寄存器AX中</p></li><li><p>相除后，商在寄存器AL里，余数在寄存器AH里</p></li><li><p>如果指令中指定的是16位寄存器或者16位操作数的内存地址，则意味着被除数是32位的，低16位在寄存器AX里，高16位在寄存器DX里</p></li><li><p>相除后，商在寄存器AX里，余数在寄存器DX里</p></li><li><p>如果指令中指定的是32位寄存器或者32位操作数的内存地址，则意味着被除数是64位的，低32位在寄存器EAX里，高32位在寄存器EDX里(80806不支持)</p></li><li><p>相除后，商在寄存器EAX里，余数在寄存器EDX里</p></li><li><p>如歌指令着指定的是64位寄存器或者64位操作数的内存地址，则意味着被除数是128位的，低64位在寄存器RAX中共，高64位在寄存器EDX里</p></li><li><p>相除后，商在寄存器RAX里，余数在寄存器RDX里</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;计算378除37结果</span><br><span class="line">mov ax , 378</span><br><span class="line">mov bl , 37</span><br><span class="line">div bl        ;al = 10(商)  ah = 8(余数)</span><br></pre></td></tr></table></figure><h2 id="xor指令"><a href="#xor指令" class="headerlink" title="xor指令"></a>xor指令</h2><p>xor &#x3D; exclusive or 异或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xor 寄存器/内存 , 寄存器/内存/立即数</span><br></pre></td></tr></table></figure><p>计算结果保存在左操作数中，两操作数指定的数据长度必须相同</p><h2 id="add指令"><a href="#add指令" class="headerlink" title="add指令"></a>add指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add 寄存器/内存地址 ， 寄存器/捏成/立即数</span><br></pre></td></tr></table></figure><p>两个操作数的长度必须相同，而且<strong>两个操作数不可以同时为内存地址</strong></p><p>在屏幕上显示数字65535</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">    mov cx , 0    ;设置段地址为0</span><br><span class="line">    mov ds , cx</span><br><span class="line">    mov bx , 10   ; 65535 / 10</span><br><span class="line"></span><br><span class="line">    mov ax , 65535</span><br><span class="line"></span><br><span class="line">    xor dx , dx</span><br><span class="line">    div bx        ; ax:6553  dx5</span><br><span class="line">    add dl , 0x30 ;将数字转换位对于的数字字符</span><br><span class="line">    mov [0x7c00 + buffer] , dl</span><br><span class="line"></span><br><span class="line">    xor dx , dx</span><br><span class="line">    div bx        ;ax:655 dx:3</span><br><span class="line">    add dx , 0x30</span><br><span class="line">    mov [0x7c00 + buffer + 1] , dl</span><br><span class="line"></span><br><span class="line">    xor dx , dx</span><br><span class="line">    div bx       ;ax:65 dx:5</span><br><span class="line">    add dx , 0x30</span><br><span class="line">    mov [0x7c00 + buffer + 2] , dl;</span><br><span class="line"></span><br><span class="line">    xor dx , dx</span><br><span class="line">    div bx      ;ax:6 dx:5</span><br><span class="line">    add dl , 0x30</span><br><span class="line">    mov [0x7c00 + buffer + 3] , dl;</span><br><span class="line">    </span><br><span class="line">    xor dx , dx</span><br><span class="line">    div bx      ;ax:0 dx:6</span><br><span class="line">    add dl , 0x30</span><br><span class="line">    mov [0x7c00 + buffer + 4] , dl;</span><br><span class="line"></span><br><span class="line">;-------输出到屏幕上---------------</span><br><span class="line"></span><br><span class="line">    mov cx , 0xb800</span><br><span class="line">    mov es , cx</span><br><span class="line">    </span><br><span class="line">    mov al , [0x7c00 + buffer + 4]</span><br><span class="line">    mov byte [es:0x00] , al       ;使用段超越前缀指定内存访问的段寄存器</span><br><span class="line">    mov byte [es:0x01] , 0x2f</span><br><span class="line"></span><br><span class="line">    mov al , [0x7c00 + buffer + 3]</span><br><span class="line">    mov byte [es:0x02] , al       ;使用段超越前缀指定内存访问的段寄存器</span><br><span class="line">    mov byte [es:0x03] , 0x2f</span><br><span class="line"></span><br><span class="line">    mov al , [0x7c00 + buffer + 2]</span><br><span class="line">    mov byte [es:0x04] , al       ;使用段超越前缀指定内存访问的段寄存器</span><br><span class="line">    mov byte [es:0x05] , 0x2f</span><br><span class="line"></span><br><span class="line">    mov al , [0x7c00 + buffer + 1]</span><br><span class="line">    mov byte [es:0x06] , al       ;使用段超越前缀指定内存访问的段寄存器</span><br><span class="line">    mov byte [es:0x07] , 0x2f</span><br><span class="line"></span><br><span class="line">    mov al , [0x7c00 + buffer + 0]</span><br><span class="line">    mov byte [es:0x08] , al       ;使用段超越前缀指定内存访问的段寄存器</span><br><span class="line">    mov byte [es:0x09] , 0x2f</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    jmp again</span><br><span class="line">;--------------------------------------</span><br><span class="line"></span><br><span class="line">buffer db 0,0,0,0,0  ;标号buffer代表第一个字节0的地址</span><br><span class="line"></span><br><span class="line">current:</span><br><span class="line">    times 510-(current - start) db 0</span><br><span class="line">    db 0x55 , 0xaa</span><br></pre></td></tr></table></figure><ul><li><p>在NASM汇编中，标号可以由 字母 数字 _ $ # @ . ? 组成</p></li><li><p>其中可以打头的字符是 字母 . _ ?</p></li><li><p>冒号后面可以放一个冒号，但它不是标号的一部分</p></li><li><p>在需要两个操作数的指令中，如果至少有一个是寄存器。则不需要长度修饰符</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah , bl</span><br><span class="line">mov [buffer] , ax</span><br><span class="line">xor byte [buffer] , 0x55</span><br></pre></td></tr></table></figure></blockquote></li><li><p>如果只有一个操作数且不是寄存器，必须使用长度修饰符</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div word [divisor]</span><br></pre></td></tr></table></figure></blockquote></li><li><p>伪指令 db dw dd dq 分别用于定义 8 16 32 64 位的数据</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db 0x55</span><br><span class="line">dw 0x55aa</span><br><span class="line">dd 0xabcd1234</span><br><span class="line">dq 0x12345678aabbccdd</span><br></pre></td></tr></table></figure></blockquote></li><li><p>伪指令times用来重复后面的指令若干次</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">times 2 mov ax , bx</span><br><span class="line">等价于</span><br><span class="line">mov ax , bx</span><br><span class="line">mov ax, bx</span><br></pre></td></tr></table></figure></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变长模板</title>
      <link href="/2023/07/25/%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/07/25/%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="变参模板"><a href="#变参模板" class="headerlink" title="变参模板"></a>变参模板</h1><h2 id="变参模板实列"><a href="#变参模板实列" class="headerlink" title="变参模板实列"></a>变参模板实列</h2><p>可以将模板参数定义成能够接受任意多个模板参数的情况。这一类模板被称为变参模板，可以通过调用下面代码中的 print()函数来打印一组数量和类型都不确定的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T , <span class="keyword">typename</span> ...Types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T firstArgs , Types... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;firstArgs&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当传入一个或多个参数时会调用模板函数，这里通过将第一个参数单独声明，就可以先打印第一个参数，然后再递归的调用<code>print()</code>，args被称为剩余参数，是一个函数参数包<code>Types ...args</code>，使用了模板参数包定义类型Types，为了结束递归，重载了不接受参数的非模板函数 print()</p><h2 id="变参和非变参模板的重载"><a href="#变参和非变参模板的重载" class="headerlink" title="变参和非变参模板的重载"></a>变参和非变参模板的重载</h2><p>上述print还可以通过如下方法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;arg&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> ...Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T firstArg , Types...args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(firstArg);</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当两个函数模板的区别只在于尾部的参数包的时候，会优先选择没有尾部参数包的那一个函数模板</p><h2 id="sizeof…-运算符"><a href="#sizeof…-运算符" class="headerlink" title="sizeof… 运算符"></a>sizeof… 运算符</h2><p>C++11 为变参模板引入了一种新的 sizeof 运算符：<code>sizeof...</code> 它会被扩展成参数包中所包含的参数数目，<code>sizeof...</code>既可以用于模板参数包也可以同于函数参数包，且二者效果相同(返回值相同)，均返回当前参数包参数的个数</p><p>这样可能会让你觉得，可以不使用为了结束递归而重载的不接受参数的非模板函数 print()， 只要在没有参数的时候不去调用任何函数就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>… Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span> <span class="params">(T firstArg, Types… args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; firstArg &lt;&lt; ’\n’;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">sizeof</span>…(args) &gt; <span class="number">0</span>) </span><br><span class="line">&#123; <span class="comment">//error if sizeof…(args)==0</span></span><br><span class="line"><span class="built_in">print</span>(args…); <span class="comment">// and no print() for no arguments declared</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法是错误的，，因为通常函数模板中 if 语句的两个分支都会被实例化。是否使用被实例化出来的代码是在运行期间（run-time）决定的，而是否实例化代码是在编译期间 （compile-time）决定的。因此如果在只有一个参数的时候调用 print()函数模板，虽然<code>args...</code>为空，if 语句中的 <code>print(args...)</code>也依然会被实例化，但此时没有定义不接受参数的 print()函数， 因此会报错</p><h2 id="变参下标"><a href="#变参下标" class="headerlink" title="变参下标"></a>变参下标</h2><p>下面的函数通过一组变参下标来访问第一个参数中相应的元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C ,<span class="keyword">typename</span> ...Idx&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printElems</span><span class="params">(C <span class="type">const</span> &amp; coll , Idx... idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(coll[idx]...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; coll = &#123;<span class="string">&quot;good&quot;</span>,<span class="string">&quot;times&quot;</span>,<span class="string">&quot;say&quot;</span>&#125; ;</span><br><span class="line">    <span class="built_in">printElems</span>(coll,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>);  <span class="comment">//相当于 print(coll[2],coll[0],coll[1])</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以将非类型模板参数声明成参数包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span>… Idx, typenam&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printIdx</span> <span class="params">(C <span class="type">const</span>&amp; coll)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">print</span>(coll[Idx]…);</span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;std::string&gt; coll = &#123;<span class="string">&quot;good&quot;</span>, <span class="string">&quot;times&quot;</span>, <span class="string">&quot;say&quot;</span>, <span class="string">&quot;bye&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">printIdx</span>&lt;<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>&gt;(coll);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++ 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++常见面试题</title>
      <link href="/2023/06/14/c++%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/06/14/c++%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="c-常见面试题"><a href="#c-常见面试题" class="headerlink" title="c++常见面试题"></a>c++常见面试题</h1><ul><li>c++ this 指针干什么用的?</li></ul><p>一个类型定义了很多对象，对象之间拥有各自的成员变量，共享一套成员方法。this指针用来区分是那个对象的成员变量和那个对象调用了成员方法( 成员方法的第一个参数由编译器默认加上该对象的地址值(this指针) )</p><ul><li>c++的new和delete，什么时候用new[] 申请，可以用delete释放</li></ul><p>如果是自定义类型<strong>且提供了析构函数</strong>，会在对象数组前占用8字节用于记录对象的个数(强调：一定要有析构函数)，那么使用<code>new[]</code>时一定要使用<code>delete[]</code>，当未提供析构函数时，类型为自定义类型，使用new[]开辟内存可以使用delete释放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;A()  %#x  \n&quot;</span>,<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="comment">//~A() &#123;&#125;</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">执行：A * pa = <span class="keyword">new</span> A[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>当不存在析构函数时，pa所指内存及前8字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd fd fd fd   <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>   <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>   <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>   <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 后全为<span class="number">0</span></span><br></pre></td></tr></table></figure><p>当存在析构函数时，pa所指内存及前8字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>   <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>   <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>   <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>   <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  后全为<span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>c++ static关键字作用</li></ul><p>static修饰全局变量，函数时将其作用域变为当前文件可见，在符号表中符号的作用域就从 global 变为 local</p><p>static修饰局部变量（一般为函数内的静态变量）在第一次使用时分配内存并初始化。这里的变量包含内置数据类型和自定义类型的对象，位于 .bss段 或 .data段，符号作用域为 local</p><p>static修饰类成员变量，是的该变量为类中公有可以通过类直接访问。修饰类成员方法，可以直接通过类访问而不需要对象</p><ul><li>c++如何防止内存泄漏</li></ul><p>内存泄漏是指分配的内存没有释放，也没有机会释放，如忘记，或在释放之前抛异常。解决方式是使用智能指针</p><ul><li>STL中迭代器失效问题</li></ul><p>迭代器不允许一边读一边写。当通过迭代器插入一个元素，所有迭代器失效。当通过迭代器删除一个元素时，当前删除位置到后面所有元素的迭代器就都失效了。</p><p>当通过迭代器更新容器元素以后，要及时对迭代器进行更新，insert &#x2F; erase 方法都会返回新位置的迭代器</p><ul><li>构造函数和析构函数能不能是虚函数</li></ul><p>构造函数不能是虚函数，对象在构造函数之后产生，没有对象就没有 vfptr</p><p>析构函数可以，当基类中拥有虚函数时，必须其析构函数必须为析构函数</p><ul><li>宏和内联函数的区别</li></ul><p>#define 的处理时机是在预处理  inline 的处理时机是在编译阶段 ， inline在函数调用点展开，通过函数的实参把函数代码直接展开调用，节省了函数调用栈的开销，但inline只是一种建议</p><ul><li>拷贝构造为什么传引用不传值</li></ul><p>若存在拷贝构造为 ：<code>A &amp;operator=(const A other)</code> 当此函数被调用时，先发生拷贝构造，用于构造 A other，然后调用operator&#x3D;。若使用引用，则避免了拷贝构造带来的开销</p><ul><li>如何实现一个不可以被继承的类</li></ul><p>派生类的构造过程为：基类构造-&gt;派生类构造，故只需可将基类构造函数私有化</p><p>c++11 中引入final 用于阻止类的继承和虚函数的重写</p><ul><li>什么时纯虚函数，为什么要有纯虚函数，虚函数表放在那里</li></ul><p>virtual void func() &#x3D; 0;  func就为纯虚函数，拥有纯虚函数的类称为抽象类（不能定义对象，但可以定义指针或引用）</p><p>纯虚函数一般定义在基类中，基类不代表任意实体，它主要的作用之一是给所有的派生类保留统一的接口，方便使用多态，基类也不需要实例化</p><p>虚函数表位于 .rodata 段</p><ul><li>c++中的const 以及和 static 的区别</li></ul><p>const修饰类型具有只读属性。const 定义的被称为常量，当用真正的常量初始化时在编译过程中，把出现名字相同的值进行替换，当用变量初始化时不会发生变化</p><p>const还可以修饰成员方法，其 this 指针所指对象将具有const属性，这样普通对象和常对象就都可以调用了，但是无法修改器成员变量</p><ul><li>deque的底层原理</li></ul><p>底层是一个动态开辟的二维数组，存在两个宏定义：<code>#define MAP_SIZE 2#define QUE_SIZE(T) 4096/sizeof(T)</code> ，其中MAP_SIZE是一维数组的个数，QUE_SIZE 是二维数组的大小</p><ul><li>异常机制是怎么回事</li></ul><p>try {可能抛出异常的代码}  catch(类型){捕获相应异常类型对象，进行处理，完成后代码继续运行}，处理过程是栈展开，首先查看当前函数栈中是否存在对应的catch若有则处理，没有则销毁当前函数栈，向调用方抛出异常</p><ul><li>早绑定和晚绑定</li></ul><p>早绑定：普通函数的绑定，对象调用虚函数</p><p>晚绑定：用指针或引用调用虚函数</p><ul><li>智能指针交叉引用问题怎么解决</li></ul><p>在定义对象时使用强智能指针 share_ptr 引用对象时使用弱智能指针 weak_ptr</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用设计模式</title>
      <link href="/2023/06/09/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/06/09/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="常用设计模式"><a href="#常用设计模式" class="headerlink" title="常用设计模式"></a>常用设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>定义：<strong>一个类不管创建多少次对象，永远只能得到该类型一个对象的实例</strong>，常用到的如，日志模块，数据库模块</p><p>分类：</p><ul><li>饿汉式单例模式：还没有获取实例对象，实例对象就已经产生了</li><li>懒汉式单例模式：唯一的实例对象直到第一次获取时才创建</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式单例：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span><span class="comment">//#3 定义静态成员方法(不需要通过对象调用)，获取类唯一实例对象的接口方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton instance; <span class="comment">// #2 定义一个唯一的类的实例对象,位于数据段</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Singleton</span>()   <span class="comment">// #1 构造函数私有化</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton Singleton::instance;  <span class="comment">//静态成员变量类内声明类外定义</span></span><br></pre></td></tr></table></figure><p>单例的饿汉实现是线程安全的，因为对象在使用前就已经创建出来了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Singleton</span>()  </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//未调用getInstance时，instance一直为nullptr</span></span><br><span class="line"><span class="comment">//当调用getInstance时，生成唯一对象并为instance赋值</span></span><br></pre></td></tr></table></figure><p>上述懒汉式单例模式并非线程安全，getInstance函数并非可重入函数。若要改为线程安全的懒汉式单例模式只需修改getInstance函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;  <span class="comment">//保证只能实例化一个对象</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> Singleton* <span class="keyword">volatile</span> instance;   <span class="comment">//防止线程缓冲影响</span></span><br></pre></td></tr></table></figure><p>全局变量、文件域的静态变量和类的静态成员变量在main执行之前的静态初始化过程中分配内存并初始化；<strong>局部静态变量（一般为函数内的静态变量）在第一次使用时分配内存并初始化。这里的变量包含内置数据类型和自定义类型的对象</strong>。</p><p>非局部静态变量一般在main执行之前的静态初始化过程中分配内存并初始化，可以认为是线程安全的；</p><p>局部静态变量在编译时，在g++中通过查看汇编指令发现已经添加了线程互斥操作，故是线程安全的</p><p>故懒汉式单例模式也可以改写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* <span class="keyword">volatile</span> instance;</span><br><span class="line">    <span class="built_in">Singleton</span>()  </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>定义：</p><p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。简单来说，使用了C++<strong>多态</strong>的特性，将存在<strong>继承</strong>关系的类，通过一个工厂类创建对应的子类（派生类）对象。在项目复杂的情况下，可以便于子类对象的创建。</p><p>分类：</p><ul><li>简单工厂：simple factory</li><li>工厂方法：factory method</li><li>抽象工厂：abstract factory</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Car</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">            : _name(std::move(name)) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> : <span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BMW</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">            : Car(std::move(name)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;获取BMW&quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> : <span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Audi</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">            : Car(std::move(name)) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;获取AUdi&quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">CarType</span> &#123;</span><br><span class="line">    BMW, AUDI</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpalFactory</span> &#123;  <span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Car *<span class="title">createCar</span><span class="params">(CarType ct)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (ct) &#123;</span><br><span class="line">            <span class="keyword">case</span> CarType::BMW:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BMW</span>(<span class="string">&quot;X1&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CarType::AUDI:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(<span class="string">&quot;A6&quot;</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cerr &lt;&lt; <span class="string">&quot;Usage argv is not right&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    SimpalFactory factory;</span></span><br><span class="line"><span class="comment">    Car *bmw = factory.createCar(CarType::BMW);</span></span><br><span class="line"><span class="comment">    Car *audi = factory.createCar(CarType::AUDI);</span></span><br><span class="line"><span class="comment">    bmw-&gt;show();delete bmw;</span></span><br><span class="line"><span class="comment">    audi-&gt;show();delete audi;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function">unique_ptr&lt;SimpalFactory&gt; <span class="title">factory</span><span class="params">(<span class="keyword">new</span> SimpalFactory())</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;Car&gt; <span class="title">p1</span><span class="params">(factory-&gt;createCar(CarType::BMW))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单工厂模式在扩展时要修改许多东西，当通过多态增加一种汽车时，工厂类对应的枚举值要增加，要修改工厂类中createCar函数。比较麻烦不符合对扩展关闭的原则，改进为工厂方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂方法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Car</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">            : _name(std::move(name)) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> : <span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BMW</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">            : Car(std::move(name)) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;获取BMW&quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> : <span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Audi</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">            : Car(std::move(name)) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;获取AUdi&quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Car *<span class="title">createCar</span><span class="params">(string name)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMWFactory</span> : <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Car *<span class="title">createCar</span><span class="params">(string name)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BMW</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudiFactory</span> : <span class="keyword">public</span> Factory &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Car * <span class="title">createCar</span><span class="params">(string name)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;Factory&gt; <span class="title">bmwfty</span><span class="params">(<span class="keyword">new</span> BMWFactory())</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;Factory&gt; <span class="title">audifty</span><span class="params">(<span class="keyword">new</span> AudiFactory())</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;Car&gt; <span class="title">p1</span><span class="params">(bmwfty-&gt;createCar(<span class="string">&quot;X6&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;Car&gt; <span class="title">p2</span><span class="params">(audifty-&gt;createCar(<span class="string">&quot;A6&quot;</span>))</span></span>;</span><br><span class="line">    p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    p2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于工厂方法，当扩展时，只需继承Car通过多态实现实体后，继承Factory通过多态实现createCar。</p><p>但是实际情况并非如此，一个工厂可能及生产手机又生产耳机或者生产音响，对于工厂方法来说，每个工厂只能生产一个物品，当物品多且相似时这种设计是不好的，因此产生了抽象工厂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Car</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">            : _name(std::move(name)) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> : <span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BMW</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">            : Car(std::move(name)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;获取BMW&quot;</span> &lt;&lt; _name &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> : <span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Audi</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">            : Car(std::move(name)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;获取AUdi&quot;</span> &lt;&lt; _name &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bmwLight</span> : <span class="keyword">public</span> Light &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;BMW light&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">audiLight</span> : <span class="keyword">public</span> Light &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Audi light&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Car *<span class="title">createCar</span><span class="params">(string name)</span> </span>= <span class="number">0</span>;   <span class="comment">//创建汽车</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Light *<span class="title">createCarLight</span><span class="params">()</span> </span>= <span class="number">0</span>;       <span class="comment">//创建灯</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMWFactory</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Car *<span class="title">createCar</span><span class="params">(string name)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BMW</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Light *<span class="title">createCarLight</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> bmwLight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudiFactory</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Car *<span class="title">createCar</span><span class="params">(string name)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Light *<span class="title">createCarLight</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> audiLight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;AbstractFactory&gt; <span class="title">bmwfty</span><span class="params">(<span class="keyword">new</span> BMWFactory)</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;AbstractFactory&gt; <span class="title">Audifty</span><span class="params">(<span class="keyword">new</span> AudiFactory)</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;Car&gt; <span class="title">p1</span><span class="params">(bmwfty-&gt;createCar(<span class="string">&quot;x1&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;Car&gt; <span class="title">p2</span><span class="params">(Audifty-&gt;createCar(<span class="string">&quot;A6&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;Light&gt; <span class="title">p3</span><span class="params">(bmwfty-&gt;createCarLight())</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;Light&gt; <span class="title">p4</span><span class="params">(Audifty-&gt;createCarLight())</span></span>;</span><br><span class="line">    p1-&gt;<span class="built_in">show</span>();p2-&gt;<span class="built_in">show</span>();p3-&gt;<span class="built_in">show</span>();p4-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是抽象工厂也存在一些问题，当bmw工厂存在特殊的方法（其他工厂没有时），此时需要在Abstractory基类中添加纯虚函数，但是只有bmw工厂给出了具体的实现，其他工厂必须重写否则无法通过编译，一般实现为空</p><blockquote><p>简单工厂把对象的创建封装在一个接口函数里面，通过传入不同的标志，返回创建的对象，客户不用自己new对象，不用了解对象创建的细节</p><p>工厂方法Factory基类提供了一个纯虚函数（创造产品），定义派生类（具体产品的工厂）负责创建对应的产品，可以做到不同的产品在不同的工厂里创建</p><p>抽象工厂把有关联的属于一个产品族的所有产品创建接口函数，放在一个抽象工厂中，派生类（具体产品的工厂）应该负责创建该产品族里的所有产品</p></blockquote><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>通过代理类来控制实际对象的访问权限</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSite</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">//免费电影</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span> </span>= <span class="number">0</span>;   <span class="comment">//vip电影</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//用卷购买的电影</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixbugVideoSite</span> : <span class="keyword">public</span> VideoSite &#123;  <span class="comment">//FixbugVideoSite 中存在所有的实现</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;freeMovie&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;vipMovie&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ticketMovie&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreeVideoSiteProxy</span> : <span class="keyword">public</span> VideoSite &#123;  <span class="comment">//普通用户代理类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FreeVideoSiteProxy</span>() &#123; pVideo = <span class="keyword">new</span> FixbugVideoSite; &#125;  <span class="comment">//指向实现类</span></span><br><span class="line">    ~<span class="built_in">FreeVideoSiteProxy</span>() &#123; <span class="keyword">delete</span> pVideo; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span></span>&#123;  <span class="comment">//实现访问控制</span></span><br><span class="line">        pVideo-&gt;<span class="built_in">freeMovie</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;vip视频，您无权访问&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;需要买卷&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VideoSite *pVideo;  <span class="comment">//存有基类指针</span></span><br><span class="line">    <span class="comment">//FixbugVideoSite video  通过组合的方式也可以，但是这这能代理FixbugVideoSite类，降低了灵活性，</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vipVideoSiteProxy</span> : <span class="keyword">public</span> VideoSite&#123; <span class="comment">//vip用户代理类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vipVideoSiteProxy</span>()&#123; p = <span class="keyword">new</span> FixbugVideoSite ;&#125;</span><br><span class="line">    ~<span class="built_in">vipVideoSiteProxy</span>() &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span></span>&#123;  <span class="comment">//实现访问控制</span></span><br><span class="line">        p-&gt;<span class="built_in">freeMovie</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        p-&gt;<span class="built_in">vipMovie</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;需要买卷&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VideoSite* p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">watchMovie</span><span class="params">(unique_ptr&lt;VideoSite&gt; &amp; ptr)</span></span>&#123;</span><br><span class="line">    ptr-&gt;<span class="built_in">freeMovie</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">vipMovie</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">ticketMovie</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">unique_ptr&lt;VideoSite&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> FreeVideoSiteProxy)</span></span>;   <span class="comment">//直接访问代理对象，而非实际对象</span></span><br><span class="line">    <span class="function">unique_ptr&lt;VideoSite&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> vipVideoSiteProxy)</span></span>;</span><br><span class="line">    <span class="comment">//p1-&gt;freeMovie();    p1-&gt;vipMovie();     p1-&gt;ticketMovie();</span></span><br><span class="line">    <span class="comment">//p2-&gt;freeMovie();    p2-&gt;vipMovie();     p2-&gt;ticketMovie();</span></span><br><span class="line">    <span class="built_in">watchMovie</span>(p1);</span><br><span class="line">    <span class="built_in">watchMovie</span>(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式是为了增加现有类的功能。但是增加现有类功能的另一个方法是增加一个子类</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;      <span class="comment">//抽象基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//三个实体的派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> : <span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;这是一个BMW汽车，配置有：基本配置&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> : <span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;这是一个Audi汽车，配置有：基本配置&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Benz</span> : <span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;这是一个Benz汽车，配置有：基本配置&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator01</span> : <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteDecorator01</span>(Car* p) : <span class="built_in">pCar</span>(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pCar-&gt;<span class="built_in">show</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;新增方法01&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Car* pCar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator02</span> : <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteDecorator02</span>(Car* p) : <span class="built_in">pCar</span>(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pCar-&gt;<span class="built_in">show</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;新增方法02&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Car * pCar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Car * p1 = <span class="keyword">new</span> <span class="built_in">ConcreteDecorator01</span>(<span class="keyword">new</span> <span class="built_in">BMW</span>());   <span class="comment">//对具有普通功能进行装饰，使其新增功能1</span></span><br><span class="line">    p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    Car * p2 = <span class="keyword">new</span> <span class="built_in">ConcreteDecorator01</span>(<span class="keyword">new</span> <span class="built_in">ConcreteDecorator02</span>(<span class="keyword">new</span> BMW));</span><br><span class="line">    p2-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>让不兼容的接口可以在一起工作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VGA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">play</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::string <span class="title">getType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;VGA&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV01</span> : <span class="keyword">public</span> VGA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;通过VGA 接口连接投影 并播放&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>   <span class="comment">//只支持VGA接口的电脑类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PlayVideo</span><span class="params">(VGA *pVGA)</span>  <span class="comment">//由于只支持VGA接口，故参数只能是VGA的指针或引用</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pVGA-&gt;<span class="built_in">play</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HDMI</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">play</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV02</span> : <span class="keyword">public</span> HDMI &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;通过HDMI 接口连接投影 并播放&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于电脑（VGA）投影仪（HDMI）无法直接相连</span></span><br><span class="line"><span class="comment">// 需要使用适配器，将 VGA 信号转换为 HDMI 信号</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VGA2HDMI</span> : <span class="keyword">public</span> VGA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VGA2HDMI</span>(HDMI *p) : <span class="built_in">pHDMI</span>(p) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        pHDMI-&gt;<span class="built_in">play</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HDMI *pHDMI;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Computer c;</span><br><span class="line">    c.<span class="built_in">PlayVideo</span>(<span class="keyword">new</span> TV01);</span><br><span class="line">    c.<span class="built_in">PlayVideo</span>(<span class="keyword">new</span> <span class="built_in">VGA2HDMI</span>(<span class="keyword">new</span> <span class="built_in">TV02</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>主要关注的是对象的一对多关系，也就是多个对象都依赖一个对象，当该对象的状态发生改变时，其他对象都能接受到相应的通知</p><p>如：我们有一组数据，可以通过这组数据生成对应的曲线图，柱状图，圆饼图。当数据改变时，这三个图都要发生变化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 处理消息的接口</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第一个观察者实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer1</span> : <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (msgid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Observer1 recv 1 msg!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Observer1 recv 2 msg!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Observer1 recv unknow msg!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第二个观察者实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer2</span> : <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (msgid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Observer2 recv 2 msg!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Observer2 recv unknow msg!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第三个观察者实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer3</span> : <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (msgid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Observer3 recv 1 msg!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Observer3 recv 3 msg!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Observer3 recv unknow msg!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 给主题增加观察者对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addObserver</span><span class="params">(Observer* obser, <span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_subMap[msgid].<span class="built_in">push_back</span>(obser);</span><br><span class="line"><span class="comment">/*auto it = _subMap.find(msgid);</span></span><br><span class="line"><span class="comment">if (it != _subMap.end())</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">it-&gt;second.push_back(obser);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">list&lt;Observer*&gt; lis;</span></span><br><span class="line"><span class="comment">lis.push_back(obser);</span></span><br><span class="line"><span class="comment">_subMap.insert(&#123; msgid, lis &#125;);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主题检测发生改变，通知相应的观察者对象处理事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dispatch</span><span class="params">(<span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> it = _subMap.<span class="built_in">find</span>(msgid);</span><br><span class="line"><span class="keyword">if</span> (it != _subMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (Observer *pObser : it-&gt;second)</span><br><span class="line">&#123;</span><br><span class="line">pObser-&gt;<span class="built_in">handle</span>(msgid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, list&lt;Observer*&gt;&gt; _subMap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Subject subject;</span><br><span class="line">Observer *p1 = <span class="keyword">new</span> <span class="built_in">Observer1</span>();</span><br><span class="line">Observer *p2 = <span class="keyword">new</span> <span class="built_in">Observer2</span>();</span><br><span class="line">Observer *p3 = <span class="keyword">new</span> <span class="built_in">Observer3</span>();</span><br><span class="line"></span><br><span class="line">subject.<span class="built_in">addObserver</span>(p1, <span class="number">1</span>);</span><br><span class="line">subject.<span class="built_in">addObserver</span>(p1, <span class="number">2</span>);</span><br><span class="line">subject.<span class="built_in">addObserver</span>(p2, <span class="number">2</span>);</span><br><span class="line">subject.<span class="built_in">addObserver</span>(p3, <span class="number">1</span>);</span><br><span class="line">subject.<span class="built_in">addObserver</span>(p3, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> msgid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输入消息id:&quot;</span>;</span><br><span class="line">cin &gt;&gt; msgid;</span><br><span class="line"><span class="keyword">if</span> (msgid == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">subject.<span class="built_in">dispatch</span>(msgid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++ 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对齐支持</title>
      <link href="/2023/05/23/%E5%AF%B9%E9%BD%90%E6%94%AF%E6%8C%81/"/>
      <url>/2023/05/23/%E5%AF%B9%E9%BD%90%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h1 id="对齐支持"><a href="#对齐支持" class="headerlink" title="对齐支持"></a>对齐支持</h1><h2 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h2><p>回忆一个经典案例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HowManyBytes</span>&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(char):&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">char</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(int):&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">int</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(HowManyBytes):&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(HowManyBytes)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;offset of char a:&quot;</span>&lt;&lt;<span class="built_in">offsetof</span>(HowManyBytes,a)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;offset of int b:&quot;</span>&lt;&lt;<span class="built_in">offsetof</span>(HowManyBytes,b)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define offsetof(type,member)   //不能以标准实现，必须由编译器实现</span></span><br><span class="line"><span class="comment">宏 offsetof 会展开为 std::size_t 类型的整数常量表达式，它的值是从指定类型对象开始到它指定的子对象的字节数偏移，并包括可能有的填充位。</span></span><br><span class="line"><span class="comment">如果type不是POD类型，那么offsetof的结果是未定义的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="built_in">sizeof</span>(<span class="type">char</span>):<span class="number">1</span></span><br><span class="line"><span class="built_in">sizeof</span>(<span class="type">int</span>):<span class="number">4</span></span><br><span class="line"><span class="built_in">sizeof</span>(HowManyBytes):<span class="number">8</span></span><br><span class="line">offset of <span class="type">char</span> a:<span class="number">0</span></span><br><span class="line">offset of <span class="type">int</span> b:<span class="number">4</span></span><br></pre></td></tr></table></figure><p>可以发现成员b并不是紧跟着成员a的，这是由于C&#x2F;C++的int类型数据要求对齐到4字节，即要求int类型数据必须放在一个能够整除4的地址上，而char要求对齐到1字节。这就造成了成员a之后的3字节空间被空出， 通常我们也称因为对齐而造成的内存留空为填充数据（padding data）。在C++中，每个类型的数据除去长度等属性之外，都还有一项“被隐藏”属性，那就是对齐方式。对于每个内置或者自定义类型，都存在一 个特定的对齐方式。对齐方式通常是一个整数，它表示的是一个类型的对象存放的内存地址应满足的条件。</p><p>对齐的数据在读写上会有性能上的优势。比如频繁使用的数据如果与处理器的高速缓存器大小对齐，有可能提高缓存性能。而更为普遍 的，在一些平台上，不按照字对齐的数据会造成数据读取效率低下。</p><p>在C++语言中，我们可以通过sizeof 查询数据长度，但C++语言却没有对对齐方式有关的查询或者设定进行标准化，而语言本身又允许自定义类型、模板等诸多特性。编译器无法完全找到正确的对齐方式，这会在使用时造成困难。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ColorVector</span> &#123;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line">    <span class="type">double</span> g;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">double</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用C++11中的alignof来查询ColorVector的对齐方式</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;alignof(ColorVector):&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(ColorVector) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">alignof运算符：alignof(类型标识符)  返回size_t类型值</span></span><br><span class="line"><span class="comment">返回由类型标识所指示的类型的任何实例所要求的对齐字节数,该类型可以是完整对象类型、元素类型完整的数组类型或者到这些类型之一的引用类型。</span></span><br><span class="line"><span class="comment">如果类型是引用类型，那么运算符返回被引用类型的对齐要求；如果类型是数组类型，那么返回元素类型的对齐要求。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">输出：<span class="built_in">alignof</span>(ColorVector):<span class="number">8</span></span><br></pre></td></tr></table></figure><p>我们可以看到 ColorVecto 依然是对齐到8字节的地址边界上。为了能够高效地读写 ColorVector 大小的数据，我们最好能将其对齐在32字节的地址边界上。<strong>我们利用C++11新提供的修饰符alignas 来重新设定ColorVector的对齐方式</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">32</span>)ColorVector&#123;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line">    <span class="type">double</span> g;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">double</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//使用C++11中的alignof来查询ColorVector的对齐方式</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;alignof(ColorVector):&quot;</span>&lt;&lt;<span class="built_in">alignof</span>(ColorVector)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="built_in">alignof</span>(ColorVector):<span class="number">32</span></span><br></pre></td></tr></table></figure><p>指定数据ColorVector对齐到32字节的地址边界上，只需要声明alignas(32)即可</p><h2 id="c-11的-alignof-和-alignas"><a href="#c-11的-alignof-和-alignas" class="headerlink" title="c++11的 alignof  和 alignas"></a>c++11的 alignof  和 alignas</h2><p>C++11在新标准中为了支持对齐，主要引入两个关键字：操作符 alignof、对齐描述符（alignment-specifier） alignas。</p><p>alignof：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InComplete</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Completed</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> b;</span><br><span class="line">    <span class="keyword">auto</span> &amp;c = b;</span><br><span class="line">    <span class="type">char</span> d[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//对内置类型和完整类型使用alignof</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">alignof</span>(<span class="type">int</span>) &lt;&lt; endl<span class="comment">//4</span></span><br><span class="line">         &lt;&lt; <span class="built_in">alignof</span>(Completed) &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line"><span class="comment">//对变量、引用或者数组使用alignof</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">alignof</span>(a) &lt;&lt; endl<span class="comment">//4</span></span><br><span class="line">         &lt;&lt; <span class="built_in">alignof</span>(b) &lt;&lt; endl<span class="comment">//8</span></span><br><span class="line">         &lt;&lt; <span class="built_in">alignof</span>(c) &lt;&lt; endl<span class="comment">//8，与b相同</span></span><br><span class="line">         &lt;&lt; <span class="built_in">alignof</span>(d) &lt;&lt; endl;<span class="comment">//1,与元素要求相同</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;alignof(Incomplete)&lt;&lt;endl;  本句无法通过编译，Incomplete类型不完整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>alignas：</p><p>alignas 既可以接受常量表达式，也可以接受类型作为参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alignas</span>(<span class="type">double</span>) <span class="type">char</span> c;  &lt;==&gt;  <span class="built_in">alignas</span>(<span class="built_in">alignof</span>(<span class="type">double</span>)) <span class="type">char</span> c;</span><br></pre></td></tr></table></figure><p>我们在使用常量表达式作为 alignas 的操作符的时候，其结果必须是以2 的自然数幂次作为对齐值。</p><p>对齐描述符可以作用于各种数据。具体来说，可以修饰变量、类的数据成员等，而位域（bit field），函数以及用register声明的变量则不可以。</p><p>采用了模板的方式来实现一个固定容量但是大小随着所用的数据类型变化的容器类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="built_in">alignof</span>(<span class="type">double</span>) * <span class="number">4</span>)ColorVector &#123;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line">    <span class="type">double</span> g;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">double</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//固定容量的模板数组</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixedCapacityArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T t)</span> </span>&#123;<span class="comment">/*在data中加入t变量*/</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//一些其他成员函数、成员变量等</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">alignas</span><span class="params">(T)</span> data[1024] </span>= &#123;<span class="number">0</span>&#125;;   <span class="comment">//根据模板参数类型指定对齐方式，且控制数组大小为1024字节</span></span><br><span class="line"><span class="comment">//对应的数组元素个数为：length=1024/sizeof(T);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FixedCapacityArray&lt;<span class="type">char</span>&gt; arrCh;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;alignof(char):&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;alignof(arrCh.data):&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(arrCh.data) &lt;&lt; endl;</span><br><span class="line">    FixedCapacityArray&lt;ColorVector&gt; arrCV;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;alignof(ColorVector):&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(ColorVector) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;alignof(arrCV.data):&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(arrCV.data) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="built_in">alignof</span>(<span class="type">char</span>):<span class="number">1</span></span><br><span class="line"><span class="built_in">alignof</span>(arrCh.data):<span class="number">1</span></span><br><span class="line"><span class="built_in">alignof</span>(ColorVector):<span class="number">32</span></span><br><span class="line"><span class="built_in">alignof</span>(arrCV.data):<span class="number">1</span></span><br></pre></td></tr></table></figure><p>FixedCapacityArray固定 使用1024字节的空间，但由于模板的存在，可以实例化为各种版本。这样一来，我们可以在相同的内存使用量的前提下，做出多种类型 （内置或者自定义）版本的数组。</p><p>在STL 库中，还内建了std::align函数来动态地根据指定的对齐方式调整数据块的位置。函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>*</span></span><br><span class="line"><span class="function"><span class="title">align</span><span class="params">(<span class="type">size_t</span> __align, <span class="type">size_t</span> __size, <span class="type">void</span>*&amp; __ptr, <span class="type">size_t</span>&amp; __space)</span> <span class="keyword">noexcept</span></span></span><br></pre></td></tr></table></figure><p>该函数在 ptr 指向的大小为 space 的内存中进行对齐方式的调整，将 ptr 开始的 size大小的数据调整为按 align 对齐。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ColorVector</span> &#123;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line">    <span class="type">double</span> g;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">double</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> <span class="type">const</span> size = <span class="number">100</span>;</span><br><span class="line">    ColorVector *<span class="type">const</span> vec = <span class="keyword">new</span> ColorVector[size];</span><br><span class="line">    <span class="type">void</span> *p = vec;</span><br><span class="line">    <span class="type">size_t</span> sz = size;</span><br><span class="line">    <span class="type">void</span> *aligned = <span class="built_in">align</span>(<span class="built_in">alignof</span>(<span class="type">double</span>) * <span class="number">4</span>, size, p, sz);</span><br><span class="line">    <span class="comment">//在指针p指向的空间大小为sz的内存中，将大小为size的内存以alignof(double)*4的方式对齐</span></span><br><span class="line">    <span class="keyword">if</span> (aligned != <span class="literal">nullptr</span>)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">alignof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c++11还提供了aligned_storage 及 aligned_union，函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>＜std::<span class="type">size_t</span> Len,std::<span class="type">size_t</span> Align=<span class="comment">/*default-alignment*/</span>＞</span><br><span class="line"><span class="keyword">struct</span> aligned_storage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>＜std::<span class="type">size_t</span> Len,<span class="keyword">class</span>...Types＞</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">aligned_union</span>;</span><br></pre></td></tr></table></figure><p><strong>还没有理解aligned_storage 及 aligned_union 的正确使用。</strong></p><p>参考：书籍《深入理解c++11》</p><p>内存对齐概念：<a href="https://www.cnblogs.com/zhao-zongsheng/p/9099603.html">https://www.cnblogs.com/zhao-zongsheng/p/9099603.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变长模板</title>
      <link href="/2023/05/20/%E5%8F%98%E9%95%BF%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/05/20/%E5%8F%98%E9%95%BF%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="变长模板"><a href="#变长模板" class="headerlink" title="变长模板"></a>变长模板</h1><h2 id="变长函数和变长模板参数"><a href="#变长函数和变长模板参数" class="headerlink" title="变长函数和变长模板参数"></a>变长函数和变长模板参数</h2><p>我们知道C++11已经支持了C99的变长宏，但是，<strong>无论是宏，还是变长参数(C语言中存在)，整个机制的设计上， 没有任何一个对于传递参数的类型是了解的</strong>。我们可以看看变长函数的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">SumOfFloat</span><span class="params">(<span class="type">int</span> count,...)</span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">    va_start(ap,count);      <span class="comment">//获得变长列表的句柄ap</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">    sum+=va_arg(ap,<span class="type">double</span>);  <span class="comment">//每次获得一个参数</span></span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,SumOfFloat(<span class="number">3</span>,<span class="number">1.2f</span>,<span class="number">3.4</span>,<span class="number">5.6</span>));<span class="comment">//10.200000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参考下面链接，熟悉下C语言中变长函数的写法及原理</span></span><br></pre></td></tr></table></figure><p>只有使用表达式<code>va_arg(ap,double)</code>的时候，我们 才按照类型（实际是按类型长度）去变长参数列表中获得指定参数，以及为ap找到下一个参数的位置。对于printf函数来说，如何打印则得益于传递在字符串中的形如“%s”、“%d”这样的转义字，这都是对连续内存的一种解释，因此，对于一些没有定义转义字的非POD的数据来说，使用变长函数就会导致未定义的程序行为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;hello%s&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;msg&quot;</span>,std::<span class="built_in">string</span>(<span class="string">&quot; world&quot;</span>));  </span><br><span class="line"><span class="comment">//程序将报错，</span></span><br><span class="line"><span class="comment">//无法通过可变参数函数传递非平凡类型“std::string”（又名“basic_string&lt;char&gt;”）的对象； 调用将在运行时中止</span></span><br></pre></td></tr></table></figure><p>对于c++这种强调类型的语言来说，是不愿意看到的，即使他是正确的。c++需要一种更现代的传参方式即<strong>类型和变量同时能够传递给变长参数的函数</strong>。一个好的方式就是使用C++的函数模板，在C++98 中，标准要求函数模板始终具有数目确定的模板参数及函数参数。</p><p>c++11中标准模板库存在 <code>tuple</code>类，在C++11中，tuple是pair类的一种更为泛化的表现形式。比起 pair，tuple是可以接受任意多个不同类型的元素的集合。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;<span class="type">double</span>,<span class="type">char</span>,std::string&gt; cloolctions</span><br></pre></td></tr></table></figure><p>因为tuple可以接受任意多的参数。此外，和pair类似地，我们也可以更为简单地使用C++11的模板函数make_tuple来创造一个tuple 模板类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">make_tuple</span>(<span class="number">9.8</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&quot;gravity&quot;</span>);</span><br></pre></td></tr></table></figure><p>在C++11中我们看到了所谓的变长模板（variadic template）的实现。</p><h2 id="变长模板：模板参数包和函数参数包"><a href="#变长模板：模板参数包和函数参数包" class="headerlink" title="变长模板：模板参数包和函数参数包"></a>变长模板：模板参数包和函数参数包</h2><p>变长模板的的语法，以tuple为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Elements&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br></pre></td></tr></table></figure><p>在c++11中，我们使用 … 来表示参数的变长的，<code>Elements</code>被称为模板参数包，有了模板参数包，类模板tuple就可以接受多个参数做为模板参数，如：<code>tuple&lt;int , char , double&gt; </code>,编译器则可以将多个模板参数打包成为“单个的”模板参数包 Elements，即Elements在进行模板推导的时候，就是一个包含int、char 和double三种类型类型集合。</p><p>与普通模板相似，模板参数包也可以是非类型的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如：</span></span><br><span class="line"><span class="keyword">template</span>＜<span class="type">int</span>...A＞<span class="keyword">class</span> <span class="title class_">NonTypeVariadicTemplate</span>&#123;&#125;;</span><br><span class="line">NonTypeVariadicTemplate＜<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>＞ntvt;</span><br><span class="line"><span class="comment">//相当于：</span></span><br><span class="line"><span class="keyword">template</span>＜<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>＞<span class="keyword">class</span> <span class="title class_">NonTypeVariadicTemplate</span>&#123;&#125;;</span><br><span class="line">NonTypeVariadicTemplate＜<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>＞ntvt;</span><br><span class="line"><span class="comment">//除了类型的模板参数包和非类型的模板参数包，模板参数包实际上还是模板类型的,之后讨论</span></span><br></pre></td></tr></table></figure><p>一个模板参数包在模板推导时会被认为是模板的单个参数（虽然实际 上它将会打包任意数量的实参）。为了使用模板参数包，我们总是需 要将其解包（unpack）。在C++11中，这通常是通过一个名为包扩展 （pack expansion）的表达式来完成。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tempalte &lt;<span class="keyword">typename</span> ...A&gt; <span class="keyword">class</span> <span class="title class_">Template</span>:<span class="keyword">private</span> B &lt;A...&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>...A</code>是表示课接受多个模板参数，参数包名为 A ， <code>A...</code>是一个包拓展，参数包会在包扩展的位置展开为多个参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt; <span class="keyword">class</span> <span class="title class_">B</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...A&gt; <span class="keyword">class</span> <span class="title class_">Template</span>:<span class="keyword">private</span> B&lt;A...&gt;&#123;&#125;;</span><br><span class="line">Template&lt;X,Y&gt; xy;</span><br></pre></td></tr></table></figure><p>如何才能利用模板参数包及包扩展，使得模板能够接受任意多的模板参数，且均能实例化出有效的对象呢？</p><p>在C++11中，实现tuple模板的方式给出了一种使用模板参数包的答案。这个思路是使用数学的归纳法，转换为计算机能够实现的手段则是递归。通过定义递归的模板偏特化定义，我们可以使得模板参数包在实例化时能够层层展开，直到参数包中的参数逐渐耗尽或到达某个数量的边界为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...Elements&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>;   <span class="comment">//变长模板的声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,<span class="keyword">typename</span>...Tail&gt;     <span class="comment">//递归的偏特化定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head,Tail...&gt;:<span class="keyword">private</span> tuple&lt;Tail...&gt;&#123;</span><br><span class="line">Head head;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;&#123;&#125;;                  <span class="comment">//边界条件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tuple&lt;<span class="type">int</span>, <span class="type">double</span>,<span class="type">float</span>&gt; t;</span><br><span class="line">    <span class="comment">//t.head = 20;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/Snipaste_2023-05-19_19-08-11.png"></p><p>我们声明了变长模板类tuple，其只包含一个模板参数，即Elements模板参数包。此外，我们又偏特化地定义了一个双参数的tuple的版本。该偏特化版本的tuple包含了两个参数，一个是类型模板参数Head，另一个则是模板参数包Tail，将Head型数据作为第一成员，而将使用了包扩展表达式的模板类tuple＜Tail…＞作为tuple＜Head,Tail… ＞的私有基类。这样一来，当程序员实例化一个形如tuple＜ double,int,char,float＞的类型时，则会引起基类的递归构造，这样的递归在tuple的参数包为0个的时候会结束。</p><p>使用非类型模板的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">long</span>...nums&gt;<span class="keyword">struct</span> <span class="title class_">Multiply</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">long</span> first,<span class="type">long</span>...last&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiply</span>&lt;first,last...&gt;&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">long</span> val=first*Multiply&lt;last...&gt;::val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiply</span>&lt;&gt;&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">long</span> val=<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;Multiply&lt;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&gt;::val&lt;&lt;endl;<span class="comment">//120</span></span><br><span class="line">    cout&lt;&lt;Multiply&lt;<span class="number">22</span>,<span class="number">44</span>,<span class="number">66</span>,<span class="number">88</span>,<span class="number">9</span>&gt;::val&lt;&lt;endl;<span class="comment">//50599296</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c++11中我们还可以声明变长的模板函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T ...args)</span></span>;</span><br></pre></td></tr></table></figure><p>在C++11中， 标准要求函数参数包必须唯一，且是函数的最后一个参数（模板参数包没有这样的要求）。</p><p>有了模板参数包和函数参数包两个概念，我们就可以实现C中变长函数的功能了。我们可以看看这个C++11提案中实现新的printf的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*s==<span class="string">&#x27;%&#x27;</span>&amp;&amp;*++s!=<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;invalid format string:missing arguments&quot;</span>);</span><br><span class="line">        cout&lt;&lt;*s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*s,T value,Args...args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*s==<span class="string">&#x27;%&#x27;</span>&amp;&amp;*++s!=<span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">            cout&lt;&lt;value;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Printf</span>(++s,args...);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;*s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;extra arguments provided to Printf&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">Printf</span>(<span class="string">&quot;hello%s\n&quot;</span>,<span class="built_in">string</span>(<span class="string">&quot;world&quot;</span>));<span class="comment">//hello world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于变长函数(printf)，变长函数模板(Printf)不会丢弃参数的类型信息。因此重载的cout的操作符 &lt;&lt; 总是可以将具有类型的变量正确地打印出来。</p><h2 id="变长模板进阶"><a href="#变长模板进阶" class="headerlink" title="变长模板进阶"></a>变长模板进阶</h2><p>c++11中可以展开参数包的位置：</p><blockquote><p>表达式   初始化列表</p><p>基类描述列表类成员初始化列表</p><p>模板参数列表通用属性列表</p><p>lambda函数的捕获列表</p></blockquote><p>一些有趣的包拓展语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Arg&gt; <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Arg&amp;&amp;...)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//解包为：Arg1&amp;&amp; , ... , Argn&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...A&gt; <span class="keyword">class</span> <span class="title class_">T</span>:<span class="keyword">private</span> B&lt;A&gt;...&#123;&#125;</span><br><span class="line"><span class="comment">//当使用 T&lt;X,Y&gt; 实例化时,会解包为</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&lt;X,Y&gt;:<span class="keyword">private</span> B&lt;X&gt; , <span class="keyword">private</span> B&lt;Y&gt; &#123;&#125;   <span class="comment">//会解包为多重继承</span></span><br></pre></td></tr></table></figure><p>类似的现象也会发生在函数模板上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...T&gt;<span class="function"><span class="type">void</span> <span class="title">DummyWrapper</span><span class="params">(T...t)</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function">T <span class="title">pr</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...A&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VTPrint</span><span class="params">(A...a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">DummyWrapper</span>(<span class="built_in">pr</span>(a)...);<span class="comment">//包扩展解包为pr(1),pr(&quot;,&quot;)...,pr(&quot;,abc\n&quot;)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">VTPrint</span>(<span class="number">1</span>,<span class="string">&quot;,&quot;</span>,<span class="number">1.2</span>,<span class="string">&quot;,abc\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++11中，标 准还引入了新操作符<code>sizeof...</code>其作用是计算参数包中的参数个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>...A&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(A...arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);<span class="comment">//非6参数偏特化版本都会默认assert(false)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特化6参数的版本，若匹配失败则执行Print(A...arg)后执行assert</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">int</span> a5, <span class="type">int</span> a6)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; a1 &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a2 &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a3 &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">         &lt;&lt; a4 &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a5 &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a6 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>...A&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Vaargs</span><span class="params">(A...args)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>...(A);<span class="comment">//计算变长包的长度</span></span><br><span class="line">    <span class="keyword">switch</span> (size) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">Print</span>(<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">Print</span>(<span class="number">99</span>, <span class="number">99</span>, args..., <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">Print</span>(<span class="number">99</span>, <span class="number">99</span>, args..., <span class="number">99</span>, <span class="number">99</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">Print</span>(args..., <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">Print</span>(<span class="number">99</span>, args..., <span class="number">99</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">Print</span>(<span class="number">99</span>, args...);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">Print</span>(args...);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">Print</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Vaargs</span>();<span class="comment">//99,99,99,99,99,99</span></span><br><span class="line">    <span class="built_in">Vaargs</span>(<span class="number">1</span>);<span class="comment">//99,99,1,99,99,99</span></span><br><span class="line">    <span class="built_in">Vaargs</span>(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//99,99,1,2,99,99</span></span><br><span class="line">    <span class="built_in">Vaargs</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">//1,2,3,99,99,99</span></span><br><span class="line">    <span class="built_in">Vaargs</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);<span class="comment">//99,1,2,3,4,99</span></span><br><span class="line">    <span class="built_in">Vaargs</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="comment">//99,1,2,3,4,5</span></span><br><span class="line">    <span class="built_in">Vaargs</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);<span class="comment">//1,2,3,4,5,6</span></span><br><span class="line">    <span class="built_in">Vaargs</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);<span class="comment">//0,0,0,0,0,0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面看不太懂了</p><p>参考：书籍《深入理解c++11》<br>           <a href="https://blog.csdn.net/code_peak/article/details/121053884">C语言变长参数函数原理_code_peak的博客-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无聊的大学生活</title>
      <link href="/2023/05/10/life%E6%97%A0%E8%81%8A%E7%9A%84%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
      <url>/2023/05/10/life%E6%97%A0%E8%81%8A%E7%9A%84%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<p>​一天又过去了，说不出的滋味，感觉我的大学生活就是三点一线，实验室 宿舍 食堂，确实你没看错，没有教室。我想呢，你要是个双非学生的话你应该都懂的。稍微吐槽一下，我们软件工程学费一万六千八，哈哈~~~。但是还好我每天去实验室，算是损失最小化了吧</p><p>​我在大一上学期，大概十月份的时候加入了网络安全实验室。当时一腔热血，可能只是被网络安全的表面现象蒙蔽了吧（一说网安给人一种很帅的感觉）。由于当时进来的较晚，实验室呢又分了好几个方向如：web pwn 逆向，当时的我想要学就学最叼的最帅的，在简单了解之后呢便选择了 pwn ，这个东西可让我吃了不少苦头。pwn呢是二进制安全，依稀记着当时寒假的时候每天从早上 9 点干到晚上12点，哈哈每天就在垃圾堆里刨食(某sdn)，学了很多。大概是学完栈攻击手法，堆 UAF 漏洞以及高版本堆工作原理（有些记不清了）的时候，采纳了学长的建议“去好好学习一下 C语言，你的C语言并不扎实”，这句话改变了我的学习轨迹，那段时间疫情封在家里面，学完C语言了，觉得这个东西可以呀，比pwn好学多了，教程一找一大片，当时可是高兴坏了，要不学习一下C++吧，反正也没什么事情干。于是呢，我就从一个pwn的爱好者变成了c++爱好者，便开始了我的c++旅程。当时C语言看了大厚书，c++看着王桂林老师的视频</p><p>由于马上要期末考试了，这两本书暂时先放下了。我本身对操作系统非常感兴趣，但是呢，学校老师教的实在过分无聊了，也是我太过自信了，以为看过点 csapp 学过点 系统编程，就可以轻松拿下。现实却是蛮打脸的，由于我常年旷课（欸~~今天又悲伤了）猛然间发现操作系统课要考的东西怎么如此（黑人问号）。没办法咯</p>]]></content>
      
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常量表达式</title>
      <link href="/2023/05/06/%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/05/06/%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h1><h2 id="运行时常量和编译期常量"><a href="#运行时常量和编译期常量" class="headerlink" title="运行时常量和编译期常量"></a>运行时常量和编译期常量</h2><p>常量表示该值不可修改，通常是通过const关键字来修饰的。const还可以修饰函数参数、函数返回值、函数本身、类等。在不同的使用条件下，const有不同的意义，不过大多数情况下，const描述的都是一些<strong>运行时常量性</strong>的概 念，即具有运行时数据的不可更改性。<strong>不过有的时候，我们需要的却是编译时期的常量性，这是const关键字无法保证的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">GetConst</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Constless</span><span class="params">(<span class="type">int</span> cond)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="built_in">GetConst</span>()] = &#123;<span class="number">0</span>&#125;;<span class="comment">//无法通过编译</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        e1 = <span class="built_in">GetConst</span>(), e2</span><br><span class="line">    &#125;;<span class="comment">//无法通过编译</span></span><br><span class="line">    <span class="keyword">switch</span> (cond) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">GetConst</span><span class="params">()</span>://无法通过编译</span></span><br><span class="line"><span class="function">            break;</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组大小，匿名枚举成员，case表达式中的值需要在编译时就确定下来，故需要的是编译器常量，而const修饰的函数返回值，只保证了在运行时期内其值是 不可以被更改的。这是两个完全不同的概念。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">BitSet</span>&#123;</span><br><span class="line">    V0=<span class="number">1</span>&lt;&lt;<span class="number">0</span>,</span><br><span class="line">    V1=<span class="number">1</span>&lt;&lt;<span class="number">1</span>,</span><br><span class="line">    V2=<span class="number">1</span>&lt;&lt;<span class="number">2</span>,</span><br><span class="line">    VMAX=<span class="number">1</span>&lt;&lt;<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//重定义操作符&quot;|&quot;,以保证返回的BitSet值不超过枚举的最大值</span></span><br><span class="line"><span class="type">const</span> BitSet <span class="keyword">operator</span>|(BitSet x,BitSet y)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;BitSet&gt;(((<span class="type">int</span>)x|y)&amp;(VMAX<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> i=V0|V1&gt;<span class="comment">//无法通过编译</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">LikeConst</span>()&#123;&#125;</span><br></pre></td></tr></table></figure><p>为了尽可能地保证或操作的有效性，我们重载了operator | ，该操作除了进行或运算外，还会 通过<code>＆(VMAX-1)</code>这样的操作保证该或操作的输出不会超过<code>VMAX</code>枚举值。而此时我们将<code>V0|V1</code>作为非类型模板函数的默认模板参数，则会导致编译错误。这同样是由需要的是编译时常量所导致的。</p><p>解决方法：</p><p>C++11中对编译时期常量的回答是<code>constexpr</code>，即常量表达式（constant expression）。比如我们要使得代码清单6-1中的GetConst函数成为一个 常量表达式，可以用下面的声明方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">GetConst</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure><p>即在函数表达式前加上<code>constexpr</code>关键字即可。有了常量表达式这样的声明，编译器就可以在编译时期对<code>GetConst</code>表达式进行值计算 （evaluation），从而将其视为一个编译时期的常量（虽然编译器不一 定这么做，但至少从语法效果上看是这样）</p><h2 id="常量表达式函数"><a href="#常量表达式函数" class="headerlink" title="常量表达式函数"></a>常量表达式函数</h2><p>通常我们可以在函数返回类型前加入关键字<code>constexpr</code>来使其成为常量 表达式函数。不过并非所有的函数都有资格成为常量表达式函数。事实上，常量表达式函数的要求非常严格，总结起来，大概有以下几点：</p><blockquote><ol><li>函数体只有单一的return返回语句。</li><li>函数必须返回值（不能是void函数）。</li><li>在使用前必须已有定义。</li><li>return返回语句表达式中不能使用非常量表达式的函数、全局数据， 且必须是一个常量表达式。</li></ol></blockquote><p>首先是常量表达式函数中最为明显的限制，就是要求函数体中只有一条语句，且该条语句必须是return语句。形如：<code>constexpr int data() &#123;const int i = 1; return i;&#125;;</code>将无法通过编译，但是一些不会产生实际代码的语句可以在常量表达式中使用，编译器是允许的如静态断言，与之类似的还有 using typedef指令也不会造成问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="number">0</span>==<span class="number">0</span>,<span class="string">&quot;assert fail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个约束条件是常量表达式必须有返回值如：<code>constexpr void f()</code>这样的不返回值的函数就不能是常量表达式</p><p>第三点约束是常量表达式函数在使用前必须被<strong>定义</strong>。对于普通函数而言，调用函数只需要有函数声明就够了，但常量表达式函数的使用则有所不同。这里要注意常量表达式“使用”和“调用”的区别，前者讲的是编译时的值计算，而后者讲的是运行时的函数调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>;   <span class="comment">//只声明不定义</span></span><br><span class="line"><span class="type">int</span> a=<span class="built_in">f</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b=<span class="built_in">f</span>();</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> c=<span class="built_in">f</span>();<span class="comment">//无法通过编译</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;  <span class="comment">//定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> d=<span class="built_in">f</span>(); <span class="comment">//可以通过编译</span></span><br></pre></td></tr></table></figure><p>在a和b的定义中，编译器会将 f() 转换为一个函数调用，而在c的定义中，由于其是一 个常量表达式值，因此会要求编译器进行编译时的值计算。这时候由于f常量表达式还没有定义，就会导致编译错误。而 d 的定义则没有问题，因为 f 的定义已经存在了。虽然 f 被定义为一个常量表达式，但是它是否在编译时进行值计算则不一定。在b和c的定义中，f 就是标准的函数调用，<code>constexpr</code>也不会使得函数被重写。即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这将无法通过编译</p><p>第四点非常重要，常量表达式中，也不能使用非常量表达式的函数。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">e</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">e</span>();&#125;</span><br><span class="line">或者：</span><br><span class="line"><span class="type">int</span> g=<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">h</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> g;&#125;</span><br></pre></td></tr></table></figure><p>这将无法通过编译，这样做的意义也比较明显，即 如果我们要使得g()是一个编译时的常量，那么其return表达式语句就 不能包含运行时才能确定返回值的函数。只有这样，编译器才能够在 编译时进行常量表达式函数的值计算。</p><p>当然，作为一个常量表达式函数，return的表达式需要是一个常量表达 式也是天经地义的事情。一些危险的操作，比如赋值的操作在常量表 达式中也是不允许的，形如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">k</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x=<span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure><p>的语句也是无法通过编译的</p><h2 id="常量表达式值"><a href="#常量表达式值" class="headerlink" title="常量表达式值"></a>常量表达式值</h2><p>形如：<code>constexpr int c</code>这样声明的变量就是所谓的常量表达式。通常情况下，常量表达式值必须被一个常量表达式赋值，而跟常量表达式函数一样，常量表达式值在使用前必须被初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//二者的区别：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">事实上，两者在大多数情况下是没有区别的。不过有一点是肯定的，</span></span><br><span class="line"><span class="comment">就是如果i在全局名字空间中，编译器一定会为i产生数据。而对于j，</span></span><br><span class="line"><span class="comment">如果不是有代码显式地使用了它的地址，编译器可以选择不为它生成</span></span><br><span class="line"><span class="comment">数据，而仅将其当做编译时期的值*/</span></span><br></pre></td></tr></table></figure><p>这里还要提一下浮点常量。C++11中，编译时的浮点数常量表达式值还是被允许的。标准要求编译时的浮点常量表达式值的精度要至少等于（或者高于）运行时的浮 点数常量的精度。</p><p>而对于自定义类型的数据，要使其成为常量表达式值的话，则不像内置类型这么简单。C++11标准中，constexpr 关键字是<strong>不能用于修饰自定义类型的定义</strong>的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">MyType</span>&#123;<span class="type">int</span> i;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> MyType mt=&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>这将无法通过编译，正确地做法是，定义自定义常量构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">MyType</span><span class="params">(<span class="type">int</span> x)</span>:i(x)&#123;</span>&#125;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> MyType mt=&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>常量表达式的构造函数也有使用上的约束，主要的有以下两点：</p><blockquote><p>函数体必须为空</p><p><strong>初始化列表只能由常量表达式来赋值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">MyType</span><span class="params">()</span>:i(f())&#123;</span>&#125;   <span class="comment">//初始化列表中使用了非常量表达式，无法通过编译</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>虽然我们声明的是常量表达式构造函 数，但是其编译时的“常量性”则体现在类型上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Date</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d)</span> :</span></span><br><span class="line"><span class="function">            year(y), month(m), day(d) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">GetYear</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> year; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">GetMonth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> month; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">GetDay</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> day; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> Date PRCfound&#123;<span class="number">1949</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> foundmonth = PRCfound.<span class="built_in">GetMonth</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; cout &lt;&lt; foundmonth &lt;&lt; endl; &#125;<span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>我们为Date类型声明了常量表达式构造函数，随后定义了constexpr的变量PRCfound。此外，还为Date定义常量表达式的 成员函数，可以看到，可以从PRCfound中拿出成员month，赋给一个 常量表达式值foundmonth。如果PRCfound的成员变量在这里不具有编 译时的常量性，显然是不可能做到的。</p><p>参考：书籍《深入理解c++11》</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针(c++11)</title>
      <link href="/2023/05/05/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2023/05/05/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="引入："><a href="#引入：" class="headerlink" title="引入："></a>引入：</h2><p>有时我们的程序会突然退出，或内存占用越来越多，最后不得不定期重启，这些问题的源头可以追溯到C&#x2F;C++中的显式堆内存管理上。通常情况下，这些症状都是由于程序没有正确处理堆内存的分配与释放造成的，从语言层面来讲，我们可以将其归纳为以下一些问题。</p><ol><li>野指针：：一些内存单元已被释放，之前指向它的指针却还在被使用。这些内存有可能被运行时系统重新分配给程序使用，从而导致了无法预测的错误。</li><li>重复释放：程序试图去释放已经被释放过的内存单元，或者释放已经被重新分配过的内存单元，就会导致重复释放错误。通常重复释放内存会导致C&#x2F;C++运行时系统打印出大量错误及诊断信息。</li><li>内存泄漏：不再需要使用的内存单元如果没有被释放就会导致内存泄漏。如果程序不断地重复进行这类操作，将会导致内存占用剧增。</li></ol><p>在C++11新标准中，智能指针被进行 了改进，以更加适应实际的应用需求。而进一步地，标准库还提供了 所谓“最小垃圾回收”的支持。</p><h2 id="c-11中的智能指针"><a href="#c-11中的智能指针" class="headerlink" title="c++11中的智能指针"></a>c++11中的智能指针</h2><figure class="highlight plaintext"><figcaption><span>shared_ptr  weak_ptr```等智能指针来自动回收堆分配的对象。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">简单使用示例：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    unique_ptr&lt;int&gt; up1(new int(11));//无法复制的unique_ptr</span><br><span class="line">    unique_ptr&lt;int&gt; up2 = up1;//不能通过编译</span><br><span class="line">    cout &lt;&lt; *up1 &lt;&lt; endl;//11</span><br><span class="line">    unique_ptr&lt;int&gt; up3 = move(up1);//现在p3是数据唯一的unique_ptr智能指针</span><br><span class="line">    cout &lt;&lt; *up3 &lt;&lt; endl;//11</span><br><span class="line">    cout &lt;&lt; *up1 &lt;&lt; endl;//运行时错误</span><br><span class="line">    up3.reset();//显式释放内存</span><br><span class="line">    up1.reset();//不会导致运行时错误</span><br><span class="line">    cout &lt;&lt; *up3 &lt;&lt; endl;//运行时错误</span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;int&gt; sp1(new int(22));</span><br><span class="line">    shared_ptr&lt;int&gt; sp2 = sp1;</span><br><span class="line">    cout &lt;&lt; *sp1 &lt;&lt; endl;//22</span><br><span class="line">    cout &lt;&lt; *sp2 &lt;&lt; endl;//22</span><br><span class="line">    sp1.reset();</span><br><span class="line">    cout &lt;&lt; *sp2 &lt;&lt; endl;//22</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于每个智能指针都重载了*运算符，用户可以使用 up1这样的方式来访问所分配的堆内存。而在该指针析构或者调用reset成员的时候，智能指针都可能释放其拥有的堆内存。</p><figure class="highlight plaintext"><figcaption><span>而且一旦构造成功，右值对象中的指针即被“窃取”，因此该右值对象 即刻失去了对指针的“所有权”。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```shared_ptr```同样形如其名，允许多个该智能指针共享地“拥有”同一堆 分配对象的内存。与```unique_ptr```不同的是，由于在实现上采用了引用计数，所以一旦一个```shared_ptr```指针放弃了“所有权”（失效），其他的```shared_ptr```对对象内存的引用并不会受到影响。只有在引用计数归零的时候，```share_ptr```才会真正释放所占有的堆内存的空间。</span><br><span class="line"></span><br><span class="line">在C++11标准中，除了```unique_ptr```和```shared_ptr```，智能指针还包括了```weak_ptr```这个类模板。```weak_ptr```的使用更为复杂一点，它可以指向 ```shared_ptr``` 指针指向的对象内存，却并不拥有该内存。而使用```weak_ptr``` 成员```lock()```，则可返回其指向内存的一个```shared_ptr```对象，且在所指对象内存已经无效时，返回指针空值</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">void Check(weak_ptr&lt;int&gt; &amp;wp) &#123;</span><br><span class="line">    shared_ptr&lt;int&gt; sp = wp.lock();</span><br><span class="line">    //转换为shared_ptr&lt;int&gt;，当wp失效时返回nullptr，</span><br><span class="line">    //wp有效时返回指向shared_ptr指针指向的对象内存，却并不拥有该内存，即不改变引用计数</span><br><span class="line">    if (sp != nullptr)</span><br><span class="line">        cout &lt;&lt; &quot;still&quot; &lt;&lt; *sp &lt;&lt; endl;</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; &quot;pointer is invalid.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    shared_ptr&lt;int&gt; sp1(new int(22));</span><br><span class="line">    shared_ptr&lt;int&gt; sp2 = sp1;</span><br><span class="line">    weak_ptr&lt;int&gt; wp = sp1;      //指向shared_ptr&lt;int&gt;所指对象</span><br><span class="line">    cout &lt;&lt; *sp1 &lt;&lt; endl;//22</span><br><span class="line">    cout &lt;&lt; *sp2 &lt;&lt; endl;//22</span><br><span class="line">    Check(wp);//still 22   此时sp1 sp2均有效</span><br><span class="line"></span><br><span class="line">    sp1.reset();          //sp1失效</span><br><span class="line">    cout &lt;&lt; *sp2 &lt;&lt; endl;//22</span><br><span class="line">    Check(wp);//still 22</span><br><span class="line"></span><br><span class="line">    sp2.reset();         //sp1 sp2 全部失效</span><br><span class="line">    Check(wp);//pointer is invalid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：书籍《深入理解c++11》</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>追踪返回类型</title>
      <link href="/2023/04/29/%E8%BF%BD%E8%B8%AA%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/04/29/%E8%BF%BD%E8%B8%AA%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="追踪返回类型"><a href="#追踪返回类型" class="headerlink" title="追踪返回类型"></a>追踪返回类型</h1><h2 id="引入："><a href="#引入：" class="headerlink" title="引入："></a>引入：</h2><p>追踪返回类型配合<code>auto</code>与 <code>decltype</code>会真正释放C++11中泛型编程的能力</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1 , <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(ti + t2)</span> <span class="title">sum</span><span class="params">(T1&amp; t1 , T2&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的写法虽然看似不错，不过对编译器来说有些小问题。编译器在 推导<code>decltype(t1+t2)</code>时，表达式中的t1和t2都未声明（虽然它们近在 咫尺，编译器却只会从左往右地读入符号）。</p><p>c++11引入了新语法：跟踪返回类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(T1 &amp;t1, T2 &amp;t2)</span> -&gt; <span class="title">decltype</span><span class="params">(t1 + t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将函数的返回值移至参数声明之后，复合符号 <code>-＞decltype(t1+t2)</code>被称为追踪返回类型，原本的返回值的位置由<code>auto</code>占据。</p><h2 id="使用追踪返回类型的函数："><a href="#使用追踪返回类型的函数：" class="headerlink" title="使用追踪返回类型的函数："></a>使用追踪返回类型的函数：</h2><p>追踪返回类型的函数和普通函数的声明最大的区别在于返回类型的后置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span></span>;   <span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">char</span> *a , <span class="type">char</span> *b)</span> -&gt; <span class="type">int</span></span>;  <span class="comment">//返回类型后置，作用好像不大 😂🤣</span></span><br></pre></td></tr></table></figure><p>对于普通类型可能没有什么作用，但是对于类型可以少写类型的作用域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterType</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">InnerType</span>&#123;<span class="type">int</span> i;&#125;;</span><br><span class="line">    <span class="function">InnerType <span class="title">GetInner</span><span class="params">()</span></span>;</span><br><span class="line">    InnerType it;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//可以不写OuterType::InnerType</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">OuterType::GetInner</span><span class="params">()</span>-&gt;InnerType</span>&#123;    <span class="comment">//们使用最终返回类型的时候，InnerType不必写明其作用域</span></span><br><span class="line"><span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*OuterType::InnerType OuterType::GetInner() &#123;</span></span><br><span class="line"><span class="comment">    return it;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><p>返回类型后置，使模板中的一些类型推导就成为了可能，如下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(<span class="type">const</span> T1&amp;t1,<span class="type">const</span> T2&amp;t2)</span>-&gt;<span class="title">decltype</span><span class="params">(t1+t2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t1+t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Mul</span><span class="params">(<span class="type">const</span> T1&amp;t1,<span class="type">const</span> T2&amp;t2)</span>-&gt;<span class="title">decltype</span><span class="params">(t1*t2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t1*t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a=<span class="number">3</span>;               <span class="comment">//a:int</span></span><br><span class="line">    <span class="keyword">auto</span> b=<span class="number">4L</span>;              <span class="comment">//b:long</span></span><br><span class="line">    <span class="keyword">auto</span> pi=<span class="number">3.14</span>;           <span class="comment">//c:double</span></span><br><span class="line">    <span class="keyword">auto</span> c=<span class="built_in">Mul</span>(<span class="built_in">Sum</span>(a,b),pi);</span><br><span class="line">    cout&lt;&lt;c&lt;&lt;endl;<span class="comment">//21.98</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟踪返回类型的另一个优势是简化函数的定义，提高可读性，常见于返回类型为函数指针的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>(* (*<span class="built_in">pf</span>() )() ) ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//auto(*)()-&gt;int(*)()一个返回函数指针的函数(假设为a函数)</span></span><br><span class="line"><span class="comment">//auto pf1()-&gt;auto(*)()-&gt;int(*)()一个返回a函数的指针的函数</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">pf1</span><span class="params">()</span> -&gt; <span class="title">auto</span> <span class="params">(*)</span><span class="params">()</span>-&gt;<span class="title">int</span> <span class="params">(*)</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; is_same&lt;<span class="keyword">decltype</span>(pf), <span class="keyword">decltype</span>(pf1)&gt;::value &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了两个类型完全一样的函数pf和pf1。其返回的都是一个函数指针。而该函数指针又指向一个返回函数指针的函数。可以发现老式的声明法可读性非常差。 而追踪返回类型只需要依照从右向左的方式，就可以将嵌套的声明解析出来。这大大提高了嵌套函数这类代码的可读性。</p><p>跟踪返回类型也常用于转发函数上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>) a + <span class="number">0.1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Forward</span><span class="params">(T t)</span> -&gt; <span class="title">decltype</span><span class="params">(foo(t))</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">foo</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Forward</span>(<span class="number">2</span>) &lt;&lt; endl;<span class="comment">//2.1   //推导为double</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Forward</span>(<span class="number">0.5</span>) &lt;&lt; endl;<span class="comment">//0   //推导为int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现了根据参数类型确定返回类型，通过decltype</span></span><br></pre></td></tr></table></figure><p>返回类型后置还可以用于声明函数指针中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto</span> (*pf)() -&gt; <span class="type">int</span> ;  <span class="comment">//等价于：int(*pf)()</span></span><br><span class="line"><span class="built_in">auto</span> (&amp;fr)() -&gt; <span class="type">int</span> = *pf;   <span class="comment">//等价于：int(&amp;fr)()</span></span><br></pre></td></tr></table></figure><p>追踪返回类型还可以用在结构或类的成员函数、类模板的成员函数 里，其方法大同小异。另外，没有返回值的函数也可以被声明为追踪返回类型，程序员只需要将返回类型声明为void 即可</p><p>参考：书籍《深入理解c++11》</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>decltype类型推导</title>
      <link href="/2023/04/27/decltype/"/>
      <url>/2023/04/27/decltype/</url>
      
        <content type="html"><![CDATA[<h1 id="decltype类型推导"><a href="#decltype类型推导" class="headerlink" title="decltype类型推导"></a>decltype类型推导</h1><h2 id="typeid-和-decltype"><a href="#typeid-和-decltype" class="headerlink" title="typeid 和 decltype"></a>typeid 和 decltype</h2><p>c++在c++98中就已经部分支持了动态类型，c++98中对动态类型的支持就是c++中运行时类型识别(RTTI)</p><p>RTTI机制为每个类型产出一个<code>type_info</code>类型的数据，可以使用<code>typeid</code>随时查询一个变量的类型，<code>typeid</code>就会返回变量相应的<code>type_info</code>数据,<code>typeinfo</code>的<code>name</code>成员可以返回类型名称(标准没有具体规定名称，由编译器自行确定)，在C++11中，又增加了<code>hash_code</code>这个成员函数，返回该类型唯 一的哈希值，以供程序员对变量的类型随时进行比较</p><p>演示代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">White</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Black</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    White a;</span><br><span class="line">    Black b;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">//5White</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(b).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">//5Black</span></span><br><span class="line">    White c;</span><br><span class="line">    <span class="type">bool</span> a_b_sametype =</span><br><span class="line">            (<span class="built_in">typeid</span>(a).<span class="built_in">hash_code</span>() == <span class="built_in">typeid</span>(b).<span class="built_in">hash_code</span>());</span><br><span class="line">    <span class="type">bool</span> a_c_sametype =</span><br><span class="line">            (<span class="built_in">typeid</span>(a).<span class="built_in">hash_code</span>() == <span class="built_in">typeid</span>(c).<span class="built_in">hash_code</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Same type?&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A and B?&quot;</span> &lt;&lt; (<span class="type">int</span>) a_b_sametype &lt;&lt; endl;<span class="comment">//0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A and C?&quot;</span> &lt;&lt; (<span class="type">int</span>) a_c_sametype &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="number">5</span>White</span><br><span class="line"><span class="number">5B</span>lack</span><br><span class="line">Same type?</span><br><span class="line">A <span class="keyword">and</span> B?<span class="number">0</span></span><br><span class="line">A <span class="keyword">and</span> C?<span class="number">1</span></span><br></pre></td></tr></table></figure><p>值得注意的是：<a href="https://zh.cppreference.com/w/cpp/types/is_same">is_same</a>模板类的成员类型value在编译时得到信息，hash_code是运行时得到的信息</p><p>而且很多时候，运行时才确定出类型对于程序员来说为时过晚，程序员更多需要的是在编译时期确定出类型。而通常程序员是要使用这样的类型而不是识别该类型，因此RTTI无法满足需求。</p><p>c++11引入了auto 和 decltype，与auto类似decltypd也可以用于类型推导</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">decltype</span>(i) j = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(j).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">//打印出&quot;i&quot;,g++表示int</span></span><br><span class="line">    <span class="type">float</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="keyword">decltype</span>(a + b) c;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">//打印出&quot;d&quot;,g++表示double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，decltype总是以一个普通的表达式作为参数，返回该表达式的类型。而与auto不同的是，作为一个类型指示符，decltype可以将获得的类型来定义另外一个变量。与auto相同的是，<strong>decltype类型推导也是在编译时进行的</strong>。</p><h2 id="decltype的应用"><a href="#decltype的应用" class="headerlink" title="decltype的应用"></a>decltype的应用</h2><p>在c++11中decltype推导类型是常见的，典型的有 decltype 与 typedef 和 using 的联合使用，我们常能见到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">size_t</span>=<span class="keyword">decltype</span>(<span class="built_in">sizeof</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">using</span> <span class="type">ptrdiff_t</span>=<span class="keyword">decltype</span>((<span class="type">int</span>*)<span class="number">0</span>-(<span class="type">int</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="keyword">using</span> <span class="type">nullptr_t</span>=<span class="keyword">decltype</span>(<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>在C++中，我们有时会遇到匿名的类型，而拥有了decltype这个利器之后，<strong>重用匿名类型</strong>也并非难事。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;K1, K2, K3&#125; anon_e;<span class="comment">//匿名的强类型枚举</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">decltype</span>(anon_e) key;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125; anon_u;<span class="comment">//匿名的union联合体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="keyword">decltype</span>(anon_u) id;</span><br><span class="line">&#125; anon_s[<span class="number">100</span>];<span class="comment">//匿名的struct数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">decltype</span>(anon_s) as;</span><br><span class="line">    as[<span class="number">0</span>].id.key = <span class="keyword">decltype</span>(anon_e)::K1;<span class="comment">//引用匿名枚举中的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了decltype，我们可以适当扩大模板泛型的能力:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sum</span><span class="params">(T1&amp; t1,T2&amp; t2,<span class="keyword">decltype</span>(t1+t2) &amp;s)</span></span>&#123;</span><br><span class="line">s=t1+t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">3</span>;</span><br><span class="line">    <span class="type">long</span> b=<span class="number">5</span>;</span><br><span class="line">    <span class="type">float</span> c=<span class="number">1.0f</span>,d=<span class="number">2.3f</span>;</span><br><span class="line">    <span class="type">long</span> e;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="built_in">Sum</span>(a,b,e);<span class="comment">//s的类型被推导为long</span></span><br><span class="line">    <span class="built_in">Sum</span>(c,d,f);<span class="comment">//s的类型被推导为float</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>decltype再模板实例化的作用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(::<span class="built_in">hash</span>(<span class="literal">nullptr</span>)) a;             <span class="comment">//a: int</span></span><br><span class="line">std::map&lt;<span class="type">char</span>*,<span class="keyword">decltype</span>(::hash)&gt;dict_key;<span class="comment">//无法通过编译,无法使用函数类型作容器参数</span></span><br><span class="line">std::map&lt;<span class="type">char</span>*,<span class="keyword">decltype</span>(::hash(<span class="literal">nullptr</span>))&gt;dict_key1;</span><br></pre></td></tr></table></figure><h2 id="decltype的四大推导规则"><a href="#decltype的四大推导规则" class="headerlink" title="decltype的四大推导规则"></a>decltype的四大推导规则</h2><blockquote><p>  标记符表达式：所有除去关键字、字面量等编译器需要使用的标记之外的程序员自定义的标 记（token）都可以是标记符（identifier）。而单个标记符对应的表达式就是标记符表达式</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>  那么arr是一个标记符表达式，而arr[3]+0,arr[3]等，则都不是标记符表达式。</p></blockquote><ol><li>如果e是一个没有带括号的<strong>标记符表达式（id-expression）</strong>或者<strong>类成员访问表达式</strong>，那么<code>decltype(e)</code>就是e所命名的实体的类型。此外，如 果e是一个被重载的函数，则会导致编译时错误。</li><li>否则，假设e的类型是T，如果e是一个将亡值(xvalue)，那么 decltype(e)为T&amp;&amp;。 </li><li>否则，假设e的类型是T，如果e是一个左值，则decltype(e)为T&amp;。</li><li>否则，假设e的类型是T，则decltype(e)为T。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span>*ptr=arr;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>&#123;<span class="type">double</span> d;&#125;s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Overloaded</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Overloaded</span><span class="params">(<span class="type">char</span>)</span></span>;<span class="comment">//重载的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">RvalRef</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">bool</span> <span class="title">Func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//规则1:单个标记符表达式以及访问类成员，推导为本类型</span></span><br><span class="line"><span class="keyword">decltype</span>(arr)var1;<span class="comment">//int[5],标记符表达式</span></span><br><span class="line"><span class="keyword">decltype</span>(ptr)var2;<span class="comment">//int*,标记符表达式</span></span><br><span class="line"><span class="keyword">decltype</span>(s.d)var4;<span class="comment">//double,成员访问表达式</span></span><br><span class="line"><span class="keyword">decltype</span>(Overloaded)var5;<span class="comment">//无法通过编译，是个重载的函数</span></span><br><span class="line"><span class="comment">//规则2:将亡值，推导为类型的右值引用</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">RvalRef</span>())var6=<span class="number">1</span>;<span class="comment">//int＆＆</span></span><br><span class="line"><span class="comment">//规则3:左值，推导为类型的引用</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="literal">true</span>?i:i)var7=i;<span class="comment">//int＆,三元运算符，这里返回一个i的左值</span></span><br><span class="line"><span class="keyword">decltype</span>((i))var8=i;<span class="comment">//int＆,带圆括号的左值</span></span><br><span class="line"><span class="keyword">decltype</span>(++i)var9=i;<span class="comment">//int＆,++i返回i的左值</span></span><br><span class="line"><span class="keyword">decltype</span>(arr[<span class="number">3</span>])var10=i;<span class="comment">//int＆[]操作返回左值</span></span><br><span class="line"><span class="keyword">decltype</span>(*ptr)var11=i;<span class="comment">//int＆*操作返回左值</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="string">&quot;lval&quot;</span>)var12=<span class="string">&quot;lval&quot;</span>;<span class="comment">//const char(&amp;)[9],字符串字面常量为左值</span></span><br><span class="line"><span class="comment">//规则4：以上都不是，推导为本类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">1</span>)var13;<span class="comment">//int,除字符串外字面常量为右值</span></span><br><span class="line"><span class="keyword">decltype</span>(i++)var14;<span class="comment">//int,i++返回右值</span></span><br><span class="line"><span class="keyword">decltype</span>((<span class="built_in">Func</span>(<span class="number">1</span>)))var15;<span class="comment">//const bool,圆括号可以忽略</span></span><br></pre></td></tr></table></figure><h2 id="cv限定的继承与冗余的符号"><a href="#cv限定的继承与冗余的符号" class="headerlink" title="cv限定的继承与冗余的符号"></a>cv限定的继承与冗余的符号</h2><p>与auto类型推导时不能带走 cv 限制符不同，decltype是能够带走表达式的 cv 限制符的。不过，如果对象的定义中有const或volatile限制符，使用decltype进行推导时，其成员不会继承const或volatile限制符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ic = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> iv;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> S a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">volatile</span> S b;</span><br><span class="line"><span class="keyword">volatile</span> S *p = &amp;b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; is_const&lt;<span class="keyword">decltype</span>(ic)&gt;::value &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line">    cout &lt;&lt; is_volatile&lt;<span class="keyword">decltype</span>(iv)&gt;::value &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line">    cout &lt;&lt; is_const&lt;<span class="keyword">decltype</span>(a)&gt;::value &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line">    cout &lt;&lt; is_volatile&lt;<span class="keyword">decltype</span>(b)&gt;::value &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line">    cout &lt;&lt; is_const&lt;<span class="keyword">decltype</span>(a.i)&gt;::value &lt;&lt; endl;<span class="comment">//0,成员不是const</span></span><br><span class="line">    cout &lt;&lt; is_volatile&lt;<span class="keyword">decltype</span>(p-&gt;i)&gt;::value &lt;&lt; endl;<span class="comment">//0,成员不是volatile</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而与auto相同的，decltype从表达式推导出类型后，进行类型定义时，也会允许一些冗余的符号。比如cv限制符以及引用符号&amp;，通常情况 下，如果推导出的类型已经有了这些属性，冗余的符号则会被忽略</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">decltype</span>(i) &amp;var1 = i;</span><br><span class="line">    <span class="keyword">decltype</span>(j) &amp;var2 = i;<span class="comment">//冗余的&amp;,被忽略</span></span><br><span class="line">    cout &lt;&lt; is_lvalue_reference&lt;<span class="keyword">decltype</span>(var1)&gt;::value &lt;&lt; endl;<span class="comment">//1,是左值引用</span></span><br><span class="line">    cout &lt;&lt; is_rvalue_reference&lt;<span class="keyword">decltype</span>(var2)&gt;::value &lt;&lt; endl;<span class="comment">//0,不是右值引用</span></span><br><span class="line">    cout &lt;&lt; is_lvalue_reference&lt;<span class="keyword">decltype</span>(var2)&gt;::value &lt;&lt; endl;<span class="comment">//1,是左值引用</span></span><br><span class="line">    <span class="comment">//decltype(p) *var3 = &amp;i;//无法通过编译</span></span><br><span class="line">    <span class="keyword">decltype</span>(p) *var3 = &amp;p;<span class="comment">//var3的类型是int**</span></span><br><span class="line">    <span class="keyword">auto</span> *v3 = p;<span class="comment">//v3的类型是int*</span></span><br><span class="line">    v3 = &amp;i;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">decltype</span><span class="params">(k)</span> var4 </span>= <span class="number">1</span>;<span class="comment">//冗余的const，被忽略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里特别要注意的是<code>decltype(p) * </code>的情况。可以看到，在定义<code>var3</code>变量 的时候，由于p的类型是<code>int *</code>，因此var3被定义为了<code>int**</code>类型。这跟 auto声明中，* 也可以是冗余的不同。在decltype后的 * 号，<strong>并不会被编译器忽略。</strong> </p><p>const也会造成冗余声明，会被编译器忽略，同样的情况也会发生在volatile限制符上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>auto类型推导</title>
      <link href="/2023/04/26/auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
      <url>/2023/04/26/auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="auto类型推导"><a href="#auto类型推导" class="headerlink" title="auto类型推导"></a>auto类型推导</h1><blockquote><p>  clion中打开内嵌提示：</p><p>  settion -&gt; Inlay hints -&gt; 勾选Types 和 Parameter names</p><p>  即可打开内嵌代码提示，可以看到类型信息和参数信息</p></blockquote><h2 id="静态类型、动态类型与类型推导"><a href="#静态类型、动态类型与类型推导" class="headerlink" title="静态类型、动态类型与类型推导"></a>静态类型、动态类型与类型推导</h2><p>静态类型和动态类型的主要区别在于对变量进行类型检查的时间点。对于所谓的静态类型，类型检查主要发生在编译阶段；而对于动态类型，类型检查主要发生在运行阶段。形如Python等语言中变量“拿来就用”的特性，则需要归功于一个技术，即类型推导。</p><p>在C++11中，这个想法得到了实现。C++11中类型推导的实现的方式之一就是重定义了auto 关键字。另外一个现实是decltype(下一篇博客)</p><p>C++11中，auto拥有了全新的含义，即auto不再是一个存储类型指示符（storage-class-specifier，如static、extern、thread_local等 都是存储类型指示符），而是作为一个新的类型指示符（type_specifier，如int、float等都是类型指示符）来指示编译器，<strong>auto声明变量的类型必须由编译器在编译时期推导而得</strong>。</p><p>auto的基本使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> x=<span class="number">1</span>;<span class="comment">//x的类型为int,1的类型为const int 类型，推导忽略了const，后面回解释原因</span></span><br><span class="line">    <span class="keyword">auto</span> y=<span class="built_in">foo</span>();<span class="comment">//y的类型为double</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">m</span>&#123;<span class="type">int</span> i;&#125;str;</span><br><span class="line">    <span class="keyword">auto</span> str1=str;<span class="comment">//str1的类型是struct m</span></span><br><span class="line">    <span class="keyword">auto</span> z;<span class="comment">//无法推导，无法通过编译</span></span><br><span class="line">    z=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：<strong>auto声明的变量必须被初始化，以使编译器能够从其初始化表达式中推导出其类型</strong>。从这个意义上来讲，auto并非一种“类型”声明，而是一个类型声明时的“占位符”，编译器在编译时期会将auto替代为变量实际的类型</p><h2 id="auto使用细则"><a href="#auto使用细则" class="headerlink" title="auto使用细则"></a>auto使用细则</h2><blockquote><p>   auto关键字与指针引用结合的类型推导：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> *y = &amp;x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> *a = &amp;x;<span class="comment">//int*</span></span><br><span class="line"><span class="keyword">auto</span> &amp;b = x;<span class="comment">//int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> c = y;<span class="comment">//int*</span></span><br><span class="line"><span class="keyword">auto</span> *d = y;<span class="comment">//int*</span></span><br><span class="line"><span class="keyword">auto</span> *e = &amp;<span class="built_in">foo</span>();<span class="comment">//编译失败,指针不能指向一个临时变量,右值不可以取地址</span></span><br><span class="line"><span class="keyword">auto</span> &amp;f = <span class="built_in">foo</span>();<span class="comment">//编译失败,nonconst的左值引用不能和一个临时变量绑定，左值引用不可以绑定右值</span></span><br><span class="line"><span class="keyword">auto</span> g = <span class="built_in">bar</span>();<span class="comment">//int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="built_in">bar</span>();<span class="comment">//int&amp;</span></span><br></pre></td></tr></table></figure><p>变量a、c、d的类型都是指针类型，且都指向变量x。实际上 对于a、c、d三个变量而言，声明其为auto*或auto并没有区别。而如果 要使得auto声明的变量是另一个变量的引用，则必须使用auto＆，如同 本例中的变量b和h一样。</p><p>其次，auto与volatile和const之间也存在着一些相互的联系。volatile和 const代表了变量的两种不同的属性：易失的和常量的。在C++标准 中，它们常常被一起叫作cv限制符（cv-qualifier）。鉴于cv限制符的 特殊性，C++11标准规定auto可以与cv限制符一起使用，<strong>不过声明为 auto的变量并不能从其初始化表达式中“带走”cv限制符。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> a = <span class="built_in">foo</span>();<span class="comment">//a:const double</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;b = <span class="built_in">foo</span>();<span class="comment">//b:const double&amp;</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">auto</span> *c = <span class="built_in">bar</span>();<span class="comment">//c:volatile float*</span></span><br><span class="line"><span class="keyword">auto</span> d = a;<span class="comment">//d:double</span></span><br><span class="line"><span class="keyword">auto</span> &amp;e = a;<span class="comment">//e:const double&amp;</span></span><br><span class="line"><span class="keyword">auto</span> f = c;<span class="comment">//f:float*</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">auto</span> &amp;g = c;<span class="comment">//g:volatile float*&amp;</span></span><br></pre></td></tr></table></figure><p>我们可以通过非cv限制的类型初始化一个cv限制的类型，如变量a、b、c所示。<strong>不过通过auto声明的变量d、f却无法带 走a和f的常量性或者易失性</strong>。这里的例外还是引用，可以看出，<strong>声明为引用的变量e、g都保持了其引用的对象相同的属性（事实上，指针 也是一样的）。</strong></p><p>此外，跟其他的变量指示符一样，同一个赋值语句中，auto可以用来声明多个变量的类型，<strong>不过这些变量的类型必须相同</strong>。如果这些变量的类型不相同，编译器则会报错。事实上，<strong>用auto来声明多个变量类型时，只有第一个变量用于auto的类型推导，然后推导出来的数据类型被作用于其他的变量</strong>。所以不允许这些变量的类型不相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>, y = <span class="number">2</span>;<span class="comment">//x和y的类型均为int</span></span><br><span class="line"><span class="comment">//m是一个指向const int类型变量的指针,n是一个const int类型的变量</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> *m = &amp;x, n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">1</span>, j = <span class="number">3.14f</span>;<span class="comment">//编译失败,类型不同，无法推导</span></span><br><span class="line"><span class="keyword">auto</span> o = <span class="number">1</span>,&amp;p = o, *q =&amp;p;<span class="comment">//从左向右推导,o:intp:int&amp;q:int*</span></span><br></pre></td></tr></table></figure><p>auto还可以用于初始化列表，new中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="keyword">auto</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> y&#123;<span class="number">1</span>&#125;;<span class="comment">//使用初始化列表的auto</span></span><br><span class="line"><span class="keyword">auto</span> z=<span class="keyword">new</span> <span class="built_in">auto</span>(<span class="number">1</span>);<span class="comment">//可以用于new</span></span><br><span class="line"><span class="comment">//而z指针所指向的堆变量在分配时依然选择让编译器对类型进行推导，</span></span><br><span class="line"><span class="comment">//同样的，编译器也能够保证这种方式下类型推导的正确性。</span></span><br></pre></td></tr></table></figure><p>auto也不是万能的，常受限于语义的二义性，或是实现的困难性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">auto</span> x = <span class="number">1</span>)</span> </span>&#123;&#125;<span class="comment">//1:auto函数参数，无法通过编译</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> var = <span class="number">10</span>;<span class="comment">//2:auto非静态成员变量，无法通过编译</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> x[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">auto</span> y = x;    <span class="comment">//y : char*</span></span><br><span class="line">    <span class="keyword">auto</span> z[<span class="number">3</span>] = x;<span class="comment">//3:auto数组，无法通过编译</span></span><br><span class="line">    vector&lt;<span class="keyword">auto</span>&gt; v = &#123;<span class="number">1</span>&#125;; <span class="comment">//4:auto模板参数（实例化时），无法通过编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>auto不能做形参类型</li><li>编译器阻止auto对结构体中的非静态成员进行推导，即使成员拥有初始化</li><li>声明 auto数组 如： auto z[3]这样的数组是被编译器禁止的，但可以推导 auto y &#x3D; x</li><li>编译器阻止在实例化模板时auto作为模板参数如：vector&lt; auto&gt; v</li></ol><p>这篇博客中存在好多复制内容，是我的偷懒，也是我无法对他进行良好的概述，如有需要请参考原书第4章第一节，若我的行为让您感到厌倦，我深感抱歉</p><p>参考：书籍《深入理解c++11》</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POD类型</title>
      <link href="/2023/04/21/POD%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/04/21/POD%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="POD类型"><a href="#POD类型" class="headerlink" title="POD类型"></a>POD类型</h1><p>POD(Plain Old Data)，通常用于说明一个类型的属性，尤其是用户自定义类型的属性。Plain，表示了POD是个普通的类型，在C++中常见的类型都有这样的属性，而不像一些存在着虚函数虚继承的类型那么特别。而Old则体现了其与C的兼容性，比如可以用最老的memcpy()函数 进行复制，使用memset()进行初始化等。当然，这样的描述都太过于笼统，具体地，C++11将POD划分为两个基本概念的合集，即：平凡的（trivial）和标准布局的（standard layout）。</p><h2 id="平凡"><a href="#平凡" class="headerlink" title="平凡"></a>平凡</h2><p>平凡的定义：</p><blockquote><ol><li><p>拥有平凡的<strong>默认</strong>构造函数和析构函数</p><p>平凡的默认构造指的是构造函数什么也不做，由编译器默认生成，当一旦自定义了构造函数，即使构造函数中无参数也无函数体，那么构造函数也不再是平凡的，对于析构函数来说也是类似的，一旦实现析构函数将不再是平凡的，可以使用 &#x3D;default 关键字来显示的声明缺省版本的构造函数，从而使类型恢复平凡</p></li><li><p>拥有平凡的拷贝构造和移动构造函数</p></li><li><p>拥有平凡的拷贝赋值运算符和移动赋值运算符</p></li><li><p>不能包含虚函数以及虚基类</p></li></ol></blockquote><p>在c++11中提供了辅助类模板来判断一个类型是否平凡</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tempalte &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">std</span>::is_trival;</span><br><span class="line"><span class="comment">//类成员中的value变量中记录了该类型是否为平凡类型 当value为1时为平凡类型，value为0时为非平凡类型</span></span><br></pre></td></tr></table></figure><h2 id="标准布局"><a href="#标准布局" class="headerlink" title="标准布局"></a>标准布局</h2><p>POD包含的另一个概念是<strong>标准布局</strong>，标准布局的类或结构体的定义：</p><blockquote><ol><li><p><strong>所以非静态成员</strong>有相同的访问权限</p></li><li><p>在类或者结构体继承时，满足以下情况之一：</p><ul><li>派生类中有非静态成员，且只有一个包含静态成员的基类</li><li>基类中有非静态成员，而派生类中没有非静态成员</li></ul><p>这样的类或结构体也是标准布局的<br><strong>实际上使得非静态成员只要同时出现在基类和派生类之间，其就不属于标准布局，而对于多重继承，一旦非静态成员出现在多个基类中，派生类也不属于标准布局</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B1</span>&#123;<span class="type">static</span> <span class="type">int</span> a;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span>:B1&#123;<span class="type">int</span> d;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B2</span>&#123;<span class="type">int</span> a;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span>:B2&#123;<span class="type">static</span> <span class="type">int</span> d;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D3</span>:B2,B1&#123;<span class="type">static</span> <span class="type">int</span> d;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D4</span>:B2&#123;<span class="type">int</span> d;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D5</span>:B2,D1&#123;&#125;;</span><br><span class="line"><span class="comment">//D1、D2和D3都是标准布局的，而D4和D5则不属于标准布局的</span></span><br></pre></td></tr></table></figure></li><li><p>类中的第一个非静态成员的类型与其基类不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> : B</span><br><span class="line">&#123;</span><br><span class="line">B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A不是一个标准布局类型，第一个非静态成员的类型为 B 与基类类型相同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> : B</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C是一个标准布局类型</span></span><br></pre></td></tr></table></figure><p>此规则是基于c++中允许优化不包含成员的基类而产生的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B1</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B2</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span>:B1&#123;</span><br><span class="line">    B1 b;<span class="comment">//第一个非静态变量跟基类相同</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span>:B1&#123;</span><br><span class="line">    B2 b;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D1 d1;</span><br><span class="line">    D2 d2;</span><br><span class="line">    cout&lt;&lt;hex;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(&amp;d1)&lt;&lt;endl;      <span class="comment">//7ffffffee608</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(&amp;(d1.b))&lt;&lt;endl;  <span class="comment">//7ffffffee609</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(&amp;(d1.i))&lt;&lt;endl;  <span class="comment">//7ffffffee60c</span></span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(&amp;d2)&lt;&lt;endl;      <span class="comment">//7ffffffee610</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(&amp;(d2.b))&lt;&lt;endl;  <span class="comment">//7ffffffee610</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">reinterpret_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(&amp;(d2.i))&lt;&lt;endl;  <span class="comment">//7ffffffee614</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D1和D2的区别是第一个非静态成员类型，在D1中第一个非静态成员类型为B1(与基类相同)，D2第一个非静态成员是B2类型。从main函数的打印中可以看到D1中第一个成员的地址与对象的地址不同(相差一个字节)，D2的第一个数据成员地址与对象地址相同。</p><p>事实上，在C++标准中，如果基类没有成员，标准允许派生类的第一 个成员与基类共享地址。因为派生类的地址总是“堆叠”在基类之上 的，所以这样的地址共享，表明了基类并没有占据任何的实际空间 （可以节省一点数据）。<strong>但是如果基类的第一个成员仍然是基类，在 我们的例子中可以看到，编译器仍然会为基类分配1字节的空间。分配为1字节空间是由于C++标准要求类型相同的对象必须地址不同（基类 地址及派生类中成员d的地址必须不同）</strong>，而导致的结果是，对于D1 和D2两种类型而言，其“布局”也就是不同的了</p><p><strong>所以在标准布局的解释中，C++11标准强制要求派生类的第一个非静态成员的类型必须不同于基类。</strong></p></li><li><p>没有虚函数和虚基类</p></li><li><p>所有非静态数据成员均符合标准布局类型，其基类也符合标准布局。这是一个递归的定义</p></li></ol></blockquote><p>在C++11中，我们可以使用模板类来帮助判断类型是否是一个 标准布局的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">std</span>::is_standard_layout;</span><br><span class="line">通过is_standard_layout模板类的成员value（is_standard_layout＜T＞::value），我们可以在代码中打印出类型的标准布局属性</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SLayout1</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLayout2</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLayout3</span>:SLayout1&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLayout4</span>:SLayout1&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    SLayout1 y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLayout5</span>:SLayout1,SLayout3&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLayout6</span>&#123;<span class="type">static</span> <span class="type">int</span> y;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SLayout7</span>:SLayout6&#123;<span class="type">int</span> x;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NonSLayout1</span>:SLayout1&#123;</span><br><span class="line">    SLayout1 x;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NonSLayout2</span>:SLayout2&#123;<span class="type">int</span> z;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NonSLayout3</span>:NonSLayout2&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NonSLayout4</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;SLayout1&gt;::value&lt;&lt;endl;<span class="comment">//1</span></span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;SLayout2&gt;::value&lt;&lt;endl;<span class="comment">//1</span></span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;SLayout3&gt;::value&lt;&lt;endl;<span class="comment">//1</span></span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;SLayout4&gt;::value&lt;&lt;endl;<span class="comment">//1</span></span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;SLayout5&gt;::value&lt;&lt;endl;<span class="comment">//1</span></span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;SLayout6&gt;::value&lt;&lt;endl;<span class="comment">//1</span></span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;SLayout7&gt;::value&lt;&lt;endl;<span class="comment">//1</span></span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;NonSLayout1&gt;::value&lt;&lt;endl;<span class="comment">//0</span></span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;NonSLayout2&gt;::value&lt;&lt;endl;<span class="comment">//0</span></span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;NonSLayout3&gt;::value&lt;&lt;endl;<span class="comment">//0</span></span><br><span class="line">    cout&lt;&lt;is_standard_layout&lt;NonSLayout4&gt;::value&lt;&lt;endl;<span class="comment">//0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在c++11中对于POD而言就是平凡和标准布局两个方面，要判定某一类型是否是 POD，标准库中的＜type_traits＞头文件也为程序员提供了如下模板类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">std</span>::is_pod;</span><br><span class="line"><span class="comment">//同样也提供了 value成员 用于判断类型是否为 pod 类型</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">U</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U1</span>&#123;<span class="built_in">U1</span>()&#123;&#125;&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">E</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span>*DA;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*PF)</span><span class="params">(<span class="type">int</span>,<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;is_pod&lt;U&gt;::value&lt;&lt;endl;<span class="comment">//1</span></span><br><span class="line">    cout&lt;&lt;is_pod&lt;U1&gt;::value&lt;&lt;endl;<span class="comment">//0</span></span><br><span class="line">    cout&lt;&lt;is_pod&lt;E&gt;::value&lt;&lt;endl;<span class="comment">//1</span></span><br><span class="line">    cout&lt;&lt;is_pod&lt;<span class="type">int</span>&gt;::value&lt;&lt;endl;<span class="comment">//1</span></span><br><span class="line">    cout&lt;&lt;is_pod&lt;DA&gt;::value&lt;&lt;endl;<span class="comment">//1</span></span><br><span class="line">    cout&lt;&lt;is_pod&lt;PF&gt;::value&lt;&lt;endl;<span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POD类型的好处："><a href="#POD类型的好处：" class="headerlink" title="POD类型的好处："></a>POD类型的好处：</h2><ol><li>字节赋值，代码中我们可以安全地使用memset和memcpy对POD类 型进行初始化和拷贝等操作。</li><li>提供对C内存布局兼容。C++程序可以与C函数进行相互操作，因 为POD类型的数据在C与C++间的操作总是安全的。</li><li>保证了静态初始化的安全有效。静态初始化在很多时候能够提高程序的性能，而POD类型的对象初始化往往更加简单（比如放入目标文件的.bss段，在初始化中直接被赋0）。</li></ol><h3 id="什么是静态初始化："><a href="#什么是静态初始化：" class="headerlink" title="什么是静态初始化："></a>什么是静态初始化：</h3><p>如果初始化值是常量并且静态变量本身是基本数据类型(POD)<br>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> val = <span class="number">10</span>;            </span><br><span class="line"><span class="type">char</span> strArray[] = <span class="string">&quot;hello! world&quot;</span>;</span><br><span class="line"><span class="comment">// 10 和 &quot;hello world&quot; 为常量，val strArray 为POD类型</span></span><br></pre></td></tr></table></figure><p>那么这个初始化过程是在编译期间完成的, 这也就是通常所说的”编译时初始化”.</p><p>若不是上述情况就一定是动态初始化了，<strong>动态初始化又分为两种 加载时初始化 和 使用时初始化</strong>，暂不清楚</p><p>参考：书籍《深入理解c++11》</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>右值、右值引用、完美转发</title>
      <link href="/2023/04/17/%E5%8F%B3%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
      <url>/2023/04/17/%E5%8F%B3%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="右值、右值引用、完美转发"><a href="#右值、右值引用、完美转发" class="headerlink" title="右值、右值引用、完美转发"></a>右值、右值引用、完美转发</h1><h2 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h2><p>C++中有一个被广泛 认同的说法，那就是可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值，对于<code> a = b + c</code>这个赋值表达式，<code>&amp;a</code>是允许操作的，但<code>&amp;(a+b)</code>是不被允许的，因此<code>a</code>是一个左 值，<code>(b+c)</code>是一个右值。</p><p>更为细致地，在C++11中，右值是由 两个概念构成的，一个是将亡值(xvalue，eXpiring Value)，另一个 则是纯右值(prvalue，Pure Rvalue)。</p><p>其中纯右值就是C++98标准中右值的概念，讲的是用于辨识临时变量和一些不跟对象关联的值。比如非引用返回的函数返回的临时变量值就是一个纯右值。一些运算表达式，比如 1+3产生的临时变量值，也是纯右值。而不跟对象关联的字面量值， 比如：2、‘c’、true，也是纯右值。此外，类型转换函数的返回值、 lambda表达式等，也都是右值。</p><p>而将亡值则是C++11新增的跟右值引用相关的表达式，<strong>这样表达式通常是将要被移动的对象（移为他用）</strong>，比如返回右值引用T＆＆的函数返回值、std::move的返回值，或者转换为T＆＆的类型转换函数的返回值（稍后解释）。而剩余的，可以标识函数、对象的值都属于左值。在C++11的程序中，所有的值必属于左值、将亡值、纯右值三者之一。</p><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>在C++11中，右值引用就是对一个右值进行引用的类型。事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。 通常情况下，我们只能是从右值表达式获得其引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T&amp;&amp; a = Return <span class="built_in">nRvalue</span>();    <span class="comment">//减少了一次构造与析构</span></span><br></pre></td></tr></table></figure><p>引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则 是不具名（匿名）变量的别名。</p><p>通过右值引用的声明，该右值又“重获新生”，其生命周期将与右值引用类型变量a的生命期一样。只要a还“活着”，该右值临时量将会一直“存 活”下去。</p><p>右值引用不能绑定任何左值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="type">int</span> &amp;&amp; d = c;</span><br></pre></td></tr></table></figure><p>这将无法通过编译</p><p>在c++98中存在可以将右值绑定到左值引用的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T&amp; e = <span class="built_in">ReturnRvalue</span>();         <span class="comment">//左值引用无法绑定右值对象，无法编译</span></span><br><span class="line"><span class="type">const</span> T&amp; f = <span class="built_in">returnRvalue</span>();   <span class="comment">//常量左值可以接受右值对象</span></span><br></pre></td></tr></table></figure><p>常量左值引用在C++98标准中开始就是 个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其 进行初始化。而且在<strong>使用右值对其初始化的时候，常量左值引用还可以像右值引用一样将右值的生命期延长</strong>。不过相比于右值引用所引用的右值，常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</p><p>常量左值避免拷贝的发生：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Copyable</span>&#123;</span><br><span class="line">    <span class="built_in">Copyable</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Copyable</span>(<span class="type">const</span> Copyable&amp;o)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Copied&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Copyable <span class="title">ReturnRvalue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Copyable</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AcceptVal</span><span class="params">(Copyable)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AcceptRef</span><span class="params">(<span class="type">const</span> Copyable&amp;)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Pass by value:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">AcceptVal</span>(<span class="built_in">ReturnRvalue</span>());<span class="comment">//临时值被拷贝传入</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Pass by reference:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">AcceptRef</span>(<span class="built_in">ReturnRvalue</span>());<span class="comment">//临时值被作为引用传递,直接使用函数返回的右值，从而避免了拷贝构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时可能不知道一个类型是否是引用类型，以及是左值引用还是右值引用、标准库在<code>＜type_traits＞</code>头 文件中提供了3个模板类：<code>is_rvalue_reference、is_lvalue_reference、 is_reference</code>,如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;is_rvalue_reference&lt;string&amp;&amp;&gt;::value;</span><br></pre></td></tr></table></figure><p>这三个模板类常用于模板中，可以配个decltype推导出类型</p><h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p>std::move的唯一功能是将一个左值强制转换为右值引用，让我们可以通过右值引用使用该值，用于移动构造，std::move基本等同于一个类型转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(lvalue);</span><br></pre></td></tr></table></figure><p><strong>被转化的左值，其生命周期并没有随着左右值的转化而改变</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Moveable</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Moveable</span>():<span class="built_in">i</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>))&#123;&#125;</span><br><span class="line">    ~<span class="built_in">Moveable</span>()&#123;<span class="keyword">delete</span> i;&#125;</span><br><span class="line">    <span class="built_in">Moveable</span>(<span class="type">const</span> Moveable&amp;m):<span class="built_in">i</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*m.i))&#123;&#125;</span><br><span class="line">    <span class="built_in">Moveable</span>(Moveable&amp;&amp;m):<span class="built_in">i</span>(m.i)&#123;</span><br><span class="line">        m.i=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>*i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Moveable a;</span><br><span class="line">    <span class="function">Moveable <span class="title">c</span><span class="params">(move(a))</span></span>;<span class="comment">//会调用移动构造函数</span></span><br><span class="line">    cout&lt;&lt;*a.i&lt;&lt;endl;<span class="comment">//运行时错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为对象a调用move函数，使用移动语义构造对象c，这样a中托管堆内存的指针将会制空，访问空指针将会报错。要使用该函数，必须是程序员清楚需要转换的时候。比如上例中，程序员应该知道被转化为右值的a不可以再使用。不过更多地，我们需要转换成为右值引用的还是一个确实生命期即将结束的对象</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HugeMem</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HugeMem</span>(<span class="type">int</span> size):<span class="built_in">sz</span>(size&gt;<span class="number">0</span>?size:<span class="number">1</span>)&#123;</span><br><span class="line">        c=<span class="keyword">new</span> <span class="type">int</span>[sz];</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">HugeMem</span>()&#123;<span class="keyword">delete</span>[] c;&#125;</span><br><span class="line">    <span class="built_in">HugeMem</span>(HugeMem&amp;&amp;hm):<span class="built_in">sz</span>(hm.sz),<span class="built_in">c</span>(hm.c)&#123;</span><br><span class="line">        hm.c=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>*c;</span><br><span class="line">    <span class="type">int</span> sz;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HugeMem</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HugeMem</span>(<span class="type">int</span> size):<span class="built_in">sz</span>(size&gt;<span class="number">0</span>?size:<span class="number">1</span>)&#123;</span><br><span class="line">        c=<span class="keyword">new</span> <span class="type">int</span>[sz];</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">HugeMem</span>()&#123;<span class="keyword">delete</span>[] c;&#125;</span><br><span class="line">    <span class="built_in">HugeMem</span>(HugeMem&amp;&amp; hm):<span class="built_in">sz</span>(hm.sz),<span class="built_in">c</span>(hm.c)&#123;</span><br><span class="line">        hm.c=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>*c;</span><br><span class="line">    <span class="type">int</span> sz;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Moveable</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Moveable</span>():<span class="built_in">i</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>)),<span class="built_in">h</span>(<span class="number">1024</span>)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">Moveable</span>()&#123;<span class="keyword">delete</span> i;&#125;</span><br><span class="line">    <span class="built_in">Moveable</span>(Moveable&amp;&amp;m):</span><br><span class="line">    <span class="built_in">i</span>(m.i),<span class="built_in">h</span>(<span class="built_in">move</span>(m.h))&#123;    <span class="comment">//强制转为右值，以调用HugeMem的移动构造函数</span></span><br><span class="line">        m.i=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>*i;</span><br><span class="line">    HugeMem h;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Moveable <span class="title">GetTemp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Moveable tmp=<span class="built_in">Moveable</span>();</span><br><span class="line">    cout&lt;&lt;hex&lt;&lt;<span class="string">&quot;Huge Mem from&quot;</span>&lt;&lt;__func__</span><br><span class="line">    &lt;&lt;<span class="string">&quot;@&quot;</span>&lt;&lt;tmp.h.c&lt;&lt;endl;<span class="comment">//Huge Mem from GetTemp@0x603030</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Moveable <span class="title">a</span><span class="params">(GetTemp())</span></span>;</span><br><span class="line">    cout&lt;&lt;hex&lt;&lt;<span class="string">&quot;Huge Mem from&quot;</span>&lt;&lt;__func__</span><br><span class="line">    &lt;&lt;<span class="string">&quot;@&quot;</span>&lt;&lt;a.h.c&lt;&lt;endl;<span class="comment">//Huge Mem from main@0x603030</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里在调用Moveable的移动构造时，初始化列表中使用了<code>h(move*m.h)</code>,强制将一个左值对象转化为右值对象并调用移动构造。可以接受右值引用的本身却是一个左值，这里的m.h引用了一个确定的对象，而且m.h也有名字，可以使 用＆m.h取到地址，因此是个不折不扣的左值。不过这个左值确确实实 会很快“灰飞烟灭”，因为拷贝构造函数在Moveable对象a的构造完成后也就结束了。那么这里使用std::move强制其为右值就不会有问题了。 而且，如果我们不这么做，由于m.h是个左值，就会导致调用 HugeMem的拷贝构造函数来构造Moveable的成员h</p><p>在标准库的头文件＜type_traits＞里，我们还可以通过一些辅助的模板 类来判断一个类型是否是可以移动的比如：<code>is_move_construcctible  is_trivially_move_constructible  is_nothrow_move_constructible</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;is_move_constructible&lt;UnknownType&gt;::value;</span><br></pre></td></tr></table></figure><p>这样就可以判断类型<code>Unknow</code>是否可以移动了</p><p>有了移动语义，就可以实现高性能的置换(swap)了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">tem</span><span class="params">(move(a))</span></span>;</span><br><span class="line">    a = <span class="built_in">move</span>(b);</span><br><span class="line">    b = tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果T是可以移动的，那么将没有堆资源的申请与释放，如果T是不可以移动的但是支持拷贝，那么将调用拷贝构造与拷贝赋值完成，因此在移动语义的支持下， 我们仅仅通过一个通用的模板，就可能更高效地完成置换，这对于泛型编程来说，无疑是具有积极意义的。</p><p>例外对于移动构造函数应该避免抛出异常，可能移动语义还没有完成，此时抛出了异常，这可能导致一些指针成为悬挂指针，通过为其添加一个noexcept关键 字，可以保证移动构造函数中抛出来的异常会直接调用terminate程序终止运行，而不是造成指针悬挂的状态</p><p>标准库中提供了<code>std::move_if_noexcept</code>的模板函数替代move，该函数在类的移动构造函数没有noexcept关键字修饰时返回一个左值引用从而使变量可以使用拷贝语义，而在类的移动构造函数有noexcept关键字时，返回一个右值引用，从而使变量可以使用移动语义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Maythrow</span>&#123;</span><br><span class="line">    <span class="built_in">Maythrow</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Maythrow</span>(<span class="type">const</span> Maythrow&amp;)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Maythorow copy constructor.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Maythrow</span>(Maythrow&amp;&amp;)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Maythorow move constructor.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Nothrow</span>&#123;</span><br><span class="line">    <span class="built_in">Nothrow</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Nothrow</span>(Nothrow&amp;&amp;)<span class="keyword">noexcept</span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Nothorow move constructor.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Nothrow</span>(<span class="type">const</span> Nothrow&amp;)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Nothorow move constructor.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Maythrow m;</span><br><span class="line">    Nothrow n;</span><br><span class="line">    Maythrow mt=<span class="built_in">move_if_noexcept</span>(m); <span class="comment">//Maythorow copy constructor.</span></span><br><span class="line">    Nothrow nt=<span class="built_in">move_if_noexcept</span>(n);  <span class="comment">//Nothorow move constructor.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>所谓完美转发（perfect forwarding），是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另外一个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">templete&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IamForwording</span><span class="params">(T t)</span></span>&#123;<span class="built_in">IrunCodeActually</span>(t);&#125;</span><br></pre></td></tr></table></figure><p>IamForwording是转发函数，IrunCodeActually是真正的目标函数，对于目标函数来说总是希望转发函数将参数按照传入IamForwording函数时的类型传递，即即传入IamForwording的是左值对象， IrunCodeActually就能获得左值对象，传入IamForwording的是右值对 象，IrunCodeActually就能获得右值对象，不产生额外的开销就好像转发者不存在一样<br>当传入基本类型时，该方法会导致多次拷贝的发生，这称不上完美。通常我们需要一个引用类型，引用类型不会有拷贝的开销。其次也要考虑转发函数对类型的接受能力(可能是左值也可能是右值)，</p><p>引用折叠:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int</span> T;</span><br><span class="line"><span class="keyword">typedef</span> T&amp; TR;</span><br><span class="line">TR&amp; v = <span class="number">1</span>;             <span class="comment">//该声明在C++98中会导致编译错误,v的类型为const int&amp;</span></span><br></pre></td></tr></table></figure><p>引用折叠的规则</p><table><thead><tr><th>TR的类型定义</th><th>声明v的类型</th><th>v的实际类型</th></tr></thead><tbody><tr><td>T&amp;</td><td>TR</td><td>A&amp;</td></tr><tr><td>T&amp;</td><td>TR&amp;</td><td>A&amp;</td></tr><tr><td>T&amp;&amp;</td><td>TR</td><td>A&amp;&amp;</td></tr><tr><td>T&amp;&amp;</td><td>TR</td><td>A&amp;&amp;</td></tr><tr><td>T&amp;&amp;</td><td>TR&amp;</td><td>A&amp;</td></tr><tr><td>T&amp;&amp;</td><td>TR&amp;&amp;</td><td>A&amp;&amp;</td></tr></tbody></table><p>一旦在定义中出现左值引用，引用折叠总是优先将其折叠左值引用<br>而模板对类型的推导规则就比较简单， 当转发函数的实参是类型X的一个左值引用，那么模板参数被推导为X &amp;类型，而转发函数的实参是类型X的一个右值引用的话，那么模板 的参数被推导为X&amp;&amp;类型。</p><p>有了对于模板的引用折叠就可以对上面的模板进行改进了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IamForwording</span><span class="params">(T&amp;&amp;t)</span></span>&#123;</span><br><span class="line"><span class="built_in">IrunCodeActually</span>(<span class="built_in">static_cass</span>&lt;T&amp;&amp;&gt;(t));    <span class="comment">//在传递右值时起作用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>static_cast&lt;T&amp;&amp;&gt;的重要性：</p><blockquote><p>  对于一个右值而言，当它使用右值引用表达式引用的时候，该右 值引用却是个不折不扣的左值，那么我们想在函数调用中继续传递右 值，就需要使用std::move来进行左右值的转换。而std::move通常就是 一个static_cast。</p></blockquote><p>不过在c++11中，用于完美转发的函数不在叫move了，而是::forward，故对模板函数改进</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IamForwording</span><span class="params">(T&amp;&amp;t)</span></span>&#123;</span><br><span class="line"><span class="built_in">IrunCodeActually</span>(forward(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">int</span>&amp;&amp;m)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;rvalue ref&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">int</span>&amp;m)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;lvalue ref&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;&amp;m)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;const rvalue ref&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;m)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;const lvalue ref&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T&amp;&amp;t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">RunCode</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c=<span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> d=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">PerfectForward</span>(a);          <span class="comment">//lvalue ref</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(<span class="built_in">move</span>(b));    <span class="comment">//rvalue ref</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(c);          <span class="comment">//const lvalue ref</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(<span class="built_in">move</span>(d));    <span class="comment">//const rvalue ref</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T&amp;&amp;t,U&amp;Func)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;t&lt;&lt;<span class="string">&quot;\tforwarded...&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">Func</span>(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">double</span>&amp;&amp;m)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunHome</span><span class="params">(<span class="type">double</span>&amp;&amp;h)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunComp</span><span class="params">(<span class="type">double</span>&amp;&amp;c)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">PerfectForward</span>(<span class="number">1.5</span>,RunComp);<span class="comment">//1.5 forwarded...</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(<span class="number">8</span>,RunCode);<span class="comment">//8 forwarded...</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(<span class="number">1.5</span>,RunHome);<span class="comment">//1.5 forwarded...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：书籍《深入理解c++11》</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>委托构造</title>
      <link href="/2023/04/14/%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0/"/>
      <url>/2023/04/14/%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h1><p>委托构造函数是c++11对C++的构造函数的一项改进，其目的也是为了减少程序员书写构造函数的时间</p><p>先来看下构造函数的冗余：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Info</span>():<span class="built_in">type</span>(<span class="number">1</span>),<span class="built_in">name</span>(<span class="string">&#x27;a&#x27;</span>)&#123;<span class="built_in">InitRest</span>();&#125;</span><br><span class="line"><span class="built_in">Info</span>(<span class="type">int</span> i):<span class="built_in">type</span>(i),<span class="built_in">name</span>(<span class="string">&#x27;a&#x27;</span>)&#123;<span class="built_in">InitRest</span>();&#125;</span><br><span class="line"><span class="built_in">Info</span>(<span class="type">char</span> e):<span class="built_in">type</span>(<span class="number">1</span>),<span class="built_in">name</span>(e)&#123;<span class="built_in">InitRest</span>();&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitRest</span><span class="params">()</span></span>&#123;<span class="comment">/*其他初始化*/</span>&#125;</span><br><span class="line"><span class="type">int</span> type;</span><br><span class="line"><span class="type">char</span> name;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以使用c++11中提供的默认参数来进行改进</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Info</span>()&#123;<span class="built_in">InitRest</span>();&#125;</span><br><span class="line"><span class="built_in">Info</span>(<span class="type">int</span> i):<span class="built_in">type</span>(i) &#123;<span class="built_in">InitRest</span>();&#125;</span><br><span class="line"><span class="built_in">Info</span>(<span class="type">char</span> e):<span class="built_in">name</span>(e)&#123;<span class="built_in">InitRest</span>();&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitRest</span><span class="params">()</span></span>&#123;<span class="comment">/*其他初始化*/</span>&#125;</span><br><span class="line"><span class="type">int</span> type = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> name = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样确实简单了不少，但是每个构造函数中共还需要调用InitRest函数用于初始化其他，我们可以进行改进</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">但前提是我们能够将一个构造函数设定为“基准版</span></span><br><span class="line"><span class="comment">本”，比如本例中Info()版本的构造函数，而其他构造函数可以通过委</span></span><br><span class="line"><span class="comment">派“基准版本”来进行初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Info</span>() &#123;<span class="built_in">InitRest</span>();&#125;</span><br><span class="line"><span class="built_in">Info</span>(<span class="type">int</span> i) &#123;<span class="keyword">this</span>-&gt;<span class="built_in">Info</span>():type=i&#125;</span><br><span class="line"><span class="built_in">Info</span>(<span class="type">char</span> e)&#123;<span class="keyword">this</span>-＞<span class="built_in">Info</span>();name=e;&#125;</span><br></pre></td></tr></table></figure><p>这可能不会通过编译，因为编译器不允许在构造函数中调用构造函数，但是可以使用<strong>定位new</strong>的方法</p><p>定位new</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>(起始地址) 类型(参数);  <span class="comment">//返回构造对象的起始地址</span></span><br></pre></td></tr></table></figure><p>可以进行如下调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Info</span>()&#123;<span class="built_in">InitRest</span>();&#125;</span><br><span class="line"><span class="built_in">Info</span>(<span class="type">int</span> i)&#123;<span class="keyword">new</span>(<span class="keyword">this</span>)<span class="built_in">Info</span>();type=i;&#125;</span><br><span class="line"><span class="built_in">Info</span>(<span class="type">char</span> e)&#123;<span class="keyword">new</span>(<span class="keyword">this</span>)<span class="built_in">Info</span>();name=e;&#125;</span><br></pre></td></tr></table></figure><p>使用定位new在本对象的地址上调用类的无参构造函数，虽然这绕过了编译器的检查但是在已经初始化一部分的对象上再次调用构造函数是危险的，c++11提供了<strong>委托构造</strong>来完成上述希望完成的事情，<strong>委托构造函数与目标构造函数使用同一块内存</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Info</span>()&#123;<span class="built_in">InitRest</span>();&#125;   <span class="comment">//基准版本的构造函数</span></span><br><span class="line"><span class="built_in">Info</span>(<span class="type">int</span> i):<span class="built_in">Info</span>()&#123;type=i;&#125;   <span class="comment">//在初始化列表中委托构造函数完成一部分初始化工作</span></span><br><span class="line"><span class="built_in">Info</span>(<span class="type">char</span> e):<span class="built_in">Info</span>()&#123;name=e;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitRest</span><span class="params">()</span></span>&#123;<span class="comment">/*其他初始化*/</span>&#125;</span><br><span class="line"><span class="type">int</span> type&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">char</span> name&#123;<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>委派构造函数<strong>只能在函数体中</strong>为type、 name等成员赋初值，这是由于委派构造函数不能有初始化列表造成的。在C++中，<strong>构造函数不能同时“委派”和使用初始化列表</strong>，所以如 果委派构造函数要给变量赋初值，初始化代码必须放在函数体中</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rule1</span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">Rule1</span>(<span class="type">int</span> a):<span class="built_in">i</span>(a)&#123;&#125;</span><br><span class="line"><span class="built_in">Rule1</span>():<span class="built_in">Rule1</span>(<span class="number">40</span>),<span class="built_in">i</span>(<span class="number">1</span>)&#123;&#125;<span class="comment">//无法通过编译,即使用委托构造，又使用初始化列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>是无法通过编译的</p><p>可能遇到的问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Info</span>()&#123;<span class="built_in">InitRest</span>();&#125;   <span class="comment">//基准版本的构造函数</span></span><br><span class="line"><span class="built_in">Info</span>(<span class="type">int</span> i):<span class="built_in">Info</span>()&#123;type=i;&#125;   <span class="comment">//在初始化列表中委托构造函数完成一部分初始化工作</span></span><br><span class="line"><span class="built_in">Info</span>(<span class="type">char</span> e):<span class="built_in">Info</span>()&#123;name=e;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitRest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">type++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> type&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">char</span> name&#123;<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Info <span class="title">f</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="comment">//初始化完成后 type 为 3</span></span><br><span class="line">    <span class="comment">// Info(3) -&gt; Info() -&gt; InitBest() 执行 type++ -&gt; 执行 type = i </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是不符合预期的，改进方法(将InitRest中的代码放入委托构造函数中)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Info</span>():<span class="built_in">Info</span>(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)&#123;&#125;</span><br><span class="line"><span class="built_in">Info</span>(<span class="type">int</span> i):<span class="built_in">Info</span>(i,<span class="string">&#x27;a&#x27;</span>)&#123;&#125;</span><br><span class="line"><span class="built_in">Info</span>(<span class="type">char</span> e):<span class="built_in">Info</span>(<span class="number">1</span>,e)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Info</span>(<span class="type">int</span> i,<span class="type">char</span> e):<span class="built_in">type</span>(i),<span class="built_in">name</span>(e)</span><br><span class="line">&#123;</span><br><span class="line">type++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> type;</span><br><span class="line"><span class="type">char</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Info</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//Info(int) -&gt; Info(int i,char e)完成初始化和type++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>避免目标构造函数和委托 构造函数体中初始化同样的成员通常是必要的，否则则可能发生代码逻辑错误</strong></p><p>当在构造函数较多时，可能拥有不止一个委托构造函数，并且一些目标构造函数可能也是委托构造函数，这样就可能在链状委托构造关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Info</span>():<span class="built_in">Info</span>(<span class="number">1</span>)&#123;&#125;<span class="comment">//委派构造函数</span></span><br><span class="line"><span class="built_in">Info</span>(<span class="type">int</span> i):<span class="built_in">Info</span>(i,<span class="string">&#x27;a&#x27;</span>)&#123;&#125;<span class="comment">//既是目标构造函数，也是委派构造函数</span></span><br><span class="line"><span class="built_in">Info</span>(<span class="type">char</span> e):<span class="built_in">Info</span>(<span class="number">1</span>,e)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Info</span>(<span class="type">int</span> i,<span class="type">char</span> e):<span class="built_in">type</span>(i),<span class="built_in">name</span>(e)&#123;<span class="comment">/*其他初始化*/</span>&#125;<span class="comment">//目标构造函数</span></span><br><span class="line"><span class="type">int</span> type;</span><br><span class="line"><span class="type">char</span> name;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上代码是没有问题的，但是在写链式委托时，要注意<strong>防止形成委托环的出现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rule2</span>&#123;</span><br><span class="line"><span class="type">int</span> i,c;</span><br><span class="line"><span class="built_in">Rule2</span>():<span class="built_in">Rule2</span>(<span class="number">2</span>)&#123;&#125;</span><br><span class="line"><span class="built_in">Rule2</span>(<span class="type">int</span> i):<span class="built_in">Rule2</span>(<span class="string">&#x27;c&#x27;</span>)&#123;&#125;</span><br><span class="line"><span class="built_in">Rule2</span>(<span class="type">char</span> c):<span class="built_in">Rule2</span>(<span class="number">2</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Rule()，Rule(int)，Rule(char) 相互依赖形成了委托环，这样代码通常不会通过编译</p><p>模板做委托构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TDConstructed</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="title">TDConstructed</span><span class="params">(T first,T last)</span> : l(first,last)&#123;</span>&#125;</span><br><span class="line">    <span class="comment">//first 和 last 是模板函数参数，在初始化列表中为 list&lt;int&gt; l</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l;    <span class="comment">//这里使用int是因为 int既可以接受int也可以接受short类型，不会导致溢出</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TDConstructed</span>(vector&lt;<span class="type">short</span>&gt; &amp;v) : <span class="built_in">TDConstructed</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>())&#123;&#125;</span><br><span class="line">    <span class="built_in">TDConstructed</span>(deque&lt;<span class="type">int</span>&gt; &amp;d) : <span class="built_in">TDConstructed</span>(d.<span class="built_in">begin</span>(),d.<span class="built_in">end</span>())&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">short</span>&gt;vi = &#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">67</span>，<span class="number">8</span>，<span class="number">9</span>，<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function">TDConstructed <span class="title">t</span><span class="params">(vi)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的委托函数使用了一个模板函数，目标构造函数参数为容器类型，调用委托构造函数时，将模板参数实例化为迭代器类型，在委托构造函数中的初始化列表中完成对链表的初始化即使用迭代器对链表初始化。这样一来，我们的 TDConstructed类就可以很容易地接受多种容器对其进行初始化。这无疑比罗列不同类型的构造函数方便了很多。可以说，委托构造使得构 造函数的泛型编程也成为了一种可能。</p><p>参考：书籍《深入理解c++11》</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外部模板</title>
      <link href="/2023/04/11/%E5%A4%96%E9%83%A8%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/04/11/%E5%A4%96%E9%83%A8%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="外部模板"><a href="#外部模板" class="headerlink" title="外部模板"></a>外部模板</h1><h2 id="引入："><a href="#引入：" class="headerlink" title="引入："></a>引入：</h2><p>外部模板是c++11对模板性能的改进</p><p>extern在c中就已经存在了，然而在c语言中extern关键字是为了防止编译完成后的数据重复导致链接器工作时无法决定相同的符号是否需要合并而报错</p><p>对于函数模板或类模板来说，发生问题的不再是数据而是代码，这种问题是由于模板的实例化带来的。这之间只涉及了代码与数据无关，故使用函数模板来演示</p><blockquote><p>  存在一个 <em>test.h</em> 文件中声明模板函数<code>template&lt;typename T&gt; void fun(T)&#123;&#125;</code></p><p>  在<em>test1.cpp</em>文件中定义了</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;test.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;<span class="built_in">func</span>(<span class="number">3</span>);&#125;</span><br></pre></td></tr></table></figure><p>  在<em>test2</em>文件中定义了</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;test.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;<span class="built_in">func</span>(<span class="number">4</span>);&#125;</span><br></pre></td></tr></table></figure></blockquote><p>两个 cpp 文件中，编译器实例化了两个 相同的函数<code>void func&lt;int&gt;(int)</code>，代码重复相比数据重复相对好些，数据重复连接器会报错，而代码重复，为了节省内存，保留其中的一份即可(代码完全相同的情况下)，这样就解决了实例化代码冗余问题</p><p><img src="/img/Snipaste_2023-04-11_10-50-21.png"></p><p>由于源码中出现的每一处模板实例化，编译器都要进行实例化操作，而在链接时又只保留一份，这无疑是增加了编译器编译和连接器链接消耗的时间，解决这个问题的方法与解决数据重复的思路时类似的，使用<strong>外部的模板</strong></p><h2 id="显示的实例化与外部模板声明"><a href="#显示的实例化与外部模板声明" class="headerlink" title="显示的实例化与外部模板声明"></a>显示的实例化与外部模板声明</h2><p>外部模板的使用依赖c++98中已有的特性，<em>显式实例化</em></p><p>显示实例化语法：</p><blockquote>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于模板</span><br><span class="line">template&lt;typename T&gt; <span class="type">void</span> <span class="title function_">func</span><span class="params">(T)</span>&#123;&#125;</span><br><span class="line">声明：</span><br><span class="line">tempalte <span class="type">void</span> func&lt;<span class="type">int</span>&gt;(<span class="type">int</span>);  <span class="comment">//显示实例化一个int版本</span></span><br></pre></td></tr></table></figure><p>  这就可以使编译器在本编译单元中实例化出一个fun＜int＞(int)版本的 函数（这种做法也被称为强制实例化）</p></blockquote><p>在c++11中增加了外部模板(Extern Template)的声明。语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">void</span> <span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>);   </span><br><span class="line"><span class="comment">//标识模板函数 tempalte void func&lt;int&gt;(int)在外部编译单元中已经存在</span></span><br></pre></td></tr></table></figure><p>这样就完成了一个外部模板的声明了</p><p>对之前代码改进：</p><blockquote><p>  test1.cpp</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>)  <span class="comment">//显示的实例化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;<span class="built_in">fun</span>(<span class="number">3</span>);&#125;</span><br></pre></td></tr></table></figure><p>  在test2.cpp中做外部模板的声明</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">void</span> <span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>);  <span class="comment">//外部模板声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span><span class="params">(fun(<span class="number">4</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>  这样一来，在test2.o中不会再生成fun＜int＞(int)的实例代码</p></blockquote><p>整个模板实例化的流程：</p><p><img src="/img/Snipaste_2023-04-11_11-11-46.png"></p><p>这里也可以把外部模板声明放在头文件中，这样所有包含test.h的头文件就可以共享这个外部模板声明了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#program once</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">fun</span><span class="params">(T)</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="type">void</span> <span class="built_in">fun</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>);   </span><br><span class="line">但是必须在一个 .cpp 文件中显示的声明  <span class="keyword">template</span> <span class="type">void</span> <span class="built_in">fun</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>); 完成实例化，否则链接出错</span><br></pre></td></tr></table></figure><p>外部模板声明不能用于一个静态函数（即文件域函数），但可以用于类静态成员函数 （这一点是显而易见的，因为静态函数没有外部链接属性，不可能在 本编译单元之外出现）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>断言</title>
      <link href="/2023/04/07/%E6%96%AD%E8%A8%80/"/>
      <url>/2023/04/07/%E6%96%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><h2 id="运行时断言"><a href="#运行时断言" class="headerlink" title="运行时断言"></a>运行时断言</h2><p>断言就 是将一个返回值总是需要为真的判别式放在语句中，用于排除在设计 的逻辑上不应该产生的情况。断言并不是程序必须的而是用于程序的调试，可以快速定位程序出错的位置</p><p>c++标准在 <code>&lt;assert.h&gt; 或 &lt;cassert&gt;</code>中提供了 <code>assert</code>宏函数，用于<strong>运行时</strong>断言</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> assert(expr)\</span></span><br><span class="line"><span class="meta">     (static_cast <span class="string">&lt;bool&gt;</span> (expr)\</span></span><br><span class="line"><span class="meta">      ? void (0)\</span></span><br><span class="line"><span class="meta">      : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))</span></span><br></pre></td></tr></table></figure><p>运行时断言 <code>assert</code> 的基本使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">ArrAlloc</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n &gt; <span class="number">0</span>);    </span><br><span class="line">    <span class="comment">//断言n &gt; 0 ,若不满足发送终止信号，进程退出</span></span><br><span class="line">    <span class="comment">//参数可以是变量名(运行时)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ArrAlloc</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序吐核：</span><br><span class="line">报错：</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">ArrAlloc</span><span class="params">(<span class="type">int</span>)</span>: Assertion `n &gt; <span class="number">0&#x27;</span> failed.</span></span><br><span class="line"><span class="function">/bin/bash: line <span class="number">1</span>:   <span class="number">543</span> Aborted                 (core dumped) /mnt/e/code/cpp/cpp11/cmake-build-debug/cpp11</span></span><br></pre></td></tr></table></figure><p>程序在运行时收到<code>SIGABRT</code>信号导致程序终止</p><p>由于<code>assert</code>断言宏函数常用于调试功能，程序员也可以定义宏NDEBUG来禁用assert宏。这对发布程 序来说还是必要的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> __ASSERT_VOID_CAST static_cast<span class="string">&lt;void&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>NDEBUG</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> assert(expr)(__ASSERT_VOID_CAST (0))</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>当定义了<code>NDEBUG</code>时，<code>assert(expr)</code>会被替换为 <code>static_cast(0)</code>,这是无意义的，编译器通常会优化掉</p><h2 id="编译时断言"><a href="#编译时断言" class="headerlink" title="编译时断言"></a>编译时断言</h2><h3 id="预处理中的断言"><a href="#预处理中的断言" class="headerlink" title="预处理中的断言"></a>预处理中的断言</h3><p>通常为<code>#if </code> 和 <code>#error </code>配合使用</p><p><strong>#error 预处理指令的作用是，编译程序时，只要遇到#error 就会生成一个编译错误提示消息，并停止编译。</strong>其语法格式为：<code>#error error-message</code>需要注意的是：报错信息不需要加引号**<code>&quot; &quot;</code>**，如果加上，引号会被一起输出。例如将上面的 #error 命令改为</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;This programe is cannot compile at Windows Platform&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="静态断言与-static-assert"><a href="#静态断言与-static-assert" class="headerlink" title="静态断言与 static_assert"></a>静态断言与 static_assert</h3><p>引入静态断言时由于<code>assert</code>断言错误只能在运行时排查出来，有时这个是无法接受的，我们希望在编译时就可以检测出断言错误</p><p>c++11引入了<code>static_assert</code><strong>静态断言表达式</strong>，这个表达式需要一个布尔值，和一个警告信息字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t,<span class="keyword">typename</span> u&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bit_copy</span><span class="params">(t&amp;a,u&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(b)==<span class="built_in">sizeof</span>(a),<span class="string">&quot;the parameters of bit_copymust havesame width.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0x2468</span>;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="built_in">bit_copy</span>(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">编译时报错：</span><br><span class="line">Static_assert failed due to requirement <span class="string">&#x27;sizeof (b) == sizeof (a)&#x27;</span> <span class="string">&quot;the parameters of bit_copymust havesame width.&quot;</span></span><br></pre></td></tr></table></figure><p>由于 static_assert是编译时期的断言，其使用范围不像assert一样受到限制。 在通常情况下，static_assert可以用于任何命名空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) == <span class="number">8</span> , <span class="string">&quot;This 64-bit machine should follow this! &quot;</span>);  <span class="comment">//全局</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>static_assert的断言表达式的结果必须是在编译时期可以计算的表达式，即必须是<strong>常量表达式</strong>。如果使用了变量，则会导致错误</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">static_assert</span>(n&gt;<span class="number">0</span> , <span class="string">&quot;value must &gt; 0 &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">无法通过编译，n是函数参数，只有在运行期可以确定</span><br></pre></td></tr></table></figure><p>看了好多文章还是不理解常量表达式…………😫</p><p>参考：书籍《深入理解c++11》</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>预处理标识符__func__</title>
      <link href="/2023/04/06/%E9%A2%84%E5%A4%84%E7%90%86%E6%A0%87%E8%AF%86%E7%AC%A6__func__/"/>
      <url>/2023/04/06/%E9%A2%84%E5%A4%84%E7%90%86%E6%A0%87%E8%AF%86%E7%AC%A6__func__/</url>
      
        <content type="html"><![CDATA[<h1 id="func-预处理标识符"><a href="#func-预处理标识符" class="headerlink" title="__ func__ 预处理标识符"></a>__ func__ 预处理标识符</h1><p>预处理标识符<code>__func__</code>在c99标准中就已经被定义了，其基本功能是返回所在函数的名字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>*<span class="title">hello</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> __func__;&#125;     <span class="comment">//返回函数名 hello</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>*<span class="title">world</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> __func__;&#125;     <span class="comment">//返回函数名 world</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">hello</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;<span class="built_in">world</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">hello,world    </span><br></pre></td></tr></table></figure><p>按照标准规定，编译器回隐式地<strong>在函数定义之后</strong>定义<code>__func__</code>标识符</p><p>相当于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *__func__ = <span class="string">&quot;hello&quot;</span>;  <span class="comment">//在函数定义后隐式定义变量__func__</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准允许在类或结构体中使用 预处理标识符 <code>__func__</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TestStruct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">TestStruct</span>():<span class="built_in">name</span>(__func__)&#123;&#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TestStruct ts;</span><br><span class="line">    std::cout&lt;&lt;ts.name&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">TestStruct</span><br></pre></td></tr></table></figure><p>在结构体的构造函数中，初始化列表使用 <code>__func__</code>是可行的，效果相当于在函数内部使用，但是<strong>将 <code>__func__  </code> 宏作为函数参数的默认值是不可以的</strong></p><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Func</span><span class="params">(<span class="built_in">string</span> funcname = __func__)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这是无法编译的：<strong>在参数声明是 <code>__func__</code>还没有被定义</strong>，可以理解了函数Func的第一语句就是<code>static __func__ = &quot;Func&quot;</code>，在函数声明阶段 <code>__func__</code>没有被定义故无法通过编译</p><p>参考：书籍《深入理解c++11》</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++中的智能指针</title>
      <link href="/2023/04/05/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%881/"/>
      <url>/2023/04/05/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%881/</url>
      
        <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>智能指针的智能二字，主要体现在用户可以不关注资源的释放，因为智能指针会帮你完全管理资源的释放，它会保证无论程序逻辑怎么跑，正常执行或者产生异常，资源在到期的情况下，一定会进行释放。</p><p>C++11库里面，提供了<strong>带引用计数的智能指针和不带引用计数的智能指针</strong>，这篇文章主要介绍它们的原理和应用场景，包括<strong>auto_ptr，scoped_ptr，unique_ptr，shared_ptr，weak_ptr</strong>。</p><h4 id="一个简陋的智能指针"><a href="#一个简陋的智能指针" class="headerlink" title="一个简陋的智能指针"></a>一个简陋的智能指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CSmartPtr</span>(T *ptr = <span class="literal">nullptr</span>)</span><br><span class="line">        :<span class="built_in">mptr</span>(ptr)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">CSmartPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> mptr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* mptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="comment">//定义了一个CSmartPtr&lt;int&gt;的对象，对象内托管这int类型的指针</span></span><br><span class="line">    <span class="comment">//由于这个对象定义在栈上，当函数结束栈帧消失，对象自动调用析构函数，</span></span><br><span class="line">    <span class="comment">//从而使对象托管的内存自动释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可不可以将智能指针分配在堆内存上？</p><figure class="highlight plaintext"><figcaption><span>ptr2 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```c++</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class CSmartPtr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CSmartPtr(T *ptr = nullptr)</span><br><span class="line">        :mptr(ptr)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    T&amp; operator*()</span><br><span class="line">    //必须返回引用，若返回 T 类型，就相当于返回一个临时量 &lt;==&gt; 20 = 30 这显然是错误的</span><br><span class="line">    &#123;</span><br><span class="line">        return *mptr;</span><br><span class="line">    &#125;</span><br><span class="line">    T* operator-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        return mptr;</span><br><span class="line">    &#125;</span><br><span class="line">    ~CSmartPtr()</span><br><span class="line">    &#123;</span><br><span class="line">        delete mptr;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T* mptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int *p = new int;</span><br><span class="line">    CSmartPtr&lt;int&gt; ptr1(new int);</span><br><span class="line">    (*ptr1) = 20;</span><br><span class="line"></span><br><span class="line">    class Test</span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">        void test()&#123;cout&lt;&lt;&quot;Test()&quot;&lt;&lt;endl;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    CSmartPtr&lt;Test&gt; ptr3 = new(Test);</span><br><span class="line">    ptr3-&gt;test();  // 相当于 (ptr3.operator-&gt;())-&gt;test()</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不带引用计数的智能指针"><a href="#不带引用计数的智能指针" class="headerlink" title="不带引用计数的智能指针"></a>不带引用计数的智能指针</h2><p>先来看段代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;        <span class="comment">//用ptr1拷贝构造ptr2(浅拷贝)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这会导致double free</p><p>解决方案，实现深拷贝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CSmartPtr</span>(<span class="type">const</span> CSmartPtr&lt;T&gt; &amp;another)</span><br><span class="line">&#123;</span><br><span class="line">    T* p = <span class="keyword">new</span> <span class="built_in">T</span>(*(another.mptr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是，这不符合实际性</strong> ，当用户执行<code>CSmartPtr&lt;int&gt; ptr2(ptr1);</code>时，会理所当然的认为 ptr1 和 ptr2 共同管理了同一块内存。可实际却是，两个指针分别指向不同的内存资源</p><h4 id="auto-ptr拷贝构造的实现"><a href="#auto-ptr拷贝构造的实现" class="headerlink" title="auto_ptr拷贝构造的实现"></a>auto_ptr拷贝构造的实现</h4><p>我们来看看c++系统中是如何实现拷贝构造的，同时避免浅拷贝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完成了对象的托管，并将原来的指针制空</span></span><br><span class="line"><span class="built_in">auto_ptr</span>(auto_ptr&amp; __a) <span class="keyword">throw</span>() : _M_ptr(__a.<span class="built_in">release</span>()) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">release</span>() <span class="built_in">throw</span>()</span><br><span class="line">&#123;</span><br><span class="line">element_type* __tmp = _M_ptr;</span><br><span class="line">_M_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> __tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/auto_ptr%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0.png"></p><p>这就导致了一旦发生拷贝构造，原来指针就无法使用的尬尴处境，这也是不推荐使用auto_ptr的原因</p><h4 id="推荐使用unique-ptr"><a href="#推荐使用unique-ptr" class="headerlink" title="推荐使用unique_ptr"></a>推荐使用unique_ptr</h4><p>源码将拷贝构造与拷贝赋值禁用了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><p>但是提供了右值参数的拷贝构造与赋值重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp;) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure><p>使用unique_ptr</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(std::move(ptr1))</span></span>;   <span class="comment">//使用户感知到自己将ptr1的资源转移到ptr2上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用带引用计数的智能指针"><a href="#使用带引用计数的智能指针" class="headerlink" title="使用带引用计数的智能指针"></a>使用带引用计数的智能指针</h2><p>带引用计数的智能指针可以管理同一个资源<br>智能指针给每一个对象资源匹配一个引用计数<br>当智能指针在引用资源的时候引用计数加一<br>智能指针不在引用资源的时候引用计数减一当引用计数为零时，资源析构</p><h4 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefCnt</span>     <span class="comment">//用于引用计数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RefCnt</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mptr = ptr;</span><br><span class="line">            mcount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addRef</span><span class="params">()</span>   <span class="comment">//增加引用计数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mcount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">delRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mcount--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* mptr;     <span class="comment">//指向资源</span></span><br><span class="line">    <span class="type">int</span> mcount;  <span class="comment">//这个资源被引用的次数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CSmartPtr</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">        :mptr(ptr)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        mpRefcnt = <span class="keyword">new</span> <span class="built_in">RefCnt</span>&lt;T&gt;(mptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(<span class="type">const</span> CSmartPtr&lt;T&gt; &amp;src)</span><br><span class="line">        :<span class="built_in">mptr</span>(src.mptr),<span class="built_in">mpRefcnt</span>(src.mpRefcnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(src.mptr != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mpRefcnt-&gt;<span class="built_in">addRef</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CSmartPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CSmartPtr&lt;T&gt;&amp; src)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((&amp;src == <span class="keyword">this</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mpRefcnt-&gt;<span class="built_in">delRef</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> mpRefcnt-&gt;mptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mptr = src.mptr;</span><br><span class="line">        mpRefcnt = src.mpRefcnt;</span><br><span class="line">        mpRefcnt-&gt;<span class="built_in">addRef</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">    <span class="comment">//必须返回引用，若返回 T 类型，就相当于返回一个临时量 &lt;==&gt; 20 = 30 这显然是错误的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *mptr;</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> mptr;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CSmartPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mpRefcnt-&gt;<span class="built_in">delRef</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">delete</span> mptr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* mptr;                    <span class="comment">//指向资源的指针</span></span><br><span class="line">    RefCnt&lt;T&gt;* mpRefcnt;        <span class="comment">//指向资源引用计数的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="share-ptr的交叉引用问题"><a href="#share-ptr的交叉引用问题" class="headerlink" title="share_ptr的交叉引用问题"></a>share_ptr的交叉引用问题</h4><p>强智能指针：可以改变资源的引用计数 share_ptr<br>弱智能指针：不会改变资源的引用计数 weak_ptr。若智能指针只是一个观察者，无法直接访问资源，没有重载 * 与 -&gt;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;~A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    shared_ptr&lt;B&gt; _ptrb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;~B()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    shared_ptr&lt;A&gt; _ptra;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">    pa-&gt;_ptrb = pb;  <span class="comment">//使得资源pb的引用计数加一</span></span><br><span class="line">    pb-&gt;_ptra = pa;  <span class="comment">//使得资源pa的引用计数加一</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;pa.<span class="built_in">use_count</span>()&lt;&lt;endl;  <span class="comment">//use_count返回指向资源的引用计数</span></span><br><span class="line">    cout&lt;&lt;pb.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line"><span class="built_in">B</span>()</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>强智能指针的交叉引用(循环引用)造成了new出来的资源无法释放</p><p><img src="/img/share_ptr%E6%89%80%E6%B6%89%E5%8F%8A%E7%9A%84%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98.png"></p><h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h5><p>定义对象时使用强智能指针，引用对象的时候使用弱智能指针。即将类A B内智能指针改为weak_ptr即可。</p><p>但是，弱智能指针无法访问资源，没有重载 * 与 -&gt;  ，这就需要提升了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;~A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;这是一个非常好用的方法&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    weak_ptr&lt;B&gt; _ptrb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;~B()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//_ptra-&gt;test();  无法使用</span></span><br><span class="line">        shared_ptr&lt;A&gt; ps = _ptra.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">//将weak_ptr提升为share_ptr。若_ptra指向资源的引用资源计数为0则返回nullptr</span></span><br><span class="line">        <span class="comment">//否则返回share_ptr&lt;A&gt;的对象，当然这会使对象的引用计数加一</span></span><br><span class="line">        <span class="keyword">if</span>(ps != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ps-&gt;<span class="built_in">test</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    weak_ptr&lt;A&gt; _ptra;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">    pa-&gt;_ptrb = pb;</span><br><span class="line">    pb-&gt;_ptra = pa;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;pa.<span class="built_in">use_count</span>()&lt;&lt;endl;  <span class="comment">//use_count返回指向资源的引用计数</span></span><br><span class="line">    cout&lt;&lt;pb.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程访问共享对象的线程安全问题"><a href="#多线程访问共享对象的线程安全问题" class="headerlink" title="多线程访问共享对象的线程安全问题"></a>多线程访问共享对象的线程安全问题</h2><p>先来看一段代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;~A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;非常好用的方法&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler01</span><span class="params">(A* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    q-&gt;<span class="built_in">testA</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;main thread  :&quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>()&lt;&lt;endl;</span><br><span class="line">    A *p = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(handler01,p)</span></span>;</span><br><span class="line">    <span class="comment">//std::this_thread::sleep_for(std::chrono::seconds(3));</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出顺序：</span><br><span class="line">main thread  :<span class="number">1</span></span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">~<span class="built_in">A</span>()</span><br><span class="line">非常好用的方法</span><br></pre></td></tr></table></figure><p>显然这是不正确的，在线程t1中 q-&gt;testA()时，传入的A类型的对象q已经析构了。这种访问是不安全的<br>解决方案，增加引用计数用于探测q访问的对象是否存活。这就联想到了强弱智能指针了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;~A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;非常好用的方法&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler01</span><span class="params">(weak_ptr&lt;A&gt; pw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    shared_ptr&lt;A&gt; t = pw.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span>(t != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        t-&gt;<span class="built_in">testA</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ptr is ptr&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ptr is nullptr&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">shared_ptr&lt;A&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">        <span class="function">thread <span class="title">t1</span><span class="params">(handler01, weak_ptr&lt;A&gt;(p))</span></span>;</span><br><span class="line">        <span class="comment">//Zstd::this_thread::sleep_for(std::chrono::seconds(3));</span></span><br><span class="line">        t1.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="智能指针定义的删除器deletor"><a href="#智能指针定义的删除器deletor" class="headerlink" title="智能指针定义的删除器deletor"></a>智能指针定义的删除器deletor</h2><p>智能指针：能保证资源绝对释放，系统中默认是使用 delete 用于资源的释放。但是并不是所有的资源都是通过delete来释放的(比如数组要通过 delete[]  文件要通过 close ) ，这就需要我们来自定义删除器来指导智能指针删除所引用的内容</p><h4 id="unique-ptr的定义"><a href="#unique-ptr的定义" class="headerlink" title="unique_ptr的定义"></a>unique_ptr的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;</span><br><span class="line">    <span class="keyword">class</span> unique_ptr</span><br></pre></td></tr></table></figure><p>模板拥有两个参数_TP用于指定类型，_DP用于指定删除方法</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>自定义删除类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">deletorInt</span>  <span class="comment">//用于删除int数组对象</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* ptr)</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;void operator()(T* ptr)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">delete</span>[](ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">deletorFile</span>    <span class="comment">//用于删除文案对象</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fclose</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>,deletorInt&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法并不好，因为我们定义了一个模板，但是这个模板仅仅使用在智能指针的定义时，这有些浪费</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>使用ambda表达式 与 function表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>,function&lt;<span class="type">void</span>(<span class="type">int</span>*)&gt;&gt; <span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]</span><br><span class="line">            ,[](<span class="type">int</span> *pa)-&gt;<span class="type">void</span>&#123;cout&lt;&lt;<span class="string">&quot;call lambda&quot;</span>;<span class="keyword">delete</span>[] pa;&#125;</span><br><span class="line">            );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们来看看unique_ptr的源码吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">类的定义</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;</span><br><span class="line">    <span class="keyword">class</span> unique_ptr</span><br><span class="line"></span><br><span class="line">别名</span><br><span class="line"><span class="keyword">using</span> deleter_type  = _Dp;</span><br><span class="line">    </span><br><span class="line">构造函数</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Del = deleter_type,</span><br><span class="line">       <span class="keyword">typename</span> = _Require&lt;is_copy_constructible&lt;_Del&gt;&gt;&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>(pointer __p, <span class="type">const</span> deleter_type&amp; __d) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__p, __d) &#123; &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++ 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++对象的优化</title>
      <link href="/2023/04/05/c++%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%98%E5%8C%96/"/>
      <url>/2023/04/05/c++%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="对象被优化后c-才是高效的"><a href="#对象被优化后c-才是高效的" class="headerlink" title="对象被优化后c++才是高效的"></a>对象被优化后c++才是高效的</h1><h2 id="对象使用过程中背后使用哪些方法"><a href="#对象使用过程中背后使用哪些方法" class="headerlink" title="对象使用过程中背后使用哪些方法"></a>对象使用过程中背后使用哪些方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test</span>(<span class="type">int</span> a=<span class="number">10</span>) : <span class="built_in">ma</span>(a)&#123;cout&lt;&lt;<span class="string">&quot;test()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">test</span>()&#123;cout&lt;&lt;<span class="string">&quot;~test()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">test</span>(<span class="type">const</span> test&amp; t) :<span class="built_in">ma</span>(t.ma)&#123;cout&lt;&lt;<span class="string">&quot;const test*&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> test&amp;t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;operator=&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ma = t.ma;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test t1;</span><br><span class="line">    <span class="function">test <span class="title">t2</span><span class="params">(t1)</span></span>;</span><br><span class="line">    test t3 = t1;</span><br><span class="line">    <span class="comment">//对象的初始化，调用拷贝构造</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    test t4 = <span class="built_in">test</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//用于临时对象生成的新对象，临时对象生成的时候，</span></span><br><span class="line">    <span class="comment">// 临时对象不产生了，直接构造新对象就可以了</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;-----------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    t4 = t2;</span><br><span class="line">    t4 = <span class="built_in">test</span>(<span class="number">30</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    t4 = (test)<span class="number">30</span>;</span><br><span class="line">    <span class="comment">//int -&gt; test 编译器要寻找有没有=合适的构造函数来完成类型转换</span></span><br><span class="line">    <span class="comment">//若存在就会隐式生成一个临时对象</span></span><br><span class="line">    <span class="comment">//调用operator=</span></span><br><span class="line">    <span class="comment">//临时对象析构</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    t4  = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//隐式转换 从 int -&gt; test 生成临时对象</span></span><br><span class="line">    <span class="comment">//调用operator=</span></span><br><span class="line">    <span class="comment">//临时对象析构</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="built_in">test</span>()</span><br><span class="line"><span class="type">const</span> test*</span><br><span class="line"><span class="type">const</span> test*</span><br><span class="line">----------------</span><br><span class="line"><span class="built_in">test</span>()</span><br><span class="line">-----------------</span><br><span class="line">~test*()</span><br><span class="line">~test*()</span><br><span class="line">~test*()</span><br><span class="line">~test*()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test* p = &amp;<span class="built_in">test</span>(<span class="number">40</span>);</span><br><span class="line">    test&amp; ref = <span class="built_in">test</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">//const test&amp; ret = test(50) 可以，常引用用于对于临时对象的引用，这拓展了临时对象的生命周期(与ref相同)</span></span><br><span class="line">&#125;</span><br><span class="line">编译错误，临时对象在语句结束后消失，在语句执行完之后，p指向的test对象已经析构，ref同理。所以没有意义</span><br></pre></td></tr></table></figure><p>c++编译器对于对象构造的优化：用于临时对象生成的新对象，临时对象生成的时候，临时对象不产生了，直接构造新对象就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注释表明了发生的顺序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// Test() Test(10) Test(10, 10)</span></span><br><span class="line">   <span class="built_in">Test</span>(<span class="type">int</span> a = <span class="number">5</span>, <span class="type">int</span> b = <span class="number">5</span>) </span><br><span class="line">      :<span class="built_in">ma</span>(a), <span class="built_in">mb</span>(b)</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Test(int, int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   ~<span class="built_in">Test</span>()</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">Test</span>(<span class="type">const</span> Test &amp;src) </span><br><span class="line">      :<span class="built_in">ma</span>(src.ma), <span class="built_in">mb</span>(src.mb)</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;src)</span><br><span class="line">   &#123;</span><br><span class="line">      ma = src.ma; </span><br><span class="line">      mb = src.mb; </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span> ma;</span><br><span class="line">   <span class="type">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;                    <span class="comment">// 1.Test(int, int)  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;                 <span class="comment">// 3.Test(int, int)</span></span><br><span class="line">   Test t3 = t2;                    <span class="comment">// 4.Test(const Test&amp;)</span></span><br><span class="line">   <span class="comment">// static Test t4(30, 30);</span></span><br><span class="line">   <span class="type">static</span> Test t4 = <span class="built_in">Test</span>(<span class="number">30</span>, <span class="number">30</span>);   <span class="comment">// 5.Test(int, int)，虽然这也是全局的但是位于函数内部</span></span><br><span class="line">   t2 = <span class="built_in">Test</span>(<span class="number">40</span>, <span class="number">40</span>);    <span class="comment">// 6.Test(int, int) operator= ~Test()</span></span><br><span class="line">     <span class="comment">// (50, 50) =  (Test)50; Test(int)</span></span><br><span class="line">   t2 = (Test)(<span class="number">50</span>, <span class="number">50</span>); <span class="comment">// 7.Test(int,int) operator=  ~Test()</span></span><br><span class="line">   t2 = <span class="number">60</span>; <span class="comment">//Test(int) 8.Test(int,int) operator= ~Test()</span></span><br><span class="line">   Test *p1 = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">70</span>, <span class="number">70</span>); <span class="comment">// 9. Test(int,int) </span></span><br><span class="line">   Test *p2 = <span class="keyword">new</span> Test[<span class="number">2</span>]; <span class="comment">// 10. Test(int,int) Test(int,int)</span></span><br><span class="line">   Test *p3 = &amp;<span class="built_in">Test</span>(<span class="number">80</span>, <span class="number">80</span>); <span class="comment">// 11. Test(int,int)  ~Test()</span></span><br><span class="line">   <span class="type">const</span> Test &amp;p4 = <span class="built_in">Test</span>(<span class="number">90</span>, <span class="number">90</span>); <span class="comment">// 12. Test(int,int)</span></span><br><span class="line">   <span class="keyword">delete</span> p1;                                                           <span class="comment">// 13.~Test()</span></span><br><span class="line">   <span class="keyword">delete</span>[]p2;                                                          <span class="comment">// 14. ~Test() ~Test()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test <span class="title">t5</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;<span class="comment">// 2.Test(int, int)  全局变量优先</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="函数调用中调用了对象的那些方法"><a href="#函数调用中调用了对象的那些方法" class="headerlink" title="函数调用中调用了对象的那些方法"></a>函数调用中调用了对象的那些方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test</span>(<span class="type">int</span> a=<span class="number">10</span>) : <span class="built_in">ma</span>(a)&#123;cout&lt;&lt;<span class="string">&quot;test()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">test</span>()&#123;cout&lt;&lt;<span class="string">&quot;~test()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">test</span>(<span class="type">const</span> test&amp; t) :<span class="built_in">ma</span>(t.ma)&#123;cout&lt;&lt;<span class="string">&quot;const test*&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> test&amp;t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;operator=&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ma = t.ma;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getdata</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ma;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">test <span class="title">GetObjct</span><span class="params">(test t)</span></span></span><br><span class="line"><span class="function"><span class="comment">//传参是对发生拷贝构造</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val = t.<span class="built_in">getdata</span>();</span><br><span class="line">    test tem = <span class="built_in">test</span>(val);</span><br><span class="line">    <span class="comment">//调用构造函数生成临时对象，将临时对象operator=赋值给tem</span></span><br><span class="line">    <span class="keyword">return</span> tem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test t1; <span class="comment">//调用构造函数</span></span><br><span class="line">    test t2; <span class="comment">//调用构造函数</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    t2 = <span class="built_in">GetObjct</span>(t1);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    传参过程 t1 -&gt; t 相当于为t1对象初始化，调用拷贝构造</span></span><br><span class="line"><span class="comment">    test(val) 调用构造函数产生临时对象</span></span><br><span class="line"><span class="comment">    test tem = test(val) 为对象tem初始化调用拷贝构造</span></span><br><span class="line"><span class="comment">    return tem 将tem对象拷贝止main函数的栈帧中生成临时对象调用拷贝构造</span></span><br><span class="line"><span class="comment">    栈帧消失对象依次析构(与构造顺序相反) tem对象析构  t对象析构</span></span><br><span class="line"><span class="comment">    t2 = 返回的临时对象   t2是已经存在，所以这是为t2赋值 调用operator=</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结三条对象优化的规则"><a href="#总结三条对象优化的规则" class="headerlink" title="总结三条对象优化的规则"></a>总结三条对象优化的规则</h2><ol><li>函数参数传递过程中，对象优先按引用传递，不要按值传递(避免了参数传递中的拷贝过程与函数结束后被拷贝对象的析构过程)</li><li>当函数返回对象时，要优先返回一个临时对象，而不是返回一个定义过的对象</li><li>接受返回值是对象的函数调用的时候，应该优先按照初始化的方式接受而不是按照赋值的方式接受</li></ol><p>返回对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">test <span class="title">GetObjct</span><span class="params">(test&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val = t.<span class="built_in">getdata</span>();  </span><br><span class="line">test tem = <span class="built_in">test</span>(val);  <span class="comment">//将一个临时对象拷贝至一个新对象，先构造在拷贝构造</span></span><br><span class="line">    <span class="keyword">return</span> tem;  <span class="comment">//将一个对象拷贝到站外的临时对象 ，发生拷贝构造</span></span><br><span class="line">&#125;<span class="comment">//函数结束后tem对象发生析构</span></span><br></pre></td></tr></table></figure><p>优化为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">test <span class="title">GetObject</span><span class="params">(test &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> val = t.<span class="built_in">getdata</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">test</span>(val);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回一个临时对象到函数栈外用于初始化一个新的对象（也是临时对象）</span></span><br><span class="line"><span class="comment">这句话有没有很熟悉</span></span><br><span class="line"><span class="comment">c++编译器对于对象构造的优化：用于临时对象生成的新对象，临时对象生成的时候，临时对象不产生了，直接构造新对象就可以了</span></span><br><span class="line"><span class="comment">所以这只调用了一次构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接受对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test t1;</span><br><span class="line">    test t2;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    t2 = <span class="built_in">GetObjct</span>(t1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test t1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    test t2 = <span class="built_in">GetObjct</span>(t1);</span><br><span class="line">    <span class="comment">//GetObjct(ti) 返回一个临时对象之后要拷贝规则到拎一个临时对象中</span></span><br><span class="line">    <span class="comment">//而这个临时对象又要用来初始化t2</span></span><br><span class="line">    <span class="comment">//这就导致了只在函数中执行了一次构造函数就为t2完成了赋值操作</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CMystring的代码问题-右值引用"><a href="#CMystring的代码问题-右值引用" class="headerlink" title="CMystring的代码问题   右值引用"></a>CMystring的代码问题   右值引用</h2><p>先来看下原来写的String实现的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mystring</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mystring</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Mystring&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">sizeof</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(ptr, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Mystring</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;~Mystring&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">delete</span>[] ptr;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Mystring</span>(<span class="type">const</span> Mystring&amp; another)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Mystring(const Mystring&amp; another)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(another.ptr)  + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(ptr,another.ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    Mystring&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Mystring&amp;another)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;another)</span><br><span class="line">            <span class="comment">//this 和 &amp;another 是地址值可以比较</span></span><br><span class="line">            <span class="comment">//*this 和 another 是Mystring的对象，这两个比较要重载 == 运算符</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;ptr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(another.ptr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(ptr,another.ptr);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Mystring <span class="title">GetString</span><span class="params">(Mystring&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Mystring</span>(pstr);        <span class="comment">//构造   -&gt;   拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Mystring <span class="title">str1</span><span class="params">(<span class="string">&quot;aaaaaaaaaaaa&quot;</span>)</span></span>;   <span class="comment">//构造</span></span><br><span class="line">    Mystring str2;                       <span class="comment">//构造</span></span><br><span class="line">    str2 = <span class="built_in">GetString</span>(str1);           <span class="comment">//operator=</span></span><br><span class="line">    cout&lt;&lt;str2.<span class="built_in">c_str</span>()&lt;&lt;endl;            </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的拷贝构造和赋值重载是最为浪费资源的函数，因为这里涉及到了字符串的拷贝，要知道在现实中要传递的字符串是非常长的比如<code>json</code> 格式，拷贝并不是最可悲的，而是我费劲的完成了拷贝之后这个对象就用一次之后就消失了</p><p><img src="/img/%E5%8E%9FMystring%E4%B8%AD%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98.png"></p><p>这样不如直接使用临时对象</p><h4 id="右值引用："><a href="#右值引用：" class="headerlink" title="右值引用："></a>右值引用：</h4><p>左值：有名字并且有内存右值：没名字或者没内存(存在寄存器中)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>  a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;c = a;</span><br><span class="line">    <span class="comment">//int &amp;&amp;d = a;                  不能用右值值引用绑定左值</span></span><br><span class="line">    <span class="comment">//int &amp; d = 20;                 不能用左值引用绑定右值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp;d = <span class="number">20</span>;               <span class="comment">//可以使用常引用绑定右值，但是这个内存的值将不可修改</span></span><br><span class="line">    <span class="comment">/*相当于先生成一个临时量赋值为20 int tem = 20   tem是一个临时对象</span></span><br><span class="line"><span class="comment">     * const int&amp;d = tem;   在对这个临时量进行引用</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; e = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">/*相当于：先生成一个临时量赋值为20 int tem = 20   tem是一个临时对象</span></span><br><span class="line"><span class="comment">    * const int&amp;d = tem;   在对这个临时量进行引用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//int &amp;&amp;e = 40;  //右值引用同样不可以修改引用的对象</span></span><br><span class="line">    e = <span class="number">30</span>;          <span class="comment">//右值引用可以修改指向内存的值</span></span><br><span class="line">    <span class="comment">/*int &amp;&amp;f = e;</span></span><br><span class="line"><span class="comment">    报错：&#x27;int&#x27;类型的右值引用不能绑定到&#x27;int&#x27;类型的左值</span></span><br><span class="line"><span class="comment">     总结：右值引用变量本身是一个左值 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重点：一个右值引用变量本身是左值，因为这个右值引用变量有内存有名字</strong></p><h4 id="对Mystring进行优化"><a href="#对Mystring进行优化" class="headerlink" title="对Mystring进行优化"></a>对Mystring进行优化</h4><p>提供接受临时变量的拷贝构造和赋值重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Mystring&amp; <span class="keyword">operator</span>=(Mystring&amp;&amp;another)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Mystring&amp; operator=(const Mystring&amp;&amp;another)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ptr = another.ptr;</span><br><span class="line">        another.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">Mystring</span>(Mystring&amp;&amp; another)        <span class="comment">//带右值引用参数的拷贝构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Mystring(Mystring&amp;&amp; another) &quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ptr = another.ptr;       <span class="comment">//将临时对象所托管的内存变为this对象所托管的内存</span></span><br><span class="line">        another.ptr = <span class="literal">nullptr</span>;         <span class="comment">//这是必要的，因为临时对象在执行完这之后要析构，若不制空则会将已转移的资源free掉，最终会导致double free</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>将临时对象的资源移动到当前对象下，避免了数据的拷贝(与没有提供右值引用的方法相比)。右值引用提高了效率</p><h2 id="Mystring在operator-的优化"><a href="#Mystring在operator-的优化" class="headerlink" title="Mystring在operator+的优化"></a>Mystring在operator+的优化</h2><p>回顾下我们在之前写的 Mystring 中设计的字符串拼接问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Mystring</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Mystring&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">sizeof</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(ptr, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Mystring <span class="keyword">operator</span>+(<span class="type">const</span> Mystring&amp; lptr,<span class="type">const</span> Mystring&amp;hptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* tem = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(lptr.ptr) + <span class="built_in">strlen</span>(hptr.ptr) + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//tem是函数开辟栈中的一个变量，它指向一块用于字符串连接的内存</span></span><br><span class="line">    <span class="built_in">strcpy</span>(tem , lptr.ptr);</span><br><span class="line">    <span class="built_in">strcat</span>(tem , hptr.ptr);</span><br><span class="line">    <span class="comment">//在tem指向的内存中完成了字符串的拼接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Mystring</span>(tem);</span><br><span class="line">    <span class="comment">//调用Mystring的构造函数，将tem中的内容拷贝至临时对象Mystring中</span></span><br><span class="line">    <span class="comment">//之后栈消失，tem变量不复存在，但是tem指向的内存还存在，这样就导致了内存泄露</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写是肯定有问题的。这里 tem 指向的内存将没有释放的机会</p><p>解决方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Mystring <span class="keyword">operator</span>+(<span class="type">const</span> Mystring&amp; lptr,<span class="type">const</span> Mystring&amp;hptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* tem = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(lptr.ptr) + <span class="built_in">strlen</span>(hptr.ptr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tem , lptr.ptr);</span><br><span class="line">    <span class="built_in">strcat</span>(tem , hptr.ptr);</span><br><span class="line">    <span class="comment">//第一次内存的拷贝</span></span><br><span class="line">    Mystring t = <span class="built_in">Mystring</span>(tem);</span><br><span class="line">    <span class="comment">//第二次内存的拷贝</span></span><br><span class="line">    <span class="keyword">delete</span>[] tem;</span><br><span class="line">    <span class="keyword">return</span> t;  <span class="comment">//返回对象而不是临时对象，在生成临时对象的时候会有一次拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然解决了，但是效率有点太低了</p><p>优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Mystring <span class="keyword">operator</span>+(<span class="type">const</span> Mystring&amp; lptr,<span class="type">const</span> Mystring&amp;hptr)</span><br><span class="line">&#123;</span><br><span class="line">    Mystring t;  <span class="comment">//生成一个对象直接对对象进行操作</span></span><br><span class="line">    t.ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(lptr.ptr) + <span class="built_in">strlen</span>(hptr.ptr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(t.ptr,lptr.ptr);</span><br><span class="line">    <span class="built_in">strcat</span>(t.ptr,hptr.ptr);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mystring中vector的应用"><a href="#Mystring中vector的应用" class="headerlink" title="Mystring中vector的应用"></a>Mystring中vector的应用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Mystring&gt; vm;</span><br><span class="line">    vm.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line">    Mystring str1 = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;---------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    vm.<span class="built_in">push_back</span>(str1);</span><br><span class="line"></span><br><span class="line">    vm.<span class="built_in">push_back</span>(<span class="built_in">Mystring</span>(<span class="string">&quot;bbb&quot;</span>));</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Mystring</span><br><span class="line">---------------------</span><br><span class="line"><span class="built_in">Mystring</span>(<span class="type">const</span> Mystring&amp; another)      <span class="comment">//调用拷贝构造</span></span><br><span class="line"><span class="function">Mystring</span></span><br><span class="line"><span class="function"><span class="title">Mystring</span><span class="params">(Mystring&amp;&amp; another)</span>           <span class="comment">//调用临时对象的拷贝构造</span></span></span><br><span class="line"><span class="function">~Mystring</span></span><br><span class="line"><span class="function">------------------------</span></span><br><span class="line"><span class="function">~Mystring</span></span><br><span class="line"><span class="function">~Mystring</span></span><br><span class="line"><span class="function">~Mystring</span></span><br></pre></td></tr></table></figure><p>那么push_back的底层是如何实现的呢？</p><h2 id="move移动语义和forword类型的完美转发"><a href="#move移动语义和forword类型的完美转发" class="headerlink" title="move移动语义和forword类型的完美转发"></a>move移动语义和forword类型的完美转发</h2><p>move模板的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    _GLIBCXX_NODISCARD</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function">    <span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br></pre></td></tr></table></figure><p>可以看到是将传入的变量强转为右值引用变量</p><h4 id="实现vector与Mystring的结合："><a href="#实现vector与Mystring的结合：" class="headerlink" title="实现vector与Mystring的结合："></a>实现vector与Mystring的结合：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mystring</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mystring</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Mystring&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">sizeof</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(ptr, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Mystring</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;~Mystring&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">delete</span>[] ptr;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Mystring</span>(<span class="type">const</span> Mystring&amp; another)    <span class="comment">//带左值引用参数的拷贝构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Mystring(const Mystring&amp; another)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(another.ptr)  + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(ptr,another.ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Mystring</span>(Mystring&amp;&amp; another)        <span class="comment">//带右值引用参数的拷贝构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Mystring(Mystring&amp;&amp; another) &quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ptr = another.ptr;       <span class="comment">//将临时对象所托管的内存变为this对象所托管的内存</span></span><br><span class="line">        another.ptr = <span class="literal">nullptr</span>;         <span class="comment">//这是必要的，因为临时对象在执行完这之后要析构，若不制空则会将已转移的资源free掉，最终会导致double free</span></span><br><span class="line">    &#125;</span><br><span class="line">    Mystring&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Mystring&amp;another)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Mystring&amp; operator=(const Mystring&amp;another)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;another)</span><br><span class="line">            <span class="comment">//this 和 &amp;another 是地址值可以比较</span></span><br><span class="line">            <span class="comment">//*this 和 another 是Mystring的对象，这两个比较要重载 == 运算符</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;ptr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(another.ptr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(ptr,another.ptr);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Mystring&amp; <span class="keyword">operator</span>=(Mystring&amp;&amp;another)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Mystring&amp; operator=(const Mystring&amp;&amp;another)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ptr = another.ptr;</span><br><span class="line">        another.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Mystring <span class="keyword">operator</span>+(<span class="type">const</span> Mystring&amp; lptr,<span class="type">const</span> Mystring&amp;hptr);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,Mystring &amp; another);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Allocator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> size)</span>  <span class="comment">//负责内存开辟</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T*) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T) * size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p)</span>  <span class="comment">//负责内存释放</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(T*p,<span class="type">const</span> T&amp;val)</span>  <span class="comment">//负责对象构造</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span>(p) <span class="built_in">T</span>(val);  <span class="comment">//定位new，在p的内存上调用拷贝构造</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(T*p,T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span>(p) <span class="built_in">T</span>(std::<span class="built_in">move</span>(val));</span><br><span class="line">        <span class="comment">//右值引用变量本身是左值，这里使用move移动语义构造返回一个临时对象</span></span><br><span class="line">        <span class="comment">//用于调用T()构造函数的参数为临时对象的重载函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(T* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt;(<span class="type">int</span> size = <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        first_ = allocator_.<span class="built_in">allocate</span>(size);</span><br><span class="line">        last_  = first_;</span><br><span class="line">        end_ = first_ + size + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">vector</span>&lt;T&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(T* p=first_;p!=last_;p++)</span><br><span class="line">        &#123;</span><br><span class="line">            allocator_.<span class="built_in">destroy</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        allocator_.<span class="built_in">deallocate</span>(first_);</span><br><span class="line">        first_ = last_ = end_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt;(<span class="type">const</span> vector&lt;T&gt;&amp;another)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len = another.last_ - another.first_;</span><br><span class="line">        <span class="comment">//len是有效元素的长度</span></span><br><span class="line">        first_ = allocator_.<span class="built_in">allocate</span>(len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            allocator_.<span class="built_in">construct</span>(first_+i,another.first_[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        last_ = first_ = len;</span><br><span class="line">        end_ = first_ + (end_ - first_);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&amp;<span class="keyword">operator</span>=(<span class="type">const</span> vector&lt;T&gt;&amp;another)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;another)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(T* p=first_;p!=last_;p++)</span><br><span class="line">        &#123;</span><br><span class="line">            allocator_.<span class="built_in">destroy</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        allocator_.<span class="built_in">deallocate</span>(first_);</span><br><span class="line">        <span class="type">int</span> len = another.last_ - another.first_;</span><br><span class="line">        <span class="comment">//len是有效元素的长度</span></span><br><span class="line">        first_ = allocator_.<span class="built_in">allocate</span>(len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            allocator_.<span class="built_in">construct</span>(first_+i,(another.first_)[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        last_ = first_ = len;</span><br><span class="line">        end_ = first_ + (end_ - first_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(last_ == end_)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">full</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;vector is empty&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            allocator_.<span class="built_in">destroy</span>(--last_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span>  <span class="comment">//返回容器末尾的元素值</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(last_<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">full</span>())</span><br><span class="line">            <span class="built_in">expand</span>();</span><br><span class="line">        allocator_.<span class="built_in">construct</span>(last_,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">full</span>())</span><br><span class="line">            <span class="built_in">expand</span>();</span><br><span class="line">        allocator_.<span class="built_in">construct</span>(last_,std::<span class="built_in">move</span>(val));</span><br><span class="line">        <span class="comment">//右值引用本身是一个左值变量，使用std::move()返回一个右值引用变量，</span></span><br><span class="line">        <span class="comment">// 这里用于调用allocator_.construct()函数的右值引用函数重载</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* first_;  <span class="comment">//指向有效元素的第一个</span></span><br><span class="line">    T* last_;   <span class="comment">//指向最后一个有效元素的后继位置</span></span><br><span class="line">    T* end_;    <span class="comment">//指向数组空间的后继位置</span></span><br><span class="line">    Allocator&lt;T&gt; allocator_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = end_ - first_;</span><br><span class="line">        T* tem = allocator_.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//            tem[i] = first_[i];</span></span><br><span class="line">            allocator_.<span class="built_in">construct</span>(tem+i, first_[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            allocator_.<span class="built_in">destroy</span>(first_ + i);</span><br><span class="line">        &#125;</span><br><span class="line">        allocator_.<span class="built_in">deallocate</span>(first_);</span><br><span class="line">        first_ = tem;</span><br><span class="line">        last_ = first_ + size;</span><br><span class="line">        end_ = first_ + size * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mystring <span class="keyword">operator</span>+(<span class="type">const</span> Mystring&amp; lptr,<span class="type">const</span> Mystring&amp;hptr)</span><br><span class="line">&#123;</span><br><span class="line">    Mystring t;</span><br><span class="line">    t.ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(lptr.ptr) + <span class="built_in">strlen</span>(hptr.ptr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(t.ptr,lptr.ptr);</span><br><span class="line">    <span class="built_in">strcat</span>(t.ptr,hptr.ptr);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,Mystring &amp; another)</span><br><span class="line">&#123;</span><br><span class="line">    out&lt;&lt;another.ptr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mystring <span class="title">GetString</span><span class="params">(Mystring&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Mystring</span>(pstr);        <span class="comment">//构造   -&gt;   拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Mystring&gt; vm;</span><br><span class="line">    Mystring str1 = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;---------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    vm.<span class="built_in">push_back</span>(str1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;---------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    vm.<span class="built_in">push_back</span>(<span class="built_in">Mystring</span>(<span class="string">&quot;bbb&quot;</span>));</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的办法有些麻烦。主要是在传递参数的时候要将左值类型通过std::move转化为右值。为了解决之一问题有了<strong>引用折叠</strong></p><p>将push_bask用函数模板替代：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_bash</span><span class="params">(Ty&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">full</span>())</span><br><span class="line">        <span class="built_in">expand</span>();</span><br><span class="line">    allocator_.<span class="built_in">construct</span>(last_,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>push_bash(Mystring(“abc”));   模板会进行实参推演，将Ty自动替换为 Mystring&amp;&amp;  这样函数就变为void push_bash(Mystring&amp;&amp; &amp;&amp; val) 根据引用折叠这等价于void push_bash(Mystring&amp;&amp; val)</p><p>Mystring s1(“abcd”);<br>push_back(s1);       模板会进行实参推演，将Ty自动替换为 Mystring&amp;  这样函数就变为了void push_bash(Mystring &amp; &amp;&amp; val) 根据引用折叠这等价于void push_bash(Mystring&amp; val)</p><p>但是，模板中调用了<code>allocator_.construct(last_,val)</code> 函数,右值引用变量其实是一个左值变量，使用allocator_.construct(last_,val);函数调用的是左值引用的重载函数。这与我们想要的结果不同，我们希望的是，当传入左值引用变量的时候allocator_.construct(last_,val);函数调用的是左值引用重载的函数，当传入右值引用参数的时候调用右值引用参数的重载函数</p><h4 id="这就引出了，forward-的类型完美转发"><a href="#这就引出了，forward-的类型完美转发" class="headerlink" title="这就引出了，forward 的类型完美转发"></a>这就引出了，forward 的类型完美转发</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(T*p,Ty &amp;&amp;val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">new</span>(p) <span class="built_in">T</span>(std::forward&lt;Ty&gt;(val));</span><br><span class="line">    <span class="comment">//Ty可能是一个左值也可能是一个右值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(Ty&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">full</span>())</span><br><span class="line">        <span class="built_in">expand</span>();</span><br><span class="line">    allocator_.<span class="built_in">construct</span>(last_,std::forward&lt;Ty&gt;(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forward类型完美转发，可以识别变量本身是左值还是右值，若本身是左值就返回一个左值引用，若本身是右值变量就返回一个右值引用move移动语义，得到右值类型</p><p><strong>最终代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;typeinfo&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __glibcxx_assertaa</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test</span>(<span class="type">int</span> a=<span class="number">10</span>) : <span class="built_in">ma</span>(a)&#123;cout&lt;&lt;<span class="string">&quot;test()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">test</span>()&#123;cout&lt;&lt;<span class="string">&quot;~test()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">test</span>(<span class="type">const</span> test&amp; t) :<span class="built_in">ma</span>(t.ma)&#123;cout&lt;&lt;<span class="string">&quot;const test*&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> test&amp;t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;operator=&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ma = t.ma;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getdata</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ma;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">test <span class="title">GetObjct</span><span class="params">(test&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val = t.<span class="built_in">getdata</span>();</span><br><span class="line">    test tem = <span class="built_in">test</span>(val);</span><br><span class="line">    <span class="comment">//调用构造函数生成临时对象，将临时对象operator=赋值给tem</span></span><br><span class="line">    <span class="keyword">return</span> tem;</span><br><span class="line">    <span class="comment">//return test(val);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test t1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    test t2 = <span class="built_in">GetObjct</span>(t1);   <span class="comment">//用临时对象为唯一个新对象初始化</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mystring</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mystring</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Mystring&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">sizeof</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(ptr, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Mystring</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;~Mystring&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">delete</span>[] ptr;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Mystring</span>(<span class="type">const</span> Mystring&amp; another)    <span class="comment">//带左值引用参数的拷贝构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Mystring(const Mystring&amp; another)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(another.ptr)  + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(ptr,another.ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Mystring</span>(Mystring&amp;&amp; another)        <span class="comment">//带右值引用参数的拷贝构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Mystring(Mystring&amp;&amp; another) &quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ptr = another.ptr;       <span class="comment">//将临时对象所托管的内存变为this对象所托管的内存</span></span><br><span class="line">        another.ptr = <span class="literal">nullptr</span>;         <span class="comment">//这是必要的，因为临时对象在执行完这之后要析构，若不制空则会将已转移的资源free掉，最终会导致double free</span></span><br><span class="line">    &#125;</span><br><span class="line">    Mystring&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Mystring&amp;another)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Mystring&amp; operator=(const Mystring&amp;another)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;another)</span><br><span class="line">            <span class="comment">//this 和 &amp;another 是地址值可以比较</span></span><br><span class="line">            <span class="comment">//*this 和 another 是Mystring的对象，这两个比较要重载 == 运算符</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;ptr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(another.ptr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(ptr,another.ptr);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Mystring&amp; <span class="keyword">operator</span>=(Mystring&amp;&amp;another)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Mystring&amp; operator=(const Mystring&amp;&amp;another)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ptr = another.ptr;</span><br><span class="line">        another.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Mystring <span class="keyword">operator</span>+(<span class="type">const</span> Mystring&amp; lptr,<span class="type">const</span> Mystring&amp;hptr);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,Mystring &amp; another);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Allocator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> size)</span>  <span class="comment">//负责内存开辟</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T*) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T) * size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p)</span>  <span class="comment">//负责内存释放</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">construct</span><span class="params">(T*p,Ty &amp;&amp;val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span>(p) <span class="built_in">T</span>(std::forward&lt;Ty&gt;(val));</span><br><span class="line">        <span class="comment">//Ty可能是一个左值也可能是一个右值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*void construct(T*p,const T&amp;val)  //负责对象构造</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        new(p) T(val);  //定位new，在p的内存上调用拷贝构造</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    void construct(T*p,T&amp;&amp; val)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        new(p) T(std::move(val));</span></span><br><span class="line"><span class="comment">        //右值引用变量本身是左值，这里使用move移动语义构造返回一个临时对象</span></span><br><span class="line"><span class="comment">        //用于调用T()构造函数的参数为临时对象的重载函数</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(T* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt;(<span class="type">int</span> size = <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        first_ = allocator_.<span class="built_in">allocate</span>(size);</span><br><span class="line">        last_  = first_;</span><br><span class="line">        end_ = first_ + size + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">vector</span>&lt;T&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(T* p=first_;p!=last_;p++)</span><br><span class="line">        &#123;</span><br><span class="line">            allocator_.<span class="built_in">destroy</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        allocator_.<span class="built_in">deallocate</span>(first_);</span><br><span class="line">        first_ = last_ = end_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt;(<span class="type">const</span> vector&lt;T&gt;&amp;another)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len = another.last_ - another.first_;</span><br><span class="line">        <span class="comment">//len是有效元素的长度</span></span><br><span class="line">        first_ = allocator_.<span class="built_in">allocate</span>(len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            allocator_.<span class="keyword">template</span> <span class="built_in">construct</span>&lt;Mystring&gt;(first_+i,another.first_[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        last_ = first_ = len;</span><br><span class="line">        end_ = first_ + (end_ - first_);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&amp;<span class="keyword">operator</span>=(<span class="type">const</span> vector&lt;T&gt;&amp;another)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;another)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(T* p=first_;p!=last_;p++)</span><br><span class="line">        &#123;</span><br><span class="line">            allocator_.<span class="built_in">destroy</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        allocator_.<span class="built_in">deallocate</span>(first_);</span><br><span class="line">        <span class="type">int</span> len = another.last_ - another.first_;</span><br><span class="line">        <span class="comment">//len是有效元素的长度</span></span><br><span class="line">        first_ = allocator_.<span class="built_in">allocate</span>(len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            allocator_.<span class="built_in">construct</span>(first_+i,(another.first_)[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        last_ = first_ = len;</span><br><span class="line">        end_ = first_ + (end_ - first_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(last_ == end_)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">full</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;vector is empty&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            allocator_.<span class="built_in">destroy</span>(--last_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span>  <span class="comment">//返回容器末尾的元素值</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(last_<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">push_back</span><span class="params">(Ty&amp;&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">full</span>())</span><br><span class="line">            <span class="built_in">expand</span>();</span><br><span class="line">        allocator_. <span class="built_in">construct</span>(last_,std::forward&lt;Ty&gt;(val));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* first_;  <span class="comment">//指向有效元素的第一个</span></span><br><span class="line">    T* last_;   <span class="comment">//指向最后一个有效元素的后继位置</span></span><br><span class="line">    T* end_;    <span class="comment">//指向数组空间的后继位置</span></span><br><span class="line">    Allocator&lt;T&gt; allocator_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = end_ - first_;</span><br><span class="line">        T* tem = allocator_.<span class="built_in">allocate</span>(size * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//            tem[i] = first_[i];</span></span><br><span class="line">            allocator_.<span class="built_in">construct</span>(tem+i, first_[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            allocator_.<span class="built_in">destroy</span>(first_ + i);</span><br><span class="line">        &#125;</span><br><span class="line">        allocator_.<span class="built_in">deallocate</span>(first_);</span><br><span class="line">        first_ = tem;</span><br><span class="line">        last_ = first_ + size;</span><br><span class="line">        end_ = first_ + size * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Mystring <span class="keyword">operator</span>+(<span class="type">const</span> Mystring&amp; lptr,<span class="type">const</span> Mystring&amp;hptr)</span><br><span class="line">&#123;</span><br><span class="line">    Mystring t;</span><br><span class="line">    t.ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(lptr.ptr) + <span class="built_in">strlen</span>(hptr.ptr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(t.ptr,lptr.ptr);</span><br><span class="line">    <span class="built_in">strcat</span>(t.ptr,hptr.ptr);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,Mystring &amp; another)</span><br><span class="line">&#123;</span><br><span class="line">    out&lt;&lt;another.ptr;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mystring <span class="title">GetString</span><span class="params">(Mystring&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Mystring</span>(pstr);        <span class="comment">//构造   -&gt;   拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Mystring&gt; vm;</span><br><span class="line">    Mystring str1 = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;---------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    vm.<span class="built_in">push_back</span>(str1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;---------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    vm.<span class="built_in">push_back</span>(<span class="built_in">Mystring</span>(<span class="string">&quot;bbb&quot;</span>));</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++ 学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
