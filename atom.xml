<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boolsatellite</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-23T13:58:45.998Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>boolsatellite</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Oprating-system Structrues</title>
    <link href="http://example.com/2024/10/23/1.operating-System-Structures/"/>
    <id>http://example.com/2024/10/23/1.operating-System-Structures/</id>
    <published>2024-10-23T13:58:45.998Z</published>
    <updated>2024-10-23T13:58:45.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h1><h2 id="操作系统为用户提供的服务："><a href="#操作系统为用户提供的服务：" class="headerlink" title="操作系统为用户提供的服务："></a>操作系统为用户提供的服务：</h2><p><img src="/img/oprating_system/Snipaste_2023-05-07_13-10-40.png"></p><p>User interfaces：为用户提供的接口中包含了 (对于普通用户)</p><blockquote><p>GUI(图形化接口)</p><p>batch(批处理)</p><p>command line(命令行)</p></blockquote><p>system calls：系统调用(面向程序员或应用程序提供的接口)</p><blockquote><p>program execution(程序的执行)</p><p>I&#x2F;O operations(输入输出的操作)</p><p>file system(以文件的方式保存在磁盘上 常见的有 NTFS  Exf4)</p><p>communication(通信，主要指进程间通信，提供程序之间的相互对话，传递一些数据)</p><p>resource allocation(资源分配，主要指，分配硬件资源)</p><p>accounting(记账，用于记录某个程序的如使用时间等信息)</p><p>error detection(错误检查)</p><p>protection and security(提供保护和安全性)</p></blockquote><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>纠正了以前的误区(系统调用并不是API，API中访问了系统调用)</p><ul><li>系统调用提供了访问和使用操作系统所提供的服务的接口。<ul><li>系统调用的实现代码是操作系统级的</li><li>这个接口通常是面向程序员的</li></ul></li><li>API (Application Programming Interface)：指明了参数和返回值的一组函数。<ul><li>应用程序App的开发人员通过透过API间接访问了系统调用</li><li>Windows API &#x2F; POSIX API &#x2F; JAVA API</li></ul></li></ul><h2 id="双重模式"><a href="#双重模式" class="headerlink" title="双重模式"></a>双重模式</h2><ul><li>现代计算机系统有一个特殊的硬件，用于划分系统 的运行状态，至少需要两种单独运行模式：<ul><li>用户模式（user mode）：执行用户代码</li><li>内核模式（kernel mode）：执行操作系统代码</li></ul></li><li>目的：确保操作系统正确的运行</li><li>实现方式<ul><li>用一个硬件模式位来表示当前模式：0表示内核模式，1 表示用户模式。</li></ul></li></ul><p>区分用户模式和内核模式，因为有一些非常重要的指令如(定时器的设置，错误的捕捉，等特权指令)，这些指令不系统被用户随意执行(安全性)，所以这些指令只能运行由操作系统运行，故就引出了内核模式</p><h2 id="运行模式的切换"><a href="#运行模式的切换" class="headerlink" title="运行模式的切换"></a>运行模式的切换</h2><p>系统调用需要在哪种模式下执行？</p><blockquote><p>系统调用的实现是操作系统级别的提供了访问和使用操作系统所提供的服务的接口，所以系统调用运行在内核模式下</p></blockquote><p>你的应用程序运行在哪种模式下？</p><blockquote><p>运行在用户模式下</p></blockquote><p>调用API函数printf时，运行模式如何切换？</p><blockquote><p>从用户态陷入内核态，执行系统调用后返回用户态</p></blockquote><p>如图：</p><p><img src="/img/oprating_system/Snipaste_2023-05-07_14-05-04.png"></p><h2 id="系统调用的实现机制"><a href="#系统调用的实现机制" class="headerlink" title="系统调用的实现机制"></a>系统调用的实现机制</h2><ul><li>每个系统调用都有一个唯一的数字编号，被称为系统调用号。</li><li>用户代码调用API时，API中会向系统调用接口指明其所要用的系统调用号，操作系统内核中维护了一张索引表，依据这个调用号可以检索到访系统调用代码在内核中的位置。</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-07_14-08-12.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统结构&quot;&gt;&lt;a href=&quot;#操作系统结构&quot; class=&quot;headerlink&quot; title=&quot;操作系统结构&quot;&gt;&lt;/a&gt;操作系统结构&lt;/h1&gt;&lt;h2 id=&quot;操作系统为用户提供的服务：&quot;&gt;&lt;a href=&quot;#操作系统为用户提供的服务：&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="oprating system" scheme="http://example.com/tags/oprating-system/"/>
    
  </entry>
  
  <entry>
    <title>deadlocks(死锁)</title>
    <link href="http://example.com/2024/10/23/10.deadlock/"/>
    <id>http://example.com/2024/10/23/10.deadlock/</id>
    <published>2024-10-23T13:58:45.998Z</published>
    <updated>2024-10-23T13:58:45.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DeadLocks"><a href="#DeadLocks" class="headerlink" title="DeadLocks"></a>DeadLocks</h1><h2 id="死锁的特征"><a href="#死锁的特征" class="headerlink" title="死锁的特征"></a>死锁的特征</h2><h3 id="哲学家用餐死锁问题"><a href="#哲学家用餐死锁问题" class="headerlink" title="哲学家用餐死锁问题"></a>哲学家用餐死锁问题</h3><ul><li>当所有人同时拿到一侧的筷子时，发生永远等待现象 （即死锁）。</li><li>有若种办法可避免死锁：<ul><li>至多允许四个哲学家同时吃；</li><li>奇数号先取左手边的筷子，偶数号先取右手边的筷子； </li><li>每个哲学家取到手边的两根筷子才吃，否则一根也不取。</li></ul></li><li>进程访问资源流程：申请 ➠ 使用 ➠ 释放</li></ul><h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><ul><li>In a multiprogramming environment, several(若干) processes  may compete for a finite(有限) number of resources.</li><li>A process requests(请求) resources; if the resources are not  available(可用的) at that time, the process enters a waiting state.</li><li>Sometimes, a waiting process is never again able to  change state, because the resources it has requested are  held(占有) by other waiting processes.</li><li>This situation is called a deadlock</li></ul><h3 id="死锁与饥饿"><a href="#死锁与饥饿" class="headerlink" title="死锁与饥饿"></a>死锁与饥饿</h3><ul><li>饥饿：进程长时间的等待<ul><li>e.g.低优先级进程总是等待高优先级所占有的进程</li></ul></li><li>死锁：循环等待资源<br><img src="/img/oprating_system/Snipaste_2023-05-11_21-56-06.png"></li></ul><h3 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h3><ul><li>互斥使用： 一个时刻，一个资源仅能被一个进程占有</li><li>不可剥夺： 除了资源占有进程主动释放资源，其它进程都不可抢夺其资源</li><li>占有和等待 ：一个进程请求资源得不到满足等待时，不释放已占有资源</li><li>循环等待(上面三个条件同时存在产生的结果)：  每一个进程分别等待它前一个进程所占有的资源</li></ul><h3 id="死锁的解决方案"><a href="#死锁的解决方案" class="headerlink" title="死锁的解决方案"></a>死锁的解决方案</h3><ul><li>死锁的防止 (Prevention)<ul><li>破坏四个必要条件之一</li></ul></li><li>死锁的避免 (Avoidance)<ul><li>允许四个必要条件同时存在，在并发进程中做出妥善安 排避免死锁的发生，使用安全算法</li></ul></li><li>死锁的检测和恢复 (Detection &amp; Recovery)<ul><li>允许死锁的发生，系统及时地检测死锁并解除它</li></ul></li></ul><h2 id="死锁的防止"><a href="#死锁的防止" class="headerlink" title="死锁的防止"></a>死锁的防止</h2><ul><li>互斥使用：破坏这个意味者，要使资源共享使用，不是所有的资源都是可以共享使用的，如打印机同时只允许一个人使用，故：这明显是不可行的</li><li>不可剥夺：破坏这个条件意味着，资源可以被抢夺，我们只知道CPU可以被抢夺，若共享资源是打印机呢，抢夺打印机明显是不可行的，故：不可行</li><li>占有和等待：破坏这个条件意味这，一次性拿到进程所需的所有资源，若A进程需要disk CPU 打印机 ， 当A进程要执行时，他的全部资源就已经被获取了，但是导致了资源的严重浪费，因为A进程可能要在执行的最后才使用打印机，但是A在执行的开始就已经将其占用了，这造成了资源浪费，这是可以的但是效果不太好</li><li>循环等待：<br>破坏这个条件可以的方法：由程序员自行为资源排序可以将其抽象成一个数组，将资源以一定顺序放入数组中（一般按照优先级顺序）R &#x3D; {R1,R2,R3,R4}，当要申请一个资源时必须使得全部资源都满足才可申请（当要申请R3时，R1 ，R2资源均要获取），这样解决了循环等待问题，但是这样也存在资源的浪费（当申请R3时，R1与R2可能并不是必要的）而且可操作性差，故可行但是效果不好</li></ul><h2 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h2><h3 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h3><ul><li>A state is safe if the system can allocate resources to  each process (up to its maximum) in some order and  still avoid a deadlock. More formally(正式的), a system is in a  safe state only if there exists a safe sequence(序列).</li><li>If no such sequence exists, then the system state is  said to be unsafe.</li><li>A safe state is NOT a deadlocked state.</li><li>An unsafe state MAY lead to a deadlock.</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-12_09-48-50.png"></p><h3 id="死锁的避免-1"><a href="#死锁的避免-1" class="headerlink" title="死锁的避免"></a>死锁的避免</h3><ul><li>系统对进程的每一次资源申请都进行详细的计算， 根据结果决定是分配资源还是让其等待，确保系统 始终处于安全状态，避免死锁的发生。</li><li>银行家算法（Banker’s algorithm）<ul><li>已知系统中所有资源的种类和数量</li><li>已知进程所需要的各类资源最大需求量</li><li>该算法可以计算出当前的系统状态是否安全(寻找安全序列)</li></ul></li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-12_10-09-27.png"></p><p>存在安全序列{ P1,P3,P4,P2,P0 }，系统处于安全状态。</p><p>银行家算法就是寻找一个安全分资源的序列使得，避免死锁的发生</p><ul><li>优点：允许死锁必要条件同时存在</li><li>缺点：缺乏实用价值<ul><li>进程运行前就要求知道其所需资源的最大数量</li><li>要求进程是无关(独立)的，因为分配资源的安全顺序是固定的，若考虑同步情况，可能会打乱安全序列</li><li>要求进入系统的进程个数和资源数固定（这不太现实）</li></ul></li></ul><h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><h3 id="死锁的检测与恢复"><a href="#死锁的检测与恢复" class="headerlink" title="死锁的检测与恢复"></a>死锁的检测与恢复</h3><ul><li>允许死锁发生，操作系统不断监视系统进展情况， 判断死锁是否发生</li><li>一旦死锁发生则采取专门的措施，解除死锁并以最 小的代价恢复操作系统运行</li><li>死锁检测的时机<ul><li>当很多进程等待时检测死锁（系统开销大，资源被分配却没有归还）</li><li>定时检测</li><li>系统资源利用率下降时检测死锁</li></ul></li></ul><h3 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h3><p>方框表示一类资源，里面的黑点表示该类资源的个数<br>原型表示进程<br>由进程指向资源表示进程申请资源<br>由资源指向进程表示系统分配资源给欸进程</p><h3 id="资源分配图示例："><a href="#资源分配图示例：" class="headerlink" title="资源分配图示例："></a>资源分配图示例：</h3><p><img src="/img/oprating_system/Snipaste_2023-05-12_10-29-30.png"></p><p>死锁发生在申请边</p><p>图一：p1申请R1将会等待，P2申请R2将会等待，P3没有申请资源。故P3将会执行完会归还资源R2 R4，这样P2就可执行，P2执行完归还R1,P1即可正常运行</p><p>图二：P1申请R1将等待，P2申请R2将等待，P3申请R3将等待，3个进程无一可以执行故死锁</p><p>图三：P1申请R1将等待，P2不申请资源，P3申请R2，P2完成后归还R1，P4完成后归还R2，可以正常运行</p><h3 id="死锁的解除-recovery"><a href="#死锁的解除-recovery" class="headerlink" title="死锁的解除(recovery)"></a>死锁的解除(recovery)</h3><ul><li>中止进程，强制回收资源（如我们的windows中，一个进程可能会弹出对话框说进程长时间无响应，询问是否等待还是结束进程，这可能是改进程发生了死锁现象，这里使用可能是因为操作系统只检测了进程在等待队列的时长）</li><li>剥夺资源，但不中止进程 </li><li>进程回退(roll back)</li><li>重新启动</li></ul><p>参考：<a href="https://www.bilibili.com/video/BV1bf4y147PZ">https://www.bilibili.com/video/BV1bf4y147PZ</a></p><p>光看视频而不看书是远远不够的，但是由于考试在及，没有过多的时间，暑假立flag：</p><ul><li>让自己擅长汇编语言</li><li>操作系统真象还原</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DeadLocks&quot;&gt;&lt;a href=&quot;#DeadLocks&quot; class=&quot;headerlink&quot; title=&quot;DeadLocks&quot;&gt;&lt;/a&gt;DeadLocks&lt;/h1&gt;&lt;h2 id=&quot;死锁的特征&quot;&gt;&lt;a href=&quot;#死锁的特征&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="oprating system" scheme="http://example.com/tags/oprating-system/"/>
    
  </entry>
  
  <entry>
    <title>Memory management</title>
    <link href="http://example.com/2024/10/23/11.Memory%20managemnet/"/>
    <id>http://example.com/2024/10/23/11.Memory%20managemnet/</id>
    <published>2024-10-23T13:58:45.998Z</published>
    <updated>2024-10-23T13:58:45.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Memory-management"><a href="#Memory-management" class="headerlink" title="Memory management"></a>Memory management</h1><p>cat &#x2F;proc&#x2F;pid&#x2F;maps # 查看当前进程的各段的内存加载信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">:~<span class="variable">$sudo</span> <span class="built_in">cat</span> /proc/7/maps</span></span><br><span class="line">[sudo] password for yixuan_zhang:</span><br><span class="line">00200000-0025a000 r--p 00000000 00:16 562949953668040                    /init</span><br><span class="line">0025a000-0034f000 r-xp 00059000 00:16 562949953668040                    /init</span><br><span class="line">0034f000-00361000 rw-p 0014d000 00:16 562949953668040                    /init</span><br><span class="line">00361000-00363000 rw-p 0015e000 00:16 562949953668040                    /init</span><br><span class="line">00363000-0036a000 rw-p 00000000 00:00 0</span><br><span class="line">020b0000-020b7000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">020b7000-020b9000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7efc18300000-7efc18301000 ---p 00000000 00:00 0</span><br><span class="line">7efc18301000-7efc18316000 rw-p 00000000 00:00 0</span><br><span class="line">7efc18316000-7efc18317000 ---p 00000000 00:00 0</span><br><span class="line">7efc18317000-7efc1832c000 rw-p 00000000 00:00 0</span><br><span class="line">7ffed4d66000-7ffed4d87000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7ffed4dd8000-7ffed4ddc000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffed4ddc000-7ffed4ddd000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">起始位置     终止位置     权限 偏移量 主设备号:副设备号  文件inode号        文件路径</span></span><br></pre></td></tr></table></figure><p>cat &#x2F;proc&#x2F;pid&#x2F;status # 查看当前进程状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">:~<span class="variable">$sudo</span> <span class="built_in">cat</span> /proc/7/status</span></span><br><span class="line">Name:   init</span><br><span class="line">Umask:  0022</span><br><span class="line">State:  S (sleeping)</span><br><span class="line">Tgid:   7</span><br><span class="line">Ngid:   0</span><br><span class="line">Pid:    7</span><br><span class="line">PPid:   1</span><br><span class="line">TracerPid:      0</span><br><span class="line">Uid:    0       0       0       0</span><br><span class="line">Gid:    0       0       0       0</span><br><span class="line">FDSize: 128</span><br><span class="line">Groups:</span><br><span class="line">NStgid: 7</span><br><span class="line">NSpid:  7</span><br><span class="line">NSpgid: 7</span><br><span class="line">NSsid:  7</span><br><span class="line">VmPeak:     1812 kB</span><br><span class="line">VmSize:     1812 kB</span><br><span class="line">VmLck:         0 kB</span><br><span class="line">VmPin:         0 kB</span><br><span class="line">VmHWM:        88 kB</span><br><span class="line">VmRSS:        88 kB</span><br><span class="line">RssAnon:              88 kB</span><br><span class="line">RssFile:               0 kB</span><br><span class="line">RssShmem:              0 kB</span><br><span class="line">VmData:      312 kB</span><br><span class="line">VmStk:       132 kB</span><br><span class="line">VmExe:       980 kB</span><br><span class="line">VmLib:         4 kB</span><br><span class="line">VmPTE:        40 kB</span><br><span class="line">VmSwap:        0 kB</span><br><span class="line">HugetlbPages:          0 kB</span><br><span class="line">CoreDumping:    0</span><br><span class="line">THP_enabled:    1</span><br><span class="line">Threads:        1</span><br><span class="line">SigQ:   0/31282</span><br><span class="line">SigPnd: 0000000000000000</span><br><span class="line">ShdPnd: 0000000000000000</span><br><span class="line">SigBlk: 0000000000010000</span><br><span class="line">SigIgn: fffffffc7ff8fefe</span><br><span class="line">SigCgt: 0000000000010000</span><br><span class="line">CapInh: 0000000000000000</span><br><span class="line">CapPrm: 000001ffffffffff</span><br><span class="line">CapEff: 000001ffffffffff</span><br><span class="line">CapBnd: 000001ffffffffff</span><br><span class="line">CapAmb: 0000000000000000</span><br><span class="line">NoNewPrivs:     0</span><br><span class="line">Seccomp:        0</span><br><span class="line">Seccomp_filters:        0</span><br><span class="line">Speculation_Store_Bypass:       thread vulnerable</span><br><span class="line">Cpus_allowed:   ffff</span><br><span class="line">Cpus_allowed_list:      0-15</span><br><span class="line">Mems_allowed:   1</span><br><span class="line">Mems_allowed_list:      0</span><br><span class="line">voluntary_ctxt_switches:        1</span><br><span class="line">nonvoluntary_ctxt_switches:     0</span><br></pre></td></tr></table></figure><h2 id="内存管理目标"><a href="#内存管理目标" class="headerlink" title="内存管理目标"></a>内存管理目标</h2><h3 id="main-memory"><a href="#main-memory" class="headerlink" title="main memory"></a>main memory</h3><ul><li>Main memory is central(中心) to the operation of a modern computer  system. </li><li>Memory consists(组成) of a large array of bytes, each with its own address(每一个字节都拥有地址).</li><li>The CPU fetches(获取) instructions from memory according to the value of  the program counter(PC). These instructions may cause additional(额外的)  loading from and storing to specific(特定的) memory addresses.</li><li>A typical(典型的) instruction-execution cycle, for example, first fetches an  instruction from memory. The instruction is then decoded(解码&#x2F;译码) and may  cause operands to be fetched from memory. After the instruction has  been executed on the operands, results may be stored back in  memory.</li></ul><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><ul><li>高速缓存是一种存取速度比内存快，但容量比内存小的多的存储器，它可以加快访问物理内存的相对速度。</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-12_14-19-42.png"></p><p>现代操作系统存在三级缓存，一级缓冲又分为指令缓存和数据缓冲，每个核心内均有二级缓存，三级缓存为所有核心公有</p><h3 id="保护操作系统和用户进程"><a href="#保护操作系统和用户进程" class="headerlink" title="保护操作系统和用户进程"></a>保护操作系统和用户进程</h3><ul><li>用户进程不可以访问操作系统内存数据，以及用户进程空间之间不能互相影响<ul><li>通过硬件实现，因为操作系统一般不干预CPU对内存的访问</li><li>base register：基址寄存器，保存一个进程加载到内存空间的起始地址</li><li>limit register：限长寄存器，保存这个进程所占空间的长度</li><li>上述两个寄存器的值只能被操作系统的特权指令加载，通过这两个寄存器可以确定一个进程的起始地址和结束地址，若访问地址不在这一区间内，操作系统将拒绝访问</li></ul></li></ul><h2 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h2><h3 id="地址空间和地址转换"><a href="#地址空间和地址转换" class="headerlink" title="地址空间和地址转换"></a>地址空间和地址转换</h3><ul><li>逻辑地址：面向程序的地址，总是从0开始编址，每 一条指令的逻辑地址就是与第1条指令之间的相对偏移，因此逻辑地址也叫相对地址或虚拟地址。</li><li>物理地址：内存单元看到的实际地址，也称为绝对地址</li><li>所有逻辑地址的集合称为逻辑地址空间，这些逻辑地址对应的所有物理地址集合称为物理地址空间。</li><li>地址转换：由逻辑地址转换成物理地址。</li></ul><h3 id="内存管理单元MMU"><a href="#内存管理单元MMU" class="headerlink" title="内存管理单元MMU"></a>内存管理单元MMU</h3><p>程序在编译时以及加载时均采用逻辑地址（加载时不计算地址，在运行时计算真实地址），只有在运行时才使用真实地址</p><ul><li>Memory-Management Unit完成逻辑地址到物理地址运行时的转换工作。</li><li>在加载时将加载首地址存放在，重定位寄存器（relocation register）或基址寄存器</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-12_14-59-39.png"></p><p>这解决了进程内存无法移动的问题，只需要将进程对应的重定位寄存器中的修改即可修改进程的加载位置</p><h2 id="contiguous-连续的-memory-allocation"><a href="#contiguous-连续的-memory-allocation" class="headerlink" title="contiguous(连续的) memory allocation"></a>contiguous(连续的) memory allocation</h2><h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><ul><li>In contiguous memory allocation, each process is  contained in a single section of memory that is  contiguous(相近的) to the section containing the next  process.</li><li>进程内部地址是连续的，进程与进程间是连续的</li></ul><h3 id="FIXED-SIZED-PARTITION-固定大小分区"><a href="#FIXED-SIZED-PARTITION-固定大小分区" class="headerlink" title="FIXED-SIZED PARTITION 固定大小分区"></a>FIXED-SIZED PARTITION 固定大小分区</h3><ul><li>Memory is divided(划分) to several(数个) fixed-sized(固定大小的) partitions(分区).  Each partition may contain exactly(恰好) one process.</li></ul><p>存在一张内存分区表，用于查看分区是否被占用</p><p><img src="/img/oprating_system/Snipaste_2023-05-12_15-40-27.png"></p><p>当 P1所占用的内存为 6K 那么P1 将加载到 编号为 1 的分区中，此时 1号 分区的 occuiped 将变为 1 表示已经占用，这意味为 1号 分区将不允许有其他进程占用，剩余的 2k 将会浪费掉。浪费掉的空间被称为碎片。这是一种非常早期的分区方案。</p><h3 id="Variable-partition-可变分区"><a href="#Variable-partition-可变分区" class="headerlink" title="Variable partition 可变分区"></a>Variable partition 可变分区</h3><ul><li>In the variable-partition scheme, the operating system(方案)  keeps two tables indicating(表明) which parts of memory  are available and which are occupied.（这两张表指的是占用表和空闲表）</li><li>Initially(初始时), all memory is available for user processes  and is considered(看作) one large block of available  memory, a hole.</li><li>Eventually,(最终) as you will see, memory contains a set of  holes of various sizes(不同大小)</li></ul><p>由于进程的加载与释放这势必会导致内存中出现一系列的孔洞，当相邻两个进程都释放时，所形成的孔洞将合并为一个孔洞</p><h4 id="动态存储分配问题"><a href="#动态存储分配问题" class="headerlink" title="动态存储分配问题"></a>动态存储分配问题</h4><ul><li>首次适应  分配首个足够大的孔，效率最高</li><li>最佳适应  分配最小的足够大的孔，浪费最小</li><li>最坏适应  分配最大的孔，产生的剩余孔更可能 被再利用</li></ul><p>首次分配和最佳分配在执行时间和利用空间方面都好于最坏适应，首次适应的效率优于最佳适应</p><h3 id="地址转换和保护"><a href="#地址转换和保护" class="headerlink" title="地址转换和保护"></a>地址转换和保护</h3><ul><li>两种连续分配方案的地址转换方式是相似的：  物理地址 &#x3D; 基址 + 逻辑地址</li><li>地址保护策略：与限长limit(寄存器)进行比较</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-12_16-43-12.png"></p><p>CPU在每次依靠MMU内存映射单元计算逻辑地址时，逻辑地址均要与 [0，limit] 范围进行比较（因为都要加基地址故省去），若在这个范围内则进行地址转换（访问物理地址），否则不进行地址转换（抛出异常）</p><h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><ul><li>Fragmentation: some little pieces of memory hardly  to be used.<ul><li>internal fragmentation(内部碎片)：针对固定分区来说，就是进程占用的固定分区的内存所导致有剩余内存，这部分内存被称为碎片</li><li>external fragmentation(外部碎片)：针对可变分区来说，当所剩孔洞足够小，小到不支持进程分配，那么部分内存被称为碎片</li></ul></li><li>碎片的解决方法：compaction(压缩，紧凑)，只有运行时地址转换才可以执行compaction，compaction的开销较大<br><img src="/img/oprating_system/Snipaste_2023-05-12_16-56-53.png"></li></ul><p>现代操作系统已经不采用这种内存管理的方案了</p><p>参考：<a href="https://www.bilibili.com/video/BV1bf4y147PZ/">https://www.bilibili.com/video/BV1bf4y147PZ/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Memory-management&quot;&gt;&lt;a href=&quot;#Memory-management&quot; class=&quot;headerlink&quot; title=&quot;Memory management&quot;&gt;&lt;/a&gt;Memory management&lt;/h1&gt;&lt;p&gt;cat &amp;#x2F;</summary>
      
    
    
    
    
    <category term="oprating system" scheme="http://example.com/tags/oprating-system/"/>
    
  </entry>
  
  <entry>
    <title>Page table</title>
    <link href="http://example.com/2024/10/23/13.page%20table/"/>
    <id>http://example.com/2024/10/23/13.page%20table/</id>
    <published>2024-10-23T13:58:45.998Z</published>
    <updated>2024-10-23T13:58:45.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Page-table"><a href="#Page-table" class="headerlink" title="Page table"></a>Page table</h1><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>页表是可以简化的，原来的页表：</p><p><img src="/img/oprating_system/Snipaste_2023-05-13_20-01-44.png"></p><p>可以观察出，若当页面号连续时，可以将页表简化为一个数组，数组元素中存放数组下标（即页面号）所对应的页框号</p><h3 id="页面大小"><a href="#页面大小" class="headerlink" title="页面大小"></a>页面大小</h3><p><img src="/img/oprating_system/Snipaste_2023-05-13_20-04-43.png"></p><ul><li>若逻辑地址长度为 m bits，页面大小：2^n Bytes<ul><li>页内位移占n bits</li><li>页号占m-n bits</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">:~<span class="variable">$uname</span> -m     //查看CPU架构</span></span><br><span class="line">x86_64</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">:~<span class="variable">$getconf</span> PAGESIZE   //获取当前页面大小</span></span><br><span class="line">4096</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">由于 4096Byte = 2 ^ 12 n=12   ,   系统为 64 位 故 m=64  (理论上)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但由于 64 位地址太大了，实际上我们只使用了 48位用来表示逻辑地址</span></span><br></pre></td></tr></table></figure><h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><ul><li>The operating system maintains(维护) a copy(副本) of the page  table for each process.</li><li>This copy is used to translate(转化) logical addresses to  physical addresses.</li><li>It is also used by the CPU dispatcher(派遣器) to define the  hardware page table when a process is to be allocated  the CPU.：当一个进程要被分配到CPU时，它也被CPU调度器用来定义硬件页表。</li><li>Paging therefore increases the context-switch(上下文切换) time</li></ul><h2 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h2><h3 id="HARDWARE-PAGE-TABLE（硬件页表）"><a href="#HARDWARE-PAGE-TABLE（硬件页表）" class="headerlink" title="HARDWARE PAGE TABLE（硬件页表）"></a>HARDWARE PAGE TABLE（硬件页表）</h3><ul><li>The page table is kept in main memory, and a pagetable base register (PTBR) points to the page table.</li><li>Changing(切换) page tables requires changing only this one  register, substantially(大幅的) reducing(减少) context-switch time.</li><li>With this scheme(方案), two memory accesses are needed to  access a byte (one for the page-table entry, one for the  byte).：在这种方案下，访问一个字节需要两次内存访问（一次为页表条目（寻找对应页面），一次为字节）。</li></ul><h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><ul><li>TLB(Translation(转换) Look-aside(旁路) Buffer(缓冲区)) is a kind of small,  fast-lookup(快速查找) hardware cache. It is used with page  tables in the following way(以下方式).<ul><li>The TLB contains only a few of (少数)the page-table entries(条目).这些条目的总称为快表</li><li>When a logical address is generated by(被生成) the CPU, its page  number is presented(提交) to the TLB. </li><li>If the page number is found, its frame number is  immediately available(可用的) and is used to access memory. </li><li>If TLB miss(没有命中), a memory reference to the page table must be  made.</li></ul></li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-13_21-28-33.png"></p><ul><li>The percentage(百分比) of times that the page number of interest is  found in the TLB is called the hit ratio(命中率).</li></ul><h2 id="基于页的保护与共享"><a href="#基于页的保护与共享" class="headerlink" title="基于页的保护与共享"></a>基于页的保护与共享</h2><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><ul><li>为了防止地址转换时出现异常，可在页表每个条目 设置一个“valid-invalid”比特位，用于表示该页 的有效性。</li><li>这个方法可以被轻松扩 展以提供更好的保护级别，如两个bit可实现 “只读”、“读 写”、“可执行”等。</li></ul><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p><img src="/img/oprating_system/Snipaste_2023-05-13_22-27-25.png"></p><p>如图，进程P1 P2 P3 对应的页表中均含有 3 4 6 号页面，这意味着3 4 6 号页面被三个进程所共享，只有特定的内容才可以被共享，一般具有只读属性</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><h4 id="页表大小"><a href="#页表大小" class="headerlink" title="页表大小"></a>页表大小</h4><ul><li>假设CPU是32bits，采用的逻辑地址是32bits，那么 进程的逻辑地址空间大小为2 32Bytes，即4G Bytes。<ul><li>若页面大小是4K Bytes，则一个进程最多被分成 4G&#x2F;4K &#x3D; 1M个页 面，也就是说进程的页表最多有1M个页表项；</li><li>若每个页表项占用4Bytes，则每个页表最多占用 1M B* 4B &#x3D; 4MBytes ，由于页大小为4k，故需要 4M&#x2F;4K 1K个连续页框。</li></ul></li></ul><p>问题来了，1k个连续的页框应该如何解决？<br>这里采用的方法时将页表也拆散</p><h4 id="页表页"><a href="#页表页" class="headerlink" title="页表页"></a>页表页</h4><p><img src="/img/oprating_system/Snipaste_2023-05-14_13-57-38.png"></p><p>我们将进程分为（p#0 p#1 p#2 …… p#7），将其存放在页表中，根据页表可以查询到对应的页框，但是由于页表较大需要连续分配2个页框，但我们希望将页表分开存储以达到内存灵活，因此设计了页表页。首先将页表按照页框大小分若个个并标号，将页表离散的存储到页框中，页表页中记录了页表对应的编号和存放到对应页框的对应关系，这样就实现了页表的离散存储。当然对应的逻辑地址也要发生改变。这种分页方法我们称为二级页表</p><h4 id="多级页表-1"><a href="#多级页表-1" class="headerlink" title="多级页表"></a>多级页表</h4><p><img src="/img/oprating_system/Snipaste_2023-05-14_14-12-11.png"></p><ul><li>上面是一个32位地址采用两级页表的例子，页面大 小是4KBytes，第一级页表页的数量是1K个，每个页 表页中包含的页面数量也是1K个。</li><li>下面是x86-64架构CPU采用的四级页表方案</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-14_14-12-42.png"></p><p>参考：<a href="https://www.bilibili.com/video/BV1bf4y147PZ/">https://www.bilibili.com/video/BV1bf4y147PZ/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Page-table&quot;&gt;&lt;a href=&quot;#Page-table&quot; class=&quot;headerlink&quot; title=&quot;Page table&quot;&gt;&lt;/a&gt;Page table&lt;/h1&gt;&lt;h2 id=&quot;页表&quot;&gt;&lt;a href=&quot;#页表&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="oprating system" scheme="http://example.com/tags/oprating-system/"/>
    
  </entry>
  
  <entry>
    <title>Segnation paging</title>
    <link href="http://example.com/2024/10/23/12.segmation_page/"/>
    <id>http://example.com/2024/10/23/12.segmation_page/</id>
    <published>2024-10-23T13:58:45.998Z</published>
    <updated>2024-10-23T13:58:45.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="segmation-paging分段分页"><a href="#segmation-paging分段分页" class="headerlink" title="segmation_paging分段分页"></a>segmation_paging分段分页</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>Solution to fragmentation(碎片): permit(允许) the logical address  space of processes to be noncontiguous(不连续). <ul><li>The view of memory is different between</li><li>logical (programmer’s ): a variable-sized(可变大小的) segments</li><li>physical : a linear(线性的) array of bytes</li></ul></li><li>The hardware could provide a memory mechanism(机制)  that mapped(映射) the logical view to the actual(实际的) physical  memory.</li></ul><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><h3 id="划分段"><a href="#划分段" class="headerlink" title="划分段"></a>划分段</h3><p>将：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void f()&#123;    //在未划分段时，地址时连续的，从 0 开始直至结束</span><br><span class="line">1.//...... </span><br><span class="line">2.//...... </span><br><span class="line">3.//...... </span><br><span class="line">4.&#125; </span><br><span class="line">5.void g()&#123; </span><br><span class="line">6.//...... </span><br><span class="line">7.//...... </span><br><span class="line">8.&#125; </span><br><span class="line">9.int main()&#123; </span><br><span class="line">10.//...... </span><br><span class="line">11.//...... </span><br><span class="line">12.return 0; </span><br><span class="line">13.&#125;</span><br></pre></td></tr></table></figure><p>划分为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0.void f()&#123;    //划分段后每段的起始地址为 0 ，每个段有对应的标号，段与段之间不需要连续</span><br><span class="line">1.//...... </span><br><span class="line">2.//...... </span><br><span class="line">3.//...... </span><br><span class="line">4.&#125;    // #1 表示第一段</span><br><span class="line">0.void g()&#123; </span><br><span class="line">1.//...... </span><br><span class="line">2.//...... </span><br><span class="line">3.&#125;    //#3 表示第三段</span><br><span class="line">0.int main()&#123; </span><br><span class="line">1.//...... </span><br><span class="line">2.//...... </span><br><span class="line">3.return 0;</span><br><span class="line">4.&#125;    //#2 表示第二段</span><br></pre></td></tr></table></figure><p><strong>在分段之后的程序中，访问逻辑地址需要表明段号和偏移</strong></p><p>注意：上述代码前的标号代表指令而非C语言语句</p><p>由于内存被分成了许多段，而且段与段之间并不连续，这就意味着需要一张段表来存放对应的信息用来寻找对应的逻辑地址</p><p>段表：段号，基址，限长</p><p>当拿到一个逻辑地址&lt;段号：偏移&gt;时，首先将段表内相应段号对应的基址值存放到base寄存器中，将对应的段限长存放到limit寄存器中，先执行保护（比较偏移与段限长，若未超过段限长则说明地址有效）后进行转换（物理地址 &#x3D; base + offset）</p><h3 id="逻辑地址-16位段式地址转换实例"><a href="#逻辑地址-16位段式地址转换实例" class="headerlink" title="逻辑地址 16位段式地址转换实例"></a>逻辑地址 16位段式地址转换实例</h3><p><img src="/img/oprating_system/Snipaste_2023-05-12_22-29-16.png"></p><ul><li><p>假设逻辑地址的段号占2bits，段内位移占14bits，此时 PC寄存器的值为0x240</p></li><li><p>下⼀条指令的物理地址为：</p><blockquote><p>PC：0b0000 00,10 0100 0000</p><p>故段号为0</p><p>下一条指令物理地址：0x4000 + 0x240 &#x3D; 0x4240</p></blockquote></li><li><p>Move 0x4050 → $a0, Move PC+4 → PC，下条指令物理地址为：</p><blockquote><p>PC由0x240 变为 0x244：0000 0010 0100 0100</p><p>短号为 0 </p><p>吓一跳物理地址为 0x4000 + 0x244 &#x3D; 0x4244</p></blockquote></li><li><p>Move 0x0248 → $ra (return address!), Move 0x0360 → PC，下条指令物理地址为：</p><blockquote><p>上述汇编指令意味着，将 0x0248存放到ra寄存器中（做函数的返回地址）</p><p>将PC寄存器中的值更新为 0x0360：0000 0011 0110 0000<br>对应短号为 0</p><p>下一条物理地址为：0x4000 + 0x0360 &#x3D; 0x4360</p></blockquote></li><li><p>Move 0x0→$v0, Move PC+4→PC，下条指令物理地址为：0x4364</p></li><li><p>“lb $t0,($a0)”(将a0寄存器中所示内存地址处取出1个字节存到寄存器t0中)，该内存地址为：</p><blockquote><p>a0中存放的值为：0x4040：0b0100 0000 0101 0000</p><p>对应的段为 1</p><p>运行时物理内存为：0x4800 + 0x50 &#x3D; 0x4850</p></blockquote></li></ul><p>分段并没有完全解决外部碎片的问题</p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="基本方案"><a href="#基本方案" class="headerlink" title="基本方案"></a>基本方案</h3><p>将内存看作是由若干个相等大小的分区组成，我们称这个分区为帧或页框</p><p>将进程也分为与帧大小相同的若干个，称为页面，只有切割进程的最后一块可能小于页面大小</p><p><img src="/img/oprating_system/Snipaste_2023-05-13_16-30-28.png"></p><p>如图：将内存分为 19 块等大的帧，进程分为 11 块等大的页面，将这 11个等大的页面离散的存放在memory中，当然就需要一张表用于存放帧的使用情况，记录了页面也页框的对应情况这个表被称为页表</p><p><img src="/img/oprating_system/Snipaste_2023-05-13_16-35-17.png"></p><p>分页后指令的逻辑地址将从 0 开始，为了确定物理地址，就必须确定页面号与页内偏移，根据页面号通过查询页表找到对应的页框号，从而确定物理地址</p><p><strong>physical address &#x3D; frame_no * pagesize + offset</strong></p><p>操作系统在进行分页地址转换时，直接将页面号替换为页框号与页内偏移进行拼接即可获得物理地址</p><h3 id="分页硬件"><a href="#分页硬件" class="headerlink" title="分页硬件"></a>分页硬件</h3><p><img src="/img/oprating_system/Snipaste_2023-05-13_17-19-09.png"></p><p>CPU根据逻辑地址&lt;页面号，页偏移&gt;，根据页面号查询页表找到对应的段号，将段号与段偏移拼接，得到物理地址</p><h3 id="LOGICAL-ADDRESS"><a href="#LOGICAL-ADDRESS" class="headerlink" title="LOGICAL ADDRESS"></a>LOGICAL ADDRESS</h3><ul><li>The page size (like the frame size) is defined by the hardware. The size of a  page is a power of 2(2的幂次), varying(更改) between 512 bytes and 1 GB per page,  depending(依赖) on the computer architecture(架构). （大小为2的幂次是为了可以拼接运算，目前大多数计算机采用页面大小为 4k）</li><li>The selection of a power of 2 as a page size makes the translation(转化) of a  logical address into a page number and page offset particularly(特别的) easy.</li><li>If the size of the logical address space is 2m , and a page size is 2n bytes,  then the high-order <code>m − n </code>bits of a logical address designate(指定为) the page  number, and the <code>n</code> low-order bits designate the page offset. Thus, the  logical address is as follows:</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-13_17-36-17.png"></p><h2 id="分页与分段的区别"><a href="#分页与分段的区别" class="headerlink" title="分页与分段的区别"></a>分页与分段的区别</h2><p><img src="/img/oprating_system/Snipaste_2023-05-13_17-45-49.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;segmation-paging分段分页&quot;&gt;&lt;a href=&quot;#segmation-paging分段分页&quot; class=&quot;headerlink&quot; title=&quot;segmation_paging分段分页&quot;&gt;&lt;/a&gt;segmation_paging分段分页&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="oprating system" scheme="http://example.com/tags/oprating-system/"/>
    
  </entry>
  
  <entry>
    <title>virtual memory</title>
    <link href="http://example.com/2024/10/23/14.virtual%20memory/"/>
    <id>http://example.com/2024/10/23/14.virtual%20memory/</id>
    <published>2024-10-23T13:58:45.998Z</published>
    <updated>2024-10-23T13:58:45.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Virtual-memory"><a href="#Virtual-memory" class="headerlink" title="Virtual memory"></a>Virtual memory</h1><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p><img src="/img/oprating_system/Snipaste_2023-05-15_10-40-40.png"></p><p>CPU核心首先从 cache 中寻找数据，当数据不存在时再访问内存，并且将该内存的内容拷贝一份放入缓存。<br>缓存的长相形如上图黄色部分，每次向缓存读入数据的单位是缓存行，一个缓存行中有8个格子，每个格子大小为 8Byte，故：一个缓存行大小为 64Byte。当缓存中没有指定内容，需要到内存中访问数据时，会将该内存以及后 63Byte，一同拷贝到一个缓存行中</p><h3 id="那些数据应该放入缓存中"><a href="#那些数据应该放入缓存中" class="headerlink" title="那些数据应该放入缓存中"></a>那些数据应该放入缓存中</h3><p><img src="/img/oprating_system/Snipaste_2023-05-15_11-06-53.png"></p><p>由大量的实验表明，在进程中，大量被引用的代码和数据常常位于进程地址空间中的某一局部地址，这被称为局部性原理。由于存在局部性原理，使得缓存的命中率变得非常的高</p><h3 id="局部性原理-1"><a href="#局部性原理-1" class="headerlink" title="局部性原理"></a>局部性原理</h3><ul><li>时间局部性(Temporal locality)：如果某个信息这次被访问，那它有可能在不久的未来被多次访问。</li><li>空间局部性(Spatial locality)：如果某个位置的信息被访问，那和它相邻的信息也很有可能被访问到。</li><li>内存局部性(Memory locality)：访问内存时，大概率会访问连续的块，而不是单一的内存地址，其实就是空 间局部性在内存上的体现。</li><li>分支局部性(Branch locality)：计算机中大部分指令是顺序执行，顺序执行和非顺序执行的比例大致是5:1。 </li><li>等距局部性(Equidistant locality)：等距局部性是指如果某个位置被访问，那和它相邻等距离的连续地址极有可 能会被访问到。</li></ul><h3 id="修改缓存"><a href="#修改缓存" class="headerlink" title="修改缓存"></a>修改缓存</h3><p>两种方案（保持数据的一致性）：</p><ul><li>write through：修改缓存数据的同时修改内存数据（效率低下，不仅修改了内存还修改了缓存，不如直接该内存）</li><li>write back：只修改缓存数据，直到该数据要被清除出 缓存再修改内存中的数据，我们称缓存中被修改的数据为dirty data(脏数据)</li></ul><h3 id="缓存数据的淘汰"><a href="#缓存数据的淘汰" class="headerlink" title="缓存数据的淘汰"></a>缓存数据的淘汰</h3><p>缓存的容量很小，当缓存满的时候，就需要将缓存中的部分数据淘汰，装入新的数据。  这就需要淘汰算法</p><ul><li>淘汰命中次数最少的</li><li>淘汰第一个CacheLine 或 最后一个CacheLine</li></ul><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="部分装入和部分对换"><a href="#部分装入和部分对换" class="headerlink" title="部分装入和部分对换"></a>部分装入和部分对换</h3><ul><li>部分装入<ul><li>进程运行时仅加载部分进入内存，而不必全部装入</li><li>其余部分暂时放在swap space(交换空间)</li></ul></li><li>部分对换<ul><li>可以将进程部分对换出内存，用以腾出内存空间</li><li>对换出的部分暂时放在swap space</li></ul></li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-15_14-35-59.png"></p><p>swap space位于磁盘，当进程会将一部分暂时不需要的内容存放在swap space中，当swap space中的内容被需要时将会加载到内存中，这个过程被称为 swap in ， 进程不需要的内容会被存放在swap space中，这个过程被称为 swap out。由于swap in 和 swap out 的存在，导致内存好像变得无限大，这个swap space就被称为虚拟内存</p><h3 id="virtual-memory"><a href="#virtual-memory" class="headerlink" title="virtual memory"></a>virtual memory</h3><ul><li>Virtual memory is a technique that allows the execution  of processes that are not completely(完全地) in memory.(部分装入)</li><li>One major(主要的) advantage of this scheme(安排) is that programs can  be larger than physical memory.</li><li>Further(此外), virtual memory abstracts(抽象) main memory into an  extremely(极度地) large, uniform(统一) array of storage, separating(独立的)  logical memory as viewed by the user from physical  memory.</li><li>This technique frees programmers(程序员) from the concerns(关注) of  memory-storage limitations(限制).</li></ul><h2 id="demand-paging-请求调页"><a href="#demand-paging-请求调页" class="headerlink" title="demand paging 请求调页"></a>demand paging 请求调页</h2><p>linux采用分页机制管理内存，请求调页时基于分页机制的</p><h3 id="demand-paging"><a href="#demand-paging" class="headerlink" title="demand  paging"></a>demand  paging</h3><ul><li>With demand-paged virtual memory , pages  are loaded only when  they are demanded  during program  execution.<br>在需求分页的虚拟内存中，只有在程序执行过程中需要的时候才会加载页面。</li><li>Pages that are never  accessed(访问) are thus never  loaded into physical  memory.</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-15_15-28-20.png"></p><p>如图：一个进程被分为7个页面(ABCDEFGH)，只有ACF被装载到内存中（我们称之为内存驻留），其余页面位于虚拟内存中。此时page table内只记录内存驻留的页面，当需要虚拟内存中数据时，当发起请求，成功则执行调页并记录在page table内</p><h3 id="请求调页步骤"><a href="#请求调页步骤" class="headerlink" title="请求调页步骤"></a>请求调页步骤</h3><p><img src="/img/oprating_system/Snipaste_2023-05-15_15-43-15.png"></p><p>当逻辑地址 M 被引用时，首先在页表中查询，对应invalue，即此页面没有加载到内存中，将发出缺页中断，将在内核模式下完成调页，将在虚拟内存中找到所要加载的页面，在页框中找到空闲的页框，将其载入，后在页表中记录</p><h3 id="请求调页的性能"><a href="#请求调页的性能" class="headerlink" title="请求调页的性能"></a>请求调页的性能</h3><ul><li><p>假设访问内存时间为ma，处理一次缺页中断的时间 记作page fault time，令p为缺页中断的出现几率， 则有效访问时间的计算公式为：</p><blockquote><p>effective access time &#x3D; (1 − p) × ma + p × page fault time </p></blockquote></li><li><p>若ma&#x3D;200ns，page fault time&#x3D;8ms，p&#x3D;0.001，则  </p><blockquote><p>effective access time &#x3D; 8200ns </p></blockquote><p>比直接访问内存慢了40倍</p></li><li><p>缺页中断率p对性能影响重大</p></li></ul><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ul><li>当进程在执行过程中发生了缺页，在请求调页的时候发现内存已经没有空闲页框可用，操作系统在此时会做出一个处理：页面置换。</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-15_19-02-24.png"></p><ol><li>在内存中选取一个页框为victim(牺牲者)，将它放在swap page中保存</li><li>将页表中对应的页框置为invalid</li><li>将所要加载的页面加载到空出的页框中</li><li>将页表中对应页框标记为valid</li></ol><p>对于victim的选择就由很大的讲究了，若选的不好，这将大大增加缺页的概率，导致执行时间延长</p><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><ul><li>总是淘汰最先进入内存的页面，因为它在内存中待的时间最久。</li></ul><h3 id="OPIMAL-最优"><a href="#OPIMAL-最优" class="headerlink" title="OPIMAL 最优"></a>OPIMAL 最优</h3><ul><li>总是淘汰未来最长时间不会再使用的页面。</li></ul><p>虽然是最优算法，但是不可能实现，因为操作系统不能知道每个页面将应该在何时被使用</p><h3 id="LRU（LEAST-RECENT-UNUSED）"><a href="#LRU（LEAST-RECENT-UNUSED）" class="headerlink" title="LRU（LEAST RECENT UNUSED）"></a>LRU（LEAST RECENT UNUSED）</h3><ul><li>总是淘汰最近最少使用的页面</li></ul><h2 id="系统抖动"><a href="#系统抖动" class="headerlink" title="系统抖动"></a>系统抖动</h2><ul><li>If the process does not have the number of frames it needs to support pages in active use, it will quickly pagefault. At this point, it must replace some page. However, since all its pages are in active use, it must replace a page that will be needed again right away. Consequently, it quickly faults again, and again, and again, replacing pages that it must bring back in immediately.<br>如果进程没有它所需要的页框数量来支持正在使用的页面，它将很快出现pagefault。在这一点上，它必须替换一些页面。然而，因为它的所有页面都在使用中，所以它必须替换一个马上就需要的页面 它必须替换一个马上就会再次需要的页面。因此，它迅速地再犯错，再犯错，再犯错，替换那些必须立即恢复的页面。它必须立即恢复。</li><li>This high paging activity is called thrashing. A process is  thrashing if it is spending more time paging than  executing.<br>这种高分页活动被称为 “抖动”。一个进程如果一个进程花在分页上的时间多于执行的时间。</li></ul><h3 id="抖动的原因"><a href="#抖动的原因" class="headerlink" title="抖动的原因"></a>抖动的原因</h3><p>开始时，COU利用率随着多道程序的增加而增加，当多道程序持续增多，CPU利用率陡然下降（page faul 出现增多），产出了抖动</p><p><img src="/img/oprating_system/Snipaste_2023-05-15_19-41-41.png"></p><ul><li>并发进程数量过多 </li><li>进程页框分配不合理</li></ul><h3 id="PAGE-FAULT-FREQUENCY（频率）"><a href="#PAGE-FAULT-FREQUENCY（频率）" class="headerlink" title="PAGE FAULT FREQUENCY（频率）"></a>PAGE FAULT FREQUENCY（频率）</h3><p><img src="/img/oprating_system/Snipaste_2023-05-15_19-50-56.png"></p><ul><li>PFF称作页面故障(频)率，基于这个数据可以实施一个 防止抖动的策略：动态调节分配给进程的页框数量。</li></ul><p>使一个进程的 page fault frequency 动态调节位于 upper bound 和 lower bound 之间，这样既不会造成资源的浪费也不会发生过多的缺页</p><h3 id="CONCLUDING-REMARKS"><a href="#CONCLUDING-REMARKS" class="headerlink" title="CONCLUDING REMARKS"></a>CONCLUDING REMARKS</h3><ul><li>Practically speaking, thrashing and the resulting  swapping have a disagreeably large impact on  performance.</li><li>The current best practice in implementing a computer  facility is to include enough physical memory, whenever  possible, to avoid thrashing and swapping.</li><li>From smartphones through mainframes, providing  enough memory to keep all working sets in memory  concurrently, except under extreme conditions, gives the  best user experience.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Virtual-memory&quot;&gt;&lt;a href=&quot;#Virtual-memory&quot; class=&quot;headerlink&quot; title=&quot;Virtual memory&quot;&gt;&lt;/a&gt;Virtual memory&lt;/h1&gt;&lt;h2 id=&quot;局部性原理&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="oprating system" scheme="http://example.com/tags/oprating-system/"/>
    
  </entry>
  
  <entry>
    <title>Mass story</title>
    <link href="http://example.com/2024/10/23/15.mass%20storage/"/>
    <id>http://example.com/2024/10/23/15.mass%20storage/</id>
    <published>2024-10-23T13:58:45.998Z</published>
    <updated>2024-10-23T13:58:45.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mass-storage"><a href="#Mass-storage" class="headerlink" title="Mass storage"></a>Mass storage</h1><h2 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h2><ul><li>磁道：能被磁头访问的一组同心圆  </li><li>扇区：磁道上的区域，数据存放的基本单位  </li><li>柱面：所有盘片同一磁头下的磁道集合</li></ul><p>对磁道的划分有两种方法：</p><ol><li>以同心圆的方式划分：磁盘要使用恒定角速度旋转</li></ol><p><img src="/img/oprating_system/Snipaste_2023-05-16_10-59-35.png"></p><ol start="2"><li>以磁道密度相等划分：磁盘转动的线速度相等，即角速度不断改变</li></ol><h3 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h3><ul><li><p>低级格式化（Low-level formatting</p><ul><li>physical formatting </li><li>为每个扇区使用特殊的数据结构进行填充，包括一个头 部、数据区域和一个尾部。</li><li>头部和尾部包含一些控制信息，如扇区号、ECC码(校验码)等。<br>低级格式化是与操作系统无关的格式化，属于物理级别的格式化，一个磁盘建立柱面划分扇区的过程就是在低级格式化中完成的，当大家买到一块硬盘时，低级格式化就已经完成了。当磁道损坏较高时应该进行低级格式化</li></ul></li><li><p>高级格式化（High-level formatting）</p><ul><li><p>Logical formatting</p></li><li><p>构建文件系统，在磁盘上初始化文件系统数据结构，如空 闲和 已分配空间表、一个空目录等。</p><p>高级格式化一般是和操作系统有关的<br>如windows电脑一般采用 NTFS 进行格式化 MAC系统一般采用EXT4 进行格式化</p></li></ul></li></ul><h2 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h2><ul><li>查找一个物理块的顺序：柱面号、磁头号和扇区号<ul><li>寻道时间Ts：将磁头定位到正确磁道(柱面)上所花的时 间，与盘片直径和传动臂速度相关，平均20ms。  </li><li>旋转延迟Tr：所查找的扇区转到磁头下所用的时间，与 磁盘的旋转速度有关，一个10,000 r&#x2F;m的磁盘平均旋转延 迟为3ms。  </li><li>传送时间T：传送扇区内的数据的时间，同样取决于磁盘 的旋转速度，T &#x3D; b&#x2F;(rN) (b为要传送的字节数，N为一个 磁道中的字节数，r为转速)</li></ul></li><li>总的平均存取时间 Ta &#x3D; Ts + Tr + T</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">条件假设: </span><br><span class="line">平均寻道时间为 5 ms，平均旋转延迟为 4 ms </span><br><span class="line">传输速率为 4 MByte/s，扇区大小是 1 KByte</span><br><span class="line"></span><br><span class="line">如果随机访问一个扇区 </span><br><span class="line">Ta = 5ms + 4ms + 0.25ms ≈ 10 ms </span><br><span class="line">总的存取速率为100 KByte/sec</span><br><span class="line"></span><br><span class="line">如果要访问的扇区在同一个柱面 </span><br><span class="line">Ta = 4ms + 0.25ms ≈ 5 ms → 200 KByte/sec </span><br><span class="line"></span><br><span class="line">如果下一个要访问的扇区正好和上次访问的扇区相邻 </span><br><span class="line">Ta = 0.25ms → 4 MByte/sec</span><br><span class="line">可以看出寻道时间和旋转延时相对于数据访问是要大得多</span><br></pre></td></tr></table></figure><h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><h3 id="disk-io-request"><a href="#disk-io-request" class="headerlink" title="disk io request"></a>disk io request</h3><ul><li>Whenever a process needs I&#x2F;O to or from(读或书) the disk, it  issues(发出) a system call to the operating system. The  request specifies(指定) several(一些) pieces of information:<ul><li>Whether this operation(操作) is input or output  </li><li>What the disk address for the transfer(转移) is  </li><li>What the memory address for the transfer is  </li><li>What the number of sectors(扇区) to be transferred is</li></ul></li></ul><h3 id="disk-scheduling"><a href="#disk-scheduling" class="headerlink" title="disk scheduling"></a>disk scheduling</h3><ul><li>For a multiprogramming system with many processes, the  disk queue may often have several(多个) pending (未决) requests.</li></ul><h4 id="FCFS先来先服务"><a href="#FCFS先来先服务" class="headerlink" title="FCFS先来先服务"></a>FCFS先来先服务</h4><p><img src="/img/oprating_system/Snipaste_2023-05-16_12-38-28.png"></p><h4 id="SSTF-Shortest-seek-time-first"><a href="#SSTF-Shortest-seek-time-first" class="headerlink" title="SSTF(Shortest seek time first)"></a>SSTF(Shortest seek time first)</h4><p>每次寻道均寻找当前队列中，距离当前磁头所在磁道距离最近的柱面</p><p><img src="/img/oprating_system/Snipaste_2023-05-16_12-42-34.png"></p><p>这会导致磁臂粘连现象，这本质也是一种饥饿现象，磁头会读取当前柱面附近的柱面，从而导致与之较远的柱面长时间未被读取，产生饥饿</p><h4 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h4><p><img src="/img/oprating_system/Snipaste_2023-05-16_12-50-24.png"></p><p>扫描算法，会沿着当前方向一直寻找，直至到<strong>最端柱面</strong>，在此过程中若经过pending queue中存在的柱面号，则暂停寻找处理数据。<br>当进程所有访问的柱面是分散的时，采用scan算法时较好</p><h4 id="c-scan"><a href="#c-scan" class="headerlink" title="c-scan"></a>c-scan</h4><p>scan算法是会原路返回的，但是这一小段时间内pending队列中出现靠近柱面最端的概率并不大，故改进，当扫描到达柱面端时，从另一柱面端开始重新扫描</p><p><img src="/img/oprating_system/Snipaste_2023-05-16_13-13-09.png"></p><h4 id="look"><a href="#look" class="headerlink" title="look"></a>look</h4><p>scan和c-scan算法，有些蠢，当对应方向之后没有要寻找的柱面时，磁头任然会继续移动直至柱面端点，look对此进行了改善，当对应方向之后没有需要寻找的柱面时，方向将会反转</p><p><img src="/img/oprating_system/Snipaste_2023-05-16_13-18-24.png"></p><ul><li><p>FCFS is the simplest(最简单的). </p></li><li><p>SSTF is common and has a natural appeal but it may  cause a starvation(饥饿) problem.  </p></li><li><p>SCAN and C-SCAN perform better for systems that  place a heavy load on the disk.</p></li></ul><p>查看linux中当前的和支持的磁盘调度算法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">:~<span class="variable">$cat</span> /sys/block/sda/queue/scheduler</span></span><br></pre></td></tr></table></figure><h3 id="linux-io-scheduler"><a href="#linux-io-scheduler" class="headerlink" title="linux io scheduler"></a>linux io scheduler</h3><ul><li>noop：it performs(施行) FCFS policy which is good enough for SSD.</li><li>deadline：it works by creating two queues: a read queue and a  write queue. Each I&#x2F;O request has a time stamp(时间戳) associated(关联) that is used by the kernel for an expiration(过期) time. When an I&#x2F;O  request reaches its deadline, it is pushed to(推到) the highest priority(优先级).    </li><li>cfq：Complete(完全) Fairness(公平的) Queueing works by creating a perprocess I&#x2F;O queue. The goal of this I&#x2F;O scheduler is to provide  a fair I&#x2F;O priority to each process. While the CFQ algorithm is  complex, the gist of this scheduler is that after ordering the  queues to reduce disk seeking, it services these per-process I&#x2F;O  queues in a round-robin fashion.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mass-storage&quot;&gt;&lt;a href=&quot;#Mass-storage&quot; class=&quot;headerlink&quot; title=&quot;Mass storage&quot;&gt;&lt;/a&gt;Mass storage&lt;/h1&gt;&lt;h2 id=&quot;磁盘结构&quot;&gt;&lt;a href=&quot;#磁盘结构&quot; cla</summary>
      
    
    
    
    
    <category term="oprating system" scheme="http://example.com/tags/oprating-system/"/>
    
  </entry>
  
  <entry>
    <title>Process Concept</title>
    <link href="http://example.com/2024/10/23/2.process%20concept/"/>
    <id>http://example.com/2024/10/23/2.process%20concept/</id>
    <published>2024-10-23T13:58:45.998Z</published>
    <updated>2024-10-23T13:58:45.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h1><h2 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h2><h3 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h3><ul><li>A program is a passive(被动的) entity(实体), such as a file  containing a list of instructions stored on disk(often  called an executable file).</li><li>A program becomes a process when an executable file  is loaded into memory.</li><li>A process is an active(活动的) entity, with a program counter(程序计数器) specifying(指明) the next instruction to execute an a set of  associated(相关的) resources<br>一个进程是一个活跃的实体，有一个程序计数，指定下一条要执行的指令和一组相关的资源。</li></ul><h3 id="program-counter"><a href="#program-counter" class="headerlink" title="program counter"></a>program counter</h3><ul><li>程序计数器（PC）是一个CPU中的寄存器，里面存放下一条要执行指令的内存地址，在Intel x86和 Itanium微处理器中，它叫做指令指针（Instruction  Pointer，IP），有时又称为指令地址寄存器 （instruction address register，IAR）、指令计数器。</li><li>通常，CPU在取完一条指令之后会将PC寄存器的值 加“1”，以计算下条要执行指令的地址。这里的 + 1 指的是指向下一条指令</li></ul><p><strong>process in memory 详细参考csapp第七章链接 以及 栈工作原理不在赘述了，</strong></p><h3 id="并发的进程"><a href="#并发的进程" class="headerlink" title="并发的进程"></a>并发的进程</h3><ul><li><p>Concurrency(并发)：the fact(事实) of two or more events or  circumstances(情况) happening or existing at the same time.</p></li><li><p>与并行的区别</p><blockquote><p>并发是指系统能够同时处理多个任务，而不是同时执行多个任务。在并发模型中，任务被交替执行，它们共享系统资源（例如 CPU、内存等），每个任务都有自己的执行上下文，但它们在同一时间只能执行一部分操作。这种模型通常用于处理大量的 I&#x2F;O 操作，因为在等待 I&#x2F;O 操作完成的过程中，系统可以同时执行其他任务，从而提高了系统的利用率。</p><p>并行是指系统可以同时执行多个任务，每个任务都可以独立执行，它们之间没有任何依赖关系。在并行模型中，任务被同时执行，每个任务都有自己的 CPU 核心或处理器来处理它们，每个任务的执行时间可以重叠，从而缩短了总体的执行时间。这种模型通常用于处理计算密集型任务，例如图像处理、数值模拟等。</p><p>总之，虽然并发和并行都涉及到同时执行多个任务，但并发强调的是同时处理多个任务，而并行强调的是同时执行多个任务。</p></blockquote></li><li><p>进程并发的动机：多道程序设计</p></li></ul><h3 id="并发进程共享CPU"><a href="#并发进程共享CPU" class="headerlink" title="并发进程共享CPU"></a>并发进程共享CPU</h3><ul><li>并发进程可能无法一次性执行完毕，会走走停停。</li><li>一个进程在执行过程中可能会被另一个进程替换占有 CPU，这个过程称作“进程切换”。</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-07_17-02-52.png"></p><p>如图有三个进程并发运行，实线表示占用 CUP 虚线表示不占用 CPU 可能进行 IO 操作，参见这幅图进程切换也就显而易见了</p><h3 id="进程的定义-1"><a href="#进程的定义-1" class="headerlink" title="进程的定义"></a>进程的定义</h3><ul><li>进程是一个程序的一次执行过程<ul><li>能完成具体的功能</li><li>是在某个数据集合上完成的</li><li>执行过程是可并发的</li></ul></li><li>进程是资源分配、保护和调度的基本单位</li></ul><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><h3 id="进程状态-process-state"><a href="#进程状态-process-state" class="headerlink" title="进程状态(process state)"></a>进程状态(process state)</h3><ul><li>进程在执行期间自身的状态会发生变化，进程有三 种基本状态，分别是：<ul><li>运行态（Running）：此时进程的代码在CPU上运行</li><li>就绪态（Ready）：进程具备运行条件，等待分配CPU</li><li>等待态（Waiting）：进程在等待某些事件的发生（比如 IO操作或是一个信号）</li></ul></li></ul><h3 id="进程何时离开CPU"><a href="#进程何时离开CPU" class="headerlink" title="进程何时离开CPU"></a>进程何时离开CPU</h3><ul><li>内部事件 （主动）<ul><li>进程主动放弃(yield)CPU，进入等待状态。E.g 使用I&#x2F;O设备</li><li>非正常结束，进入终止状态。E.g 除数是0</li></ul></li><li>外部事件（被动）<ul><li>进程被剥夺CPU使用权，进入就绪状态。这个动作叫抢占(preempt)。E.g 时间片到达，高优先权进程到达。</li></ul></li></ul><h3 id="进程转换"><a href="#进程转换" class="headerlink" title="进程转换"></a>进程转换</h3><p><img src="/img/oprating_system/Snipaste_2023-05-07_19-51-24.png"></p><blockquote><p>一个程序被加载处于新建状态，当资源齐全时会进入就绪ready(就绪状态)</p><p>running -&gt; ready ：被动被抢占，可能时间片到达，高优先级被抢占</p><p>running -&gt; waiting：主动放弃，可能调用了 IO 设备</p><p>running -&gt; finish：程序非正常结束，可能除数是 0</p><p>ready -&gt; running：当排队到时间片时，开始运行</p><p>waiting -&gt; running : 这是不可行的</p><p>waiting -&gt; ready：如当 IO 操作完成时程序进入就绪态，IO操作由 USB 控制器完成</p><p>ready -&gt; running：不用解释</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程概念&quot;&gt;&lt;a href=&quot;#进程概念&quot; class=&quot;headerlink&quot; title=&quot;进程概念&quot;&gt;&lt;/a&gt;进程概念&lt;/h1&gt;&lt;h2 id=&quot;进程的定义&quot;&gt;&lt;a href=&quot;#进程的定义&quot; class=&quot;headerlink&quot; title=&quot;进程的定义&quot;&gt;</summary>
      
    
    
    
    
    <category term="oprating system" scheme="http://example.com/tags/oprating-system/"/>
    
  </entry>
  
  <entry>
    <title>process scheduling</title>
    <link href="http://example.com/2024/10/23/3process%20scheduling%20and%20practice1/"/>
    <id>http://example.com/2024/10/23/3process%20scheduling%20and%20practice1/</id>
    <published>2024-10-23T13:58:45.998Z</published>
    <updated>2024-10-23T13:58:45.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="process-scheduling"><a href="#process-scheduling" class="headerlink" title="process scheduling"></a>process scheduling</h1><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><h3 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h3><ul><li>外中断：来自处理器之外的硬件中断信号<ul><li>如时钟中断、键盘中断、外围设备中断</li><li><strong>外部中断均是异步中断</strong>，所谓的异步就是随机</li></ul></li><li>内中断（异常 Exception）：来自于处理器内部，指令执行过程中发生的中断，<strong>属同步中断</strong><ul><li>硬件异常：掉电、奇偶校验错误等</li><li>程序异常：非法操作、地址越界、断点、除数为0 </li><li>系统调用</li></ul></li></ul><p><strong>由于系统调用是内中断所以系统调用存在陷阱机制(这才是系统调用陷阱机制的原因)</strong></p><p>外中断是不可预测的是随机的。但是内中断(异常)的发生均是在预定指令的执行过程中发生的，所以异常属于同步中断</p><h3 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h3><p>在详细的说一遍中断的过程：</p><p><img src="/img/oprating_system/Snipaste_2023-05-07_21-34-47.png"></p><blockquote><ol><li>程序在用户态执行时由于自身原因遇到了异常或由于外部时间导致程序产出中断</li><li>save the context(上下文) of the executing process，如当前寄存器状态，cpu时间片使用</li><li>陷入内核态，determine(确认) the cause of exception or interrupt，Handle the exception &#x2F; interrupt</li><li>select a process to restore and resume(复原)  选择要恢复的进程<br>restore the context of the selected process   恢复所选择进程的上下文<br>resume execution of the selected process     恢复所选择进程的执行</li></ol></blockquote><h3 id="特权指令和非特权指令"><a href="#特权指令和非特权指令" class="headerlink" title="特权指令和非特权指令"></a>特权指令和非特权指令</h3><ul><li>Privileged(特权) Instructions : The Instructions that can run only in Kernel Mode are called  Privileged Instructions .<ul><li>I&#x2F;O instructions and Halt(停顿&#x2F;暂定) instructions </li><li>Turn off all Interrupts    关闭所有中断</li><li>set the Timer(定时器)</li><li>process switching(切换)</li></ul></li><li>Non-Privileged Instructions : The Instructions that can run only in User Mode are called Non-Privileged Instructions</li></ul><h3 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h3><p><strong>中断是用户态向核心态转换的唯一途径！系统调用 实质上也是一种中断</strong></p><p>OS提供<code>Load PSW</code>指令装载用户进程返回用户状态</p><p><img src="/img/oprating_system/Snipaste_2023-05-07_22-06-12.png"></p><h3 id="进程切换-1"><a href="#进程切换-1" class="headerlink" title="进程切换"></a>进程切换</h3><ul><li><p>切换时机</p><ul><li><p>进程需要进入等待状态，主动离开CPU可能因为执行 IO 操作</p></li><li><p>进程被抢占CPU而进入就绪状态，被动离开可能因为时间片切换</p><blockquote><p>进程切换一定发生在中断&#x2F;异常&#x2F;系统调用处理过程中，常见的有以下情况：</p><ul><li>时间片<strong>中断</strong>、IO<strong>中断</strong>后 更改优先级进程；（导致被中断进程进入<strong>就绪态</strong>）；</li><li>阻塞式<strong>系统调用</strong>、<strong>虚拟地址异常</strong>；（导致被中断进程进入<strong>等待态</strong>）</li><li>终止用<strong>系统调用</strong>、<strong>不能继续执行的异常</strong>；（导致被中断进程进入<strong>终止态</strong>）</li></ul></blockquote></li></ul></li><li><p>切换过程</p><ul><li>由用户态切换到内核态，之后的切换工作均在内核态完成</li><li>保存被中断进程的上下文信息（Context)</li><li>修改被中断进程的控制信息（如状态等）</li><li>将被中断的进程加入相应的状态队列 ，若为等待状态则进入等待状态的队列</li><li>调度一个新的进程并恢复它的上下文信息</li></ul></li></ul><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>A Process Control Block（PCB）contains many  pieces of information associated(与……有关) with a specific(特定的)  process.</p><p>每个进程中都有一个PCB控制块</p><p>PCB进程控制块中包含了</p><blockquote><p>process state：进程状态，如就绪，等待，运行</p><p>process num：进程号 pid</p><p>programe counter</p><p>registers：寄存器的值</p><p>memory limits：内存信息，如：加载地址，最大上限，虚拟地址</p><p>list of open file：进程所打开的文件描述符</p><p>等一系列信息</p></blockquote><h3 id="进程在物理内存"><a href="#进程在物理内存" class="headerlink" title="进程在物理内存"></a>进程在物理内存</h3><p>存放方式如图：</p><p><img src="/img/oprating_system/Snipaste_2023-05-08_09-08-00.png"></p><p>进程实际在物理内存中并不是连续存放的，而是离散的</p><h3 id="进程队列"><a href="#进程队列" class="headerlink" title="进程队列"></a>进程队列</h3><p><img src="/img/oprating_system/Snipaste_2023-05-08_09-12-24.png"></p><p>如图，第一个队列为就绪队列，其余均为等待队列。等待队列有多个是因为针对不同的IO设备存在对应个数的等待对垒。没有运行队列的原因，对于单处理器来说哦同一时间只有一个进程可以运行。</p><p>注意进程队列中存放的是对于进程的PCB信息而非进程的全部信息，因为PCB足以描述进程切换所用到的信息</p><h3 id="进程调度-process-sheduling"><a href="#进程调度-process-sheduling" class="headerlink" title="进程调度(process sheduling)"></a>进程调度(process sheduling)</h3><p>进程在整个生命周期中会在各个调度队列中迁移， 由操作系统的一个调度器（scheduler）来执行。</p><p><img src="/img/oprating_system/Snipaste_2023-05-08_09-20-42.png"></p><p>如图：显示了进程调度中可能的情况，从等待状态 - &gt; 就绪状态 - &gt; 运行状态 ， 这个迁移过程是由 scheduler 完成的</p><p>由于学过linux系统编程了实验二就是fork函数的使用，我就没有做</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;process-scheduling&quot;&gt;&lt;a href=&quot;#process-scheduling&quot; class=&quot;headerlink&quot; title=&quot;process scheduling&quot;&gt;&lt;/a&gt;process scheduling&lt;/h1&gt;&lt;h2 id=&quot;进</summary>
      
    
    
    
    
    <category term="oprating system" scheme="http://example.com/tags/oprating-system/"/>
    
  </entry>
  
  <entry>
    <title>thread</title>
    <link href="http://example.com/2024/10/23/4.thread/"/>
    <id>http://example.com/2024/10/23/4.thread/</id>
    <published>2024-10-23T13:58:45.998Z</published>
    <updated>2024-10-23T13:58:45.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="threads"><a href="#threads" class="headerlink" title="threads"></a>threads</h1><h2 id="线程定义"><a href="#线程定义" class="headerlink" title="线程定义"></a>线程定义</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul><li>一个应用通常需要同时处理很多工作，比如一个Web浏览器，可能需要同时处理文字和图片，这些同时执行的任务可称为 “执行流”，我们不希望它们是顺序执行的。</li><li>早期，每个执行流都要创建一个进程来实现，但是进程的创建需要消耗大量的时间和资源。</li><li>现在，和一个应用相关的所有执行任务都装在一个进程里，这些进程内部的执行任务就是“线程”（Thread）。</li></ul><p>如果一个web服务器中的文字图片和视频是顺序执行的，那么用户体验是极差的，但这不是我们要讨论的主题，主要是CPU的利用率是低下的，进程浪费的资源主要是内存资源</p><h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><p>如图是单线程进程和多线程进程的部分虚拟内存布局</p><p><img src="/img/oprating_system/Snipaste_2023-05-08_12-18-04.png"></p><p>多线程进程：code data files 这三样东西是共享的，与多进程程序相比节省了系统资源，即线程间通信资源消耗小于进程间通信。每个线程中独立存在保存当前进程的寄存器值，以及线程中独立拥有栈空间</p><h3 id="采用多线程的优点"><a href="#采用多线程的优点" class="headerlink" title="采用多线程的优点"></a>采用多线程的优点</h3><ul><li><p>响应性：</p></li><li><p>资源共享</p></li><li><p>经济</p></li><li><p>可伸缩性</p><p>如web服务器接受client的请求，每接收一个请求就新建一个线程，由于client访问的资源常常会有重复，线程不像进程那样复制资源，共享资源节省了很大的内存，可伸缩性值的是多核处理器中并行运行时可以独占CPU</p></li></ul><h3 id="defintion-of-thread"><a href="#defintion-of-thread" class="headerlink" title="defintion of thread"></a>defintion of thread</h3><ul><li>A thread is a basic unit(基本单位) of CPU utilization(利用); it comprises(包括) a  thread id, a program counter, a register set, and a stack.</li><li>It shares with other threads belonging(属于) to the same  process its code section, data section, and other  operating-system resources, such as open files and  signals(信号).</li><li>A traditional(传统的) (or heavyweight) process has a single(单一的)  thread of control. If a process has multiple threads of  control, it can perform(执行) more than one task at a time.</li></ul><h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><h3 id="多核编程"><a href="#多核编程" class="headerlink" title="多核编程"></a>多核编程</h3><p>在多处理器系统中，多核编程机制让应用程序可以 更有效地将自身的多个执行任务（并发的线程）分散到不同的处理器上运行，以实现并行计算         </p><p><img src="/img/oprating_system/Snipaste_2023-05-08_12-42-43.png"></p><h3 id="多线程模型-1"><a href="#多线程模型-1" class="headerlink" title="多线程模型"></a>多线程模型</h3><ul><li><p>用户线程ULT（User Level Thread）</p><blockquote><p>ULT在user mode下运行，它的管理无需内核支持。</p></blockquote></li><li><p>内核线程KLT（Kernel Level Thread）</p><blockquote><p>KLT在kernel mode下运行，由操作系统支持与管理。</p></blockquote></li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-08_12-48-49.png"></p><h4 id="M：1模型"><a href="#M：1模型" class="headerlink" title="M：1模型"></a>M：1模型</h4><p>当只有一个CUP单核时：</p><p><img src="/img/oprating_system/Snipaste_2023-05-08_15-52-10.png"></p><p>所有的用户模式下的线程对应这一个内核模式下的线程</p><p>在用户看来自己使用的是多线程，用户认为有多个执行流（逻辑上），实际上真正占有CPU的只有一个线程<strong>只有KLP才可以占有CPU</strong>，这样设计的原因是硬件一般仅有一个核心</p><h4 id="1：1模型"><a href="#1：1模型" class="headerlink" title="1：1模型"></a>1：1模型</h4><p>存在一个用户线程就有一个内核线程与之对应</p><p><img src="/img/oprating_system/Snipaste_2023-05-08_16-01-51.png"></p><p>在内核级别的线程上看来实现了真正的并发与并行(多核)，但是由于每个用户线程对应一个内核线程，这样显得过于浪费资源</p><h4 id="M：M模型"><a href="#M：M模型" class="headerlink" title="M：M模型"></a>M：M模型</h4><p><img src="/img/oprating_system/Snipaste_2023-05-08_16-07-29.png"></p><p>注意：KLP的数量大于CPU的核心数</p><p>解决了1：1模型中开销大的问题，但是加入了用户线程想内核线程分配的过程，实现复杂</p><p>NPTL：native(原生的) posix thread library     指的是1：1模型</p><p>NGPT：nexr gerneration(机构) posix thread  指的是M：M模型</p><p>目前操作系统的主流采用 1：1模型</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>使用Pthread库创建多个线程，并观察线程的并发执行现象及数据共享</p><blockquote><p>Monte Carlo技术计算π值（多线程）</p></blockquote><p>数学原理：</p><p><img src="/img/oprating_system/Snipaste_2023-05-08_17-01-17.png"><br>$$<br>(2r) ^ 2 &#x2F; π * r^2 &#x3D; 4<br>$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">calculate_pi</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cir_points = <span class="number">0</span>;    <span class="comment">//存在圆内的点的数量</span></span><br><span class="line">    <span class="type">int</span> square_points = <span class="number">0</span>; <span class="comment">//存在正方形内点的数量</span></span><br><span class="line">    <span class="type">double</span> pi;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> intervals = *(<span class="type">int</span>*)argv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;intervals * intervals;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> rand_x = (<span class="type">double</span> )rand() / RAND_MAX;</span><br><span class="line">        <span class="type">double</span> rand_y = (<span class="type">double</span> )rand() / RAND_MAX;</span><br><span class="line">        <span class="keyword">if</span>(rand_x * rand_x + rand_y * rand_y &lt; <span class="number">1</span>)</span><br><span class="line">            cir_points++;</span><br><span class="line">        square_points++;</span><br><span class="line">    &#125;</span><br><span class="line">    pi = (<span class="type">double</span> )(<span class="number">4.0</span> * cir_points) / square_points;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;circle points: %d , square_point: %d , the extimated PI is %lf pid :%d\n&quot;</span>,</span><br><span class="line">           cir_points,square_points,pi,getpid());</span><br><span class="line">    pthread_exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="type">time_t</span> start = rand();</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = <span class="number">100</span> * (i + <span class="number">1</span>);</span><br><span class="line">        pthread_create(tid+i,<span class="literal">NULL</span>,calculate_pi,(<span class="type">void</span>*)(arr+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">time_t</span> delta = rand();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time : %ld&quot;</span>,(delta - start) / CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;threads&quot;&gt;&lt;a href=&quot;#threads&quot; class=&quot;headerlink&quot; title=&quot;threads&quot;&gt;&lt;/a&gt;threads&lt;/h1&gt;&lt;h2 id=&quot;线程定义&quot;&gt;&lt;a href=&quot;#线程定义&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="oprating system" scheme="http://example.com/tags/oprating-system/"/>
    
  </entry>
  
  <entry>
    <title>CPU Scheduling</title>
    <link href="http://example.com/2024/10/23/5.CPU%20scheduling/"/>
    <id>http://example.com/2024/10/23/5.CPU%20scheduling/</id>
    <published>2024-10-23T13:58:45.998Z</published>
    <updated>2024-10-23T13:58:45.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CPU-Scheduling"><a href="#CPU-Scheduling" class="headerlink" title="CPU Scheduling"></a>CPU Scheduling</h1><h2 id="CPU调度程序"><a href="#CPU调度程序" class="headerlink" title="CPU调度程序"></a>CPU调度程序</h2><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><ul><li>多道程序设计的目的将CPU 的利用率最大化。</li><li>多个进程同时存在于内存（并发），当一个进程暂不使用CPU时，系统调度另一 个进程占用CPU。</li></ul><p>CPU-burst Durrations(CPU突发事件持续时间)</p><p><img src="/img/oprating_system/Snipaste_2023-05-08_20-48-58.png"></p><p>如图：横轴为突发时间持续时间，纵轴为发生的频率</p><p>我们将时间位于 0 - 8ms 中的进程称为 CPU-bound program 也可以被称为短进程 ，大于 8ms的进程称为 I&#x2F;O-bound program 也可以被称为长进程，从频率长看大多数进程属于短进程</p><h3 id="CPU调度程序-1"><a href="#CPU调度程序-1" class="headerlink" title="CPU调度程序"></a>CPU调度程序</h3><p>Whenever the CPU becomes idle(闲置), the operating  system must select one of the processes in the ready  queue to be executed. The selection process is carried  out by the CPU scheduler.</p><p>存在两种调度方法：</p><ul><li>非抢占调度（Nonpreemptive scheduling）：一旦某个进程得到CPU，就会一直占用到终止或等待状态。</li><li>抢占调度 (preemptive scheduling)：调度程序被动被动离开CPU如：时间片到期</li></ul><h2 id="CPU调度准则"><a href="#CPU调度准则" class="headerlink" title="CPU调度准则"></a>CPU调度准则</h2><h3 id="调度算法的衡量"><a href="#调度算法的衡量" class="headerlink" title="调度算法的衡量"></a>调度算法的衡量</h3><ul><li>CPU利用率：CPU的忙碌程度</li><li>响应时间：从提交任务到第一次响应的时间，针对交互式系统</li><li>等待时间：进程<strong>累积</strong>在就绪队列中等待的时间</li><li>周转时间：从提交到完成的时间</li><li>呑吐率：每个时钟单位处理的任务数</li><li>公平性：以合理的方式让各个进程共享CPU</li></ul><p>假设作业 i 提交给系统的时刻是ts，完成的时刻是tf， 所需运行时间为 tk，那么：</p><blockquote><p>单个作业的周转时间 ti：完成时间 - 开始时间<br>$$<br>ti &#x3D; tf - ts<br>$$<br>平均作业周转时间 T：n为操作系统的进程数，将每个进程的周转时间累加后在平均<br>$$<br>T &#x3D; \sum_{i&#x3D;1}^n ti \times 1 &#x2F; n<br>$$</p></blockquote><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务-FCFS）"><a href="#先来先服务-FCFS）" class="headerlink" title="先来先服务(FCFS）"></a>先来先服务(FCFS）</h3><ul><li><p>First-Come, First-Served (FCFS)</p><ul><li><p>早期系统里，FCFS意味着一个程序会一直运行到结束(尽管其中会出 现等待I&#x2F;O的情况)</p></li><li><p>非抢占式</p></li><li><p>如今，当一个程序阻塞时会让出CPU</p><blockquote><p>假设当前就绪队列中依次存在 p1  p2  p3  p4 四个进程，p1 开始运行，运行过程中调用IO设备，此时将让出CPU进入等待状态，位于就绪队列队头的 p2 被调度器从就绪队列中取出进入运行状态，一段时间后 p1 完成IO操作要返回就绪队列，要注意的是，p1入队(从队尾入队)</p></blockquote><p><img src="/img/oprating_system/Snipaste_2023-05-09_08-24-27.png"></p><p><img src="/img/oprating_system/Snipaste_2023-05-09_08-25-17.png"></p><p>第二种排列方式比第一种要好，平均周转时间缩短为18</p></li><li><p>优点：简单易行<br>缺点：需要控制进程先到的顺序才能时平均周转时间减少</p></li></ul></li></ul><h3 id="时间片轮转-ROUND-ROBIN"><a href="#时间片轮转-ROUND-ROBIN" class="headerlink" title="时间片轮转(ROUND ROBIN)"></a>时间片轮转(ROUND ROBIN)</h3><ul><li><p>时间片轮转(ROUND ROBIN)</p><ul><li>每个进程都可以得到相同的CPU时间(CPU时间片,  time slice)，当时间片到达，进程将被剥夺CPU并加入就绪队列的尾部 。（分时系统）</li><li>抢占式调度算法</li><li>n个就绪队列中的进程和时间片q：<br>每个进程获得1&#x2F;n的CPU时间，大约是q个时间单位<br>没有进程等待时间会超过 (n-1)q</li><li>例题：</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-09_08-50-03.png"></p><blockquote><p>等待时间分别是：</p><p>P1&#x3D;(68-20)+(112-88)+(145-132)&#x3D;85       P2&#x3D;(20-0)+(88-40)+(132-108)&#x3D;92<br>P3&#x3D;(40-0)+(108-60)&#x3D;88                           dP4&#x3D;(60-0)&#x3D;60 </p><ul><li>平均等待时间 &#x3D; (85+92+88+60)&#x2F;4&#x3D;81.25</li><li>平均周转时间 &#x3D; (153+145+112+68)&#x2F;4&#x3D;119.5</li></ul></blockquote><ul><li>RR算法分析<ul><li>时间片（time slice）取选<ul><li>取值太小：进程切换开销显著增大(不能小于进程切换的时间)</li><li>取值较大：响应速度下降（取值无穷大将退化成FCFS）</li><li>一般时间片的选取范围为 10ms~100ms</li><li>上下文切换的时间大概为 0.1ms~1ms （1%的CPU时间开销）</li></ul></li><li>RR算法优缺点<ul><li>公平算法(+) </li><li>对长作业带来额外的切换开销(-)</li></ul></li></ul></li></ul></li></ul><h3 id="最短作业优先-SJF"><a href="#最短作业优先-SJF" class="headerlink" title="最短作业优先(SJF)"></a>最短作业优先(SJF)</h3><ul><li><p>SJF(Shortest Job First)：下一次调度总是选择所需要 CPU时间最短的那个作业（进程）。</p><p><img src="/img/oprating_system/Snipaste_2023-05-09_09-20-40.png"></p><p>在FCFS算法中，我们提及到，如果我们知道每个作业所需的运行时长，并按照时长从低到高的顺序依次服务，这样求出的平均周转时间是很低的，这也就是SJF算法的由来</p></li><li><p>SJF是一个非抢占式的算法，当人也可以改造为一个抢占式SRTF</p><p>以上图举例：当0时刻P1到达，1时刻 P2 到达，此时 P1 的剩余时间就变为 7 P2 剩余时间少于 P1 故优先运行 P2，依次类推直至进程全部运行完成</p></li><li><p>SJF&#x2F;SRTF算法分析</p><ul><li>该算法总是将短进程移到长进程之前执行，因此平均等待时间 最小，该算法被证明是最优的。</li><li>饥饿现象：长进程可能长时间无法获得CPU</li><li>该算法需要事先知道进程所需的CPU时间，预测一个进程的CPU时间并非易事</li></ul></li><li><p>优缺点</p><ul><li>优化了响应时间(+)</li><li>难以预测作业CPU时间(-)</li><li>不公平算法(-)</li></ul></li></ul><h3 id="优先级调度-PRIORITY"><a href="#优先级调度-PRIORITY" class="headerlink" title="优先级调度(PRIORITY)"></a>优先级调度(PRIORITY)</h3><ul><li><p>优先级通常为固定区间的数字，如[0, 10]：</p><ul><li>数字大小与优先级高低的关系在不同系统中实现不一样，以 Linux为例，0为最高优先级。 </li><li>调度策略：下一次调度总是选择优先级最高的进程。</li><li>SJF是优先级调度的一个特例。</li><li>优先级调度可以是抢占式，也可以是非抢占式。</li></ul></li><li><p>优先级的定义</p><ul><li>静态优先级<ul><li>优先级保持不变，但会出现不公平(饥饿)现象</li></ul></li><li>动态优先级（退化Aging）<ul><li>根据进程占用CPU时间：当进程占有CPU时间愈长，则慢慢降低它的优先级</li><li>根据进程等待CPU时间：当进程在就绪队列中等待时间愈长，则慢慢提升它的优先级</li></ul></li></ul></li><li><h3 id="优先级调度-PRIORITY-1"><a href="#优先级调度-PRIORITY-1" class="headerlink" title="优先级调度(PRIORITY)"></a>优先级调度(PRIORITY)</h3><ul><li>优先级通常为固定区间的数字，如[0, 10]：<ul><li>数字大小与优先级高低的关系在不同系统中实现不一样，以 Linux为例，0为最高优先级。 </li><li>调度策略：下一次调度总是选择优先级最高的进程。</li><li>SJF是优先级调度的一个特例。</li><li>优先级调度可以是抢占式，也可以是非抢占式。</li></ul></li><li>优先级的定义<ul><li>静态优先级<ul><li>优先级保持不变，但会出现不公平(饥饿)现象</li></ul></li><li>动态优先级（退化Aging）<ul><li>根据进程占用CPU时间：当进程占有CPU时间愈长，则慢慢降低它的优先级</li><li>根据进程等待CPU时间：当进程在就绪队列中等待时间愈长，则慢慢提升它的优先级</li></ul></li></ul></li></ul><p>在linux中每个线程中存在一个控制该线程属性的结构体，<code>struct pthread_attr_t</code>，也就是pthread_create函数的第二个参数的所指值，线程属性在使用时要使用<code>pthread_attr_init</code>初始化，使用完之后<code>pthread_attr_destory</code>销毁</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;   </span><br><span class="line"><span class="comment">/*pthread_attr_init之后，pthread_t结构所包含的内容就是操作系统实现</span></span><br><span class="line"><span class="comment">支持的线程所有属性的默认值。</span></span><br><span class="line"><span class="comment">如果pthread_attr_init实现时为属性对象分配了动态内存空间，</span></span><br><span class="line"><span class="comment">pthread_attr_destroy还会用无效的值初始化属性对象，因此如果经</span></span><br><span class="line"><span class="comment">pthread_attr_destroy去除初始化之后的pthread_attr_t结构被</span></span><br><span class="line"><span class="comment">pthread_create函数调用，将会导致其返回错误。*/</span></span><br></pre></td></tr></table></figure><p>  线程属性其结构体为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">int</span>                           detachstate;    线程的分离状态</span><br><span class="line">       <span class="type">int</span>                           schedpolicy;   *线程调度策略 </span><br><span class="line">       <span class="keyword">struct</span> <span class="title class_">sched_param</span>      schedparam;           线程的调度参数</span><br><span class="line">       <span class="type">int</span>                          inheritsched;    线程的继承性</span><br><span class="line">       <span class="type">int</span>                          scope;          *线程的作用域</span><br><span class="line">       <span class="type">size_t</span>                       guardsize;       线程栈末尾的警戒缓冲区大小</span><br><span class="line">       <span class="type">int</span>                          stackaddr_set;   </span><br><span class="line">       <span class="type">void</span> *                     stackaddr;         线程栈的位置</span><br><span class="line">       <span class="type">size_t</span>                      stacksize;        线程栈的大小</span><br><span class="line">&#125;<span class="type">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure><p>  分离状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">我们已经在前面已经知道，在默认情况下线程是非分离状态的，这种情况   </span><br><span class="line">下，原有的线程等待创建的线程结束。只有当pthread_join() 函数返回       </span><br><span class="line">时，创建的线程才算终止，才能释放自己占用的系统资源。   </span><br><span class="line"></span><br><span class="line">分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，</span><br><span class="line">马上释放系统资源。</span><br><span class="line"></span><br><span class="line">通俗的说也就是：我们知道一般我们要等待(pthread_join)一个线程的结束，</span><br><span class="line">主要是想知道它的结束状态，否则等待一般是没有什么意义的！但是<span class="keyword">if</span>有一</span><br><span class="line">些线程的终止态我们压根就不想知道，那么就可以使用“分离”属性，那么我</span><br><span class="line">们就无须等待管理，只要线程自己结束了，自己释放src就可以咯！这样更</span><br><span class="line">方便！</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> * attr, <span class="type">int</span> * detachstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> * attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line">参数：attr:线程属性变量</span><br><span class="line">        detachstate:分离状态属性   </span><br><span class="line">若成功返回<span class="number">0</span>，若失败返回<span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line">设置的时候可以有两种选择：</span><br><span class="line">&lt;<span class="number">1</span>&gt;.detachstate参数为：PTHREAD_CREATE_DETACHED     分离状态启动</span><br><span class="line">&lt;<span class="number">2</span>&gt;.detachstate参数为：PTHREAD_CREATE_JOINABLE    正常启动线程</span><br></pre></td></tr></table></figure><p>  线程的作用域：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">函数pthread_attr_setscope和pthread_attr_getscope分别</span><br><span class="line">用来设置和得到线程的作用域。       </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>   </span></span><br><span class="line"><span class="type">int</span>    <span class="title function_">pthread_attr_getscope</span><span class="params">( <span class="type">const</span> <span class="type">pthread_attr_t</span> * attr, <span class="type">int</span> * scope )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setscope</span><span class="params">( <span class="type">pthread_attr_t</span>*, <span class="type">int</span> scope )</span>;</span><br><span class="line">参数：</span><br><span class="line">        attr               线程属性变量</span><br><span class="line">        scope         线程的作用域       </span><br><span class="line">若成功返回<span class="number">0</span>，若失败返回<span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line">作用域控制线程是否在进程内或在系统级上竞争资源，可能的值是</span><br><span class="line">PTHREAD_SCOPE_PROCESS  （进程内竞争资源）</span><br><span class="line">PTHREAD_SCOPE_SYSTEM   （系统级竞争资源）linux中默认，这是由linux的线程模型为<span class="number">1</span>：<span class="number">1</span>模型决定的·</span><br></pre></td></tr></table></figure><p>  调度策略及优先级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">        函数pthread_attr_setschedpolicy和pthread_attr_getschedpolicy分别用</span><br><span class="line">        来设置和得到线程的调度策略。</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">pthread_attr_getschedpolicy</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *, <span class="type">int</span> * policy)</span></span><br><span class="line">        <span class="type">int</span> <span class="title function_">pthread_attr_setschedpolicy</span><span class="params">(pthread_attr_*, <span class="type">int</span> policy)</span></span><br><span class="line">        参数：</span><br><span class="line">                attr            线程属性变量</span><br><span class="line">                policy        调度策略   </span><br><span class="line">        若成功返回0，若失败返回-1。</span><br><span class="line"></span><br><span class="line">        所谓调度策略也就是我们之前在OS中所学过的那些调度算法：</span><br><span class="line">        SCHED_FIFO    ：先进先出</span><br><span class="line">        SCHED_RR       ：轮转法</span><br><span class="line">        SCHED_OTHER    ：其他方法</span><br><span class="line"></span><br><span class="line">        SCHED_OTHER是不支持优先级使用的,而SCHED_FIFO和SCHED_RR</span><br><span class="line">        支持优先级的使用,他们分别为1和99,数值越大优先级越高.</span><br><span class="line"></span><br><span class="line">        注意：</span><br><span class="line">                &gt; 此处的SCHED_FIFO是允许被高优先级抢占的！</span><br><span class="line">                &gt; 也就是有高优先级的必须先运行</span><br><span class="line">                &gt; SCHED_RR是设置一个时间片</span><br><span class="line">                &gt; 当有SCHED_FIFO或SCHED_RR策赂的线程在一个条件变量</span><br><span class="line">                上等持或等持加锁同一个互斥量时，它们将以优先级顺序被唤</span><br><span class="line">                醒。即，如果一个低优先级的SCHED_FIFO线程和一个高优先</span><br><span class="line">                织的SCHED_FIFO线程都在等待锁相同的互斥且，则当互斥量</span><br><span class="line">                被解锁时，高优先级线程将总是被首先解除阻塞。</span><br><span class="line"></span><br><span class="line">&lt;2&gt;.调度参数：</span><br><span class="line"></span><br><span class="line">        函数pthread_attr_getschedparam 和pthread_attr_setschedparam分别</span><br><span class="line">        用来设置和得到线程的调度参数。</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">pthread_attr_getschedparam</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *,<span class="keyword">struct</span></span></span><br><span class="line"><span class="params">        sched_param *)</span>;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">pthread_attr_setschedparam</span><span class="params">(<span class="type">pthread_attr_t</span> *,<span class="type">const</span> <span class="keyword">struct</span></span></span><br><span class="line"><span class="params">        sched_param *)</span>;</span><br><span class="line">        参数：</span><br><span class="line">                attr            线程变量属性</span><br><span class="line">                param        sched_parm 结构体</span><br><span class="line">        若成功返回<span class="number">0</span>，若失败返回<span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line">        /usr/include /bits/sched.h</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">               <span class="type">int</span> sched_priority;    <span class="comment">//!&gt; 参数的本质就是优先级</span></span><br><span class="line">        &#125;;</span><br><span class="line">        注意：大的权值对应高的优先级!</span><br><span class="line">        系统支持的最大和最小的优先级值可以用函数：</span><br><span class="line">        sched_get_priority_max和sched_get_priority_min得到！</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">        <span class="type">int</span> <span class="title function_">sched_get_priority_max</span><span class="params">( <span class="type">int</span> policy )</span>;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">sched_get_priority_min</span><span class="params">( <span class="type">int</span> policy )</span>;</span><br><span class="line">        参数：max_：    系统支持的优先级的最小值</span><br><span class="line">                min_ ：    系统支持的优先级的最大值</span><br><span class="line"></span><br><span class="line">        使用：max_ = sched_get_priority_max( policy );</span><br><span class="line">                min_ = sched_get_priority_min( policy );</span><br><span class="line">                注意参数是policy调用策略，也就是说对于不同的策略的值是不</span><br><span class="line">                一样的！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        policy = SCHED_OTHER</span><br><span class="line">        max_priority = <span class="number">0</span></span><br><span class="line">        min_priority = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        Show SCHED_FIFO of priority</span><br><span class="line">        max_priority = <span class="number">99</span></span><br><span class="line">        min_priority = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        Show SCHED_RR of priority</span><br><span class="line">        max_priority = <span class="number">99</span></span><br><span class="line">        min_priority = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>  调度策略可以分为两种</p><ul><li><p>normal scheduling：对应的调度策略schedpolicy的取值为<code>SCHED_OTHER    SCHED_IDLE    SCHED_TATCH</code>，此状态下对应的优先级schedparam均为0</p></li><li><p>real scheduling：对应的调度策略schedpolicy取值为<code>SCHED_FIFO    SCHED_RR</code>，此状态下对应的优先级schedparam位于 1 - 99之间，数值越低意味着优先级越低</p><p>我们自己创建进程的调度策略大多均为<code>SCHED_OTHER</code>模式，这种也遵循时间片轮转的策略，但要注意它位于normal，一旦由real sheduling的进程normal sheduling要让出CPU</p><p>在linux终端中查看进程的优先级</p><p>方法一：</p></li></ul><blockquote><p>top命令，注意观察 PR 和 NI(nice)友好值</p><p>PR值越小所代表的优先级越高(与线程属性中的优先级相反)，NI的取值范围(-20，19)，当取值为 0 意味着这是一个普通线程，PR &#x3D; 20 + NI(PR值在normal进程中范围为(0 , 39)，NI值仅对normal有效)，当PR值为负数或者rt)时，意味着该线程为实时线程。对于real scheduling 线程 PR &#x3D; -1 - priority_value(优先级)</p></blockquote><p>  方法二：</p><blockquote><p>chrt命令 -p + pid</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">:/mnt/c/Users/satellite<span class="variable">$sudo</span> chrt -p 7</span></span><br><span class="line">pid 7&#x27;s current scheduling policy: SCHED_OTHER</span><br><span class="line">pid 7&#x27;s current scheduling priority: 0     //优先级</span><br></pre></td></tr></table></figure><p>chrt命令也可以用来设置调度策略</p></blockquote><p>  参考：<a href="https://www.bilibili.com/video/BV1bf4y147PZ">https://www.bilibili.com/video/BV1bf4y147PZ</a><br>  <a href="https://www.jianshu.com/p/7bf93be5a1b0">https://www.jianshu.com/p/7bf93be5a1b0</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CPU-Scheduling&quot;&gt;&lt;a href=&quot;#CPU-Scheduling&quot; class=&quot;headerlink&quot; title=&quot;CPU Scheduling&quot;&gt;&lt;/a&gt;CPU Scheduling&lt;/h1&gt;&lt;h2 id=&quot;CPU调度程序&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
    <category term="oprating system" scheme="http://example.com/tags/oprating-system/"/>
    
  </entry>
  
  <entry>
    <title>Sychronization(同步)</title>
    <link href="http://example.com/2024/10/23/6.Synchronization/"/>
    <id>http://example.com/2024/10/23/6.Synchronization/</id>
    <published>2024-10-23T13:58:45.998Z</published>
    <updated>2024-10-23T13:58:45.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Synchronization（同步）"><a href="#Synchronization（同步）" class="headerlink" title="Synchronization（同步）"></a>Synchronization（同步）</h1><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="并发进程-x2F-线程"><a href="#并发进程-x2F-线程" class="headerlink" title="并发进程&#x2F;线程"></a>并发进程&#x2F;线程</h3><ul><li>在内存中同时存在的若干个进程&#x2F;线程，由操作系统的调度程序采用适当的策略将他(们)调度至CPU(s)上运行，同时维护他们的状态队列。 <ul><li>在内存中同时存在的若干个进程&#x2F;线程，由操作系统 的调度程序采用适当的策略将他(们)调度至CPU(s)上 运行，同时维护他们的状态队列。 </li><li>从微观上看，他们的运行过程是走走停停；</li><li>并发的进程&#x2F;线程之间是交替执行（Interleaving）。</li></ul></li></ul><h3 id="并发进程之间的关系"><a href="#并发进程之间的关系" class="headerlink" title="并发进程之间的关系"></a>并发进程之间的关系</h3><ul><li>独立关系：并发进程分别在自己的变量集合上运行</li><li>交互关系：并发进程执行过程中需要共享或是交换数据，交互的并发进程之间又存在着竞争和协作的关系</li></ul><blockquote><p>这里就不做竞争与协作的笔记了</p></blockquote><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><ul><li>Asynchronous means RANDOM!(异步就意味这随机)</li><li>会引发竞争条件（Race Condition）：一种这样的情况： 多个进程并发操作同一个数据导致执行结果依赖于特定的进程执行顺序。若不加以控制的话有可能引发错误</li></ul><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><ul><li>Process Synchronization means a mechanism(机制) to  maintain(维护) the consistency(一致性) of data shared in cooperative(竞争)  processes.</li><li>Synchronization Tool Kits(套件)<ul><li>Mutex lock：常用于解决竞争问题</li><li>Semaphore(信号量)：常用于解决协作问题</li></ul></li></ul><p>参考：<a href="https://www.bilibili.com/video/BV1bf4y147PZ">https://www.bilibili.com/video/BV1bf4y147PZ</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Synchronization（同步）&quot;&gt;&lt;a href=&quot;#Synchronization（同步）&quot; class=&quot;headerlink&quot; title=&quot;Synchronization（同步）&quot;&gt;&lt;/a&gt;Synchronization（同步）&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    
    <category term="oprating system" scheme="http://example.com/tags/oprating-system/"/>
    
  </entry>
  
  <entry>
    <title>mutex locks</title>
    <link href="http://example.com/2024/10/23/7.mutex%20locks/"/>
    <id>http://example.com/2024/10/23/7.mutex%20locks/</id>
    <published>2024-10-23T13:58:45.998Z</published>
    <updated>2024-10-23T13:58:45.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mutex-locks"><a href="#Mutex-locks" class="headerlink" title="Mutex locks"></a>Mutex locks</h1><p>​    </p><h2 id="critical-section-problem-临界区问题"><a href="#critical-section-problem-临界区问题" class="headerlink" title="critical-section problem (临界区问题)"></a>critical-section problem (临界区问题)</h2><h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><ul><li>Each concurrent(并发的) process has a segment of code, called a  critical section(临界区), in which the process may be changing  common(共有的) variables, updating a table, writing a file, and so on.</li><li>The important feature(特征) of the system is that, when one  process is executing in its critical section, no other process is  allowed to execute in its critical section. That is(换句话说), NO two  processes are executing in their critical sections at the same  time.</li><li>The critical-section problem is to design a protocol(协议) that the  processes can use to cooperate(协作).</li></ul><h3 id="进程进出临界区协议"><a href="#进程进出临界区协议" class="headerlink" title="进程进出临界区协议"></a>进程进出临界区协议</h3><p>伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">entry secion</span><br><span class="line">    critical section</span><br><span class="line">exit section</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入临界区前在 entry section 要请求许可</li><li>离开临界区后在exit section 要归还许可</li></ul><h3 id="临界区管理准则"><a href="#临界区管理准则" class="headerlink" title="临界区管理准则"></a>临界区管理准则</h3><ul><li>Mutual(相互的) exclusion(排他的) (Mutex)：互斥</li><li>Progress：前进</li><li>Bounded waiting：有限等待</li></ul><p>只有一个进程可以进入到临界区，一个进程不可以无限的待在临界区当中</p><p>秘籍：</p><blockquote><p>有空让进，泽一而入，无空等待，有限等待，让权等待</p></blockquote><h2 id="mutex-lock互斥锁"><a href="#mutex-lock互斥锁" class="headerlink" title="mutex lock互斥锁"></a>mutex lock互斥锁</h2><h3 id="define-1"><a href="#define-1" class="headerlink" title="define"></a>define</h3><ul><li>Operating-systems designers build software tools to  solve the critical-section problem. The simplest(最简单的) of  these tools is the mutex lock.</li><li>A process must acquire(获得) the lock before entering a critical  section;</li><li>It must release(释放) the lock when it exits the critical section</li></ul><h3 id="锁的基本操作"><a href="#锁的基本操作" class="headerlink" title="锁的基本操作"></a>锁的基本操作</h3><ul><li>lock：测试一把锁是否已经上锁，若未上锁则上锁，若以上锁则等待</li><li>unlock：解锁</li><li>lock 与 unlock 均为原子操作(不能被打断)</li></ul><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><ul><li>Atomic operations mean the operation can NOT be  interrupted while it’s running.</li><li>原子操作（原语）是操作系统重要的组成部分，下面2条(大多数)硬件指令都是原子操作，它们可以被用来实现对临界区的管理（也就是“锁”）。<br>test_and_set()<br>compare_and_swap()</li></ul><h3 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h3><p>test_and_set实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">test_and_set函数的过程:(这里用C语言的方式解释，但实际上它是一条原语)</span><br><span class="line"><span class="type">bool</span> <span class="title function_">test_and_set</span><span class="params">(<span class="type">bool</span> *target)</span>   <span class="comment">//将传入参数的所指值值为false，并返回传入参数的所指值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> result = *target;</span><br><span class="line">    *target = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">锁的实现：</span><br><span class="line"><span class="type">bool</span> available = <span class="literal">true</span>;    <span class="comment">//lock和unlock共享的资源，初始化为 1 表示被占用</span></span><br><span class="line">lock()&#123;    </span><br><span class="line">    <span class="keyword">while</span>(!test_and_set(&amp;available))   <span class="comment">//循环等待共享变量置为true</span></span><br><span class="line">        <span class="keyword">do</span> nothing</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// .... 临界区</span></span><br><span class="line">unlock()</span><br><span class="line">&#123;</span><br><span class="line">    available = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="忙式等待（BUSY-WAITING）"><a href="#忙式等待（BUSY-WAITING）" class="headerlink" title="忙式等待（BUSY WAITING）"></a>忙式等待（BUSY WAITING）</h3><ul><li>忙式等待是指占用CPU执行空循环实现等待，解决方法是让进程加入到等待队列中，避免消耗CPU</li><li>这种类型的互斥锁也被称为“自旋锁”(spin lock)<ul><li>缺点：浪费CPU周期，可以将进程插入等待队列以让出CPU 的使用权；</li><li>优点：进程在等待时没有上下文切换，对于使用锁时间不长的进程，自旋锁还是可以接受的；在多处理器系统中， 自旋锁的优势更加明显，因为可以实现在一个核心上自旋其他核心运算</li></ul></li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">int</span> ticketAmount = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">ticketMmount</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lock);</span><br><span class="line">    <span class="type">int</span> t = ticketAmount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;One ticket sold\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Ticket sold out\n&quot;</span>);</span><br><span class="line">    ticketAmount = t;</span><br><span class="line">    pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tichetAgent_tid[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(tichetAgent_tid + i,<span class="literal">NULL</span>,ticketMmount,<span class="literal">NULL</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tichetAgent_tid[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.bilibili.com/video/BV1bf4y147PZ">https://www.bilibili.com/video/BV1bf4y147PZ</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mutex-locks&quot;&gt;&lt;a href=&quot;#Mutex-locks&quot; class=&quot;headerlink&quot; title=&quot;Mutex locks&quot;&gt;&lt;/a&gt;Mutex locks&lt;/h1&gt;&lt;p&gt;​    &lt;/p&gt;
&lt;h2 id=&quot;critical-section</summary>
      
    
    
    
    
    <category term="oprating system" scheme="http://example.com/tags/oprating-system/"/>
    
  </entry>
  
  <entry>
    <title>同步问题</title>
    <link href="http://example.com/2024/10/23/9.%E7%95%AA%E5%A4%96%20%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2024/10/23/9.%E7%95%AA%E5%A4%96%20%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</id>
    <published>2024-10-23T13:58:45.998Z</published>
    <updated>2024-10-23T13:58:45.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同步问题案例"><a href="#同步问题案例" class="headerlink" title="同步问题案例"></a>同步问题案例</h1><h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>问题描述：</p><blockquote><p>有两组并发进程：读者和写者，共享一个文件F，要求:<br>（1）允许多个读者同时执行读操作<br>（2）任一写者在完成写操作之前不允许其它读者或写者工作<br>（3）写者执行写操作前，应让已有的写者和读者全部退出</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">semapore rw = <span class="number">1</span>;   <span class="comment">//控制读者和写者同时操作文件,当有写者时加锁，当有第一个读者时加锁（之后只允许读者访问）</span></span><br><span class="line">semapore mutex = <span class="number">1</span>;  <span class="comment">//控制多个写者控制文件</span></span><br><span class="line"><span class="type">int</span> reader_count = <span class="number">0</span>;  <span class="comment">//记录当前的读者数量</span></span><br><span class="line">Reader&#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="keyword">if</span>(reader_count++ == <span class="number">0</span>)   <span class="comment">//如果这是第一个读者，就加锁</span></span><br><span class="line">    &#123;</span><br><span class="line">        P(rw);</span><br><span class="line">    &#125;</span><br><span class="line">    V(mutex);</span><br><span class="line">    <span class="comment">//执行读操作</span></span><br><span class="line"></span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="keyword">if</span>(reader_count-- == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        V(rw);</span><br><span class="line">    &#125;</span><br><span class="line">    V(mutex);</span><br><span class="line">&#125;</span><br><span class="line">Writer&#123;</span><br><span class="line">    P(rw);</span><br><span class="line">    <span class="comment">//写数据</span></span><br><span class="line">    V(rw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当写者加锁成功其余写者与读者均不能加锁，当读者加锁成功，其他读者可以继续执行，但写者无法加锁</p><h2 id="理发师问题"><a href="#理发师问题" class="headerlink" title="理发师问题"></a>理发师问题</h2><p><img src="/img/oprating_system/Snipaste_2023-05-11_13-08-22.png"></p><blockquote><ul><li>理发店有一位理发师、一把理发椅和N把供等候理发的顾客坐的椅子</li><li>如果没有顾客，理发师便在理发椅上睡觉</li><li>一个顾客到来时，他必须叫醒理发师</li><li>如界理发师正在理发时又有顾客来到，则如果有空椅子可坐，就坐下来等待，否则就离开</li><li>使用PV操作求解该问题</li></ul></blockquote><p>初始条件，没有顾客，理发师在休息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semapore customer = <span class="number">0</span>;</span><br><span class="line">semapore barber = <span class="number">1</span>;</span><br><span class="line">semapore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> waiting = <span class="number">0</span>;  <span class="comment">//等待的人数</span></span><br><span class="line">chair_count = max;</span><br><span class="line">Barber&#123;</span><br><span class="line">    P(customer);</span><br><span class="line">    P(mutex); waiting--; V(mutex);</span><br><span class="line">    <span class="comment">//执行理发</span></span><br><span class="line">    V(barber);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customer&#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="keyword">if</span>(waiting &lt;= max) </span><br><span class="line">    &#123;</span><br><span class="line">        waiting++;</span><br><span class="line">        V(mutex);</span><br><span class="line">        P(barber);   <span class="comment">//等待理发师   </span></span><br><span class="line">        V(customer);  </span><br><span class="line">        <span class="comment">//被理发</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        V(mutex);</span><br><span class="line">        <span class="comment">//leaving,椅子已经坐满了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><p><img src="/img/oprating_system/Snipaste_2023-05-11_21-02-26.png"></p><p>有 5 个哲学家，他们面前都有一双筷子，即左手有一根筷子，右手有一根筷子。当然，这个问题有多个版本的描述，可以说是筷子，也可以说是一刀一叉，因为吃牛排的时候，需要刀和叉，缺一不可，也有说是用两把叉子来吃意大利面。这里具体是刀叉还是筷子并不重要，重要的是<strong>必须要同时持有左右两边的两个才行</strong>，也就是说，哲学家左手要拿到一根筷子，右手也要拿到一根筷子，在这种情况下哲学家才能吃饭。为了方便理解，我们选取和我国传统最贴近的筷子来说明这个问题。</p><p>我们来看一下哲学家就餐的主流程。哲学家如果想吃饭，他会先尝试拿起左手的筷子，然后再尝试拿起右手的筷子，如果某一根筷子被别人使用了，他就得等待他人用完，用完之后他人自然会把筷子放回原位，接着他把筷子拿起来就可以吃了（不考虑卫生问题）。这就是哲学家就餐的最主要流程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">semaghore chopstick[5] = &#123;1&#125;;  //初始状态均为空闲状态</span><br><span class="line">philospher_i&#123;</span><br><span class="line">    //Thinking</span><br><span class="line">    P(choptick[i]);</span><br><span class="line">    P((chopstick[i+1)%5])</span><br><span class="line">    //eating</span><br><span class="line">    V(choptick[i]);</span><br><span class="line">    V((chopstick[i+1)%5])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上有问题的，当每个哲学家都拿到其左边的筷子，这样死锁就产生了，具体将在下一节给出死锁的解决方案</p><p>参考：<a href="https://www.bilibili.com/video/BV1bf4y147PZ/?p=18">https://www.bilibili.com/video/BV1bf4y147PZ/?p=18</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;同步问题案例&quot;&gt;&lt;a href=&quot;#同步问题案例&quot; class=&quot;headerlink&quot; title=&quot;同步问题案例&quot;&gt;&lt;/a&gt;同步问题案例&lt;/h1&gt;&lt;h2 id=&quot;读者-写者问题&quot;&gt;&lt;a href=&quot;#读者-写者问题&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="oprating system" scheme="http://example.com/tags/oprating-system/"/>
    
  </entry>
  
  <entry>
    <title>Semaphores (信号量)</title>
    <link href="http://example.com/2024/10/23/8.Semaphores/"/>
    <id>http://example.com/2024/10/23/8.Semaphores/</id>
    <published>2024-10-23T13:58:45.998Z</published>
    <updated>2024-10-23T13:58:45.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Semaphores"><a href="#Semaphores" class="headerlink" title="Semaphores"></a>Semaphores</h1><p><img src="/img/oprating_system/Snipaste_2023-05-10_13-29-41.png"></p><p>注意：竞争属于协作，竞争是协作的特例，因此使用信号量可以解决竞争关系</p><h2 id="信号量与PV操作"><a href="#信号量与PV操作" class="headerlink" title="信号量与PV操作"></a>信号量与PV操作</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul><li>信号量（Semaphore）是一种比互斥锁更强大的同步工具，它可以提供更高级的方法来同步并发进程。</li><li>A semaphore S is an integer(整数) variable that, apart from  initialization, is accessed only through two standard  atomic operations: P (proberen(测试) in Dutch) and  V(verhogen(增加) in Dutch).<br>信号量 S 是一个整数变量，除了在初始化之外，信号量S被访问只能依靠两个<strong>原子操作</strong> P 和 V</li></ul><h3 id="信号量的实现"><a href="#信号量的实现" class="headerlink" title="信号量的实现"></a>信号量的实现</h3><p>伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">P(s)&#123;   <span class="comment">//测试信号量是否大于0，若大于0，执行自减操作</span></span><br><span class="line">    <span class="keyword">while</span>(s&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">do</span> nothing;</span><br><span class="line">    s--; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V(s)&#123;   <span class="comment">//使信号量增加</span></span><br><span class="line">    s++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h2><p>P V 操作必须成对出现</p><h3 id="BINARY-SEMAPHORE"><a href="#BINARY-SEMAPHORE" class="headerlink" title="BINARY SEMAPHORE"></a>BINARY SEMAPHORE</h3><ul><li>顾名思义，二值信号量的值只能是0或1，通常将其初始化为1，<strong>用于实现互斥锁的功能</strong>。</li></ul><p>伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">semphore mutex = <span class="number">1</span>;</span><br><span class="line">process p&#123;</span><br><span class="line">    p(mutex);            <span class="comment">//在 binary semaphore 中等价于 mutex 中的 lock</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    v(mutex);            <span class="comment">// unlock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="COUNTIING-SEMAPHORE"><a href="#COUNTIING-SEMAPHORE" class="headerlink" title="COUNTIING  SEMAPHORE"></a>COUNTIING  SEMAPHORE</h3><ul><li>计数信号量又称一般信号量，其取值可以是任意数值，用于控制并发 进程对共享资源的访问。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">semaphore road = <span class="number">2</span>;</span><br><span class="line">process Car&#123;</span><br><span class="line">    P(road);</span><br><span class="line">    <span class="comment">//pass the fork in road;</span></span><br><span class="line">    V(road);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/oprating_system/Snipaste_2023-05-10_14-40-07.png"></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><blockquote><p>要使用信号量，请先包含头文件 semaphore.h</p><p>sem_t：信号量的数据类型</p><p><code>int sem_init(sem_t *sem, int pshared, unsigned int  val); </code><br>该函数第一个参数为信号量指针，第二个参数为信号量 类型（一般设置为0），第三个为信号量初始值。第二 个参数<code>pshared</code>为0时，该进程内所有线程可用，不为0 时不同进程间可用。 </p><p><code>int sem_wait(sem_t *sem);</code><br>该函数申请一个信号量，当前无可用信号量则等待，有可用信号量时占用一个信号量，对信号量的值减1。(相当于 P 操作)</p><p><code>int sem_post(sem_t *sem); </code><br>该函数释放一个信号量，信号量的值加1。 (相当于 V 操作)</p><p><code>int sem_destory(sem_t *sem);</code><br>该函数用于销毁信号量</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tickAmount = <span class="number">2</span>;</span><br><span class="line"><span class="type">sem_t</span> sem;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">ticketAgent</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    sem_wait(&amp;sem);</span><br><span class="line">    <span class="type">int</span> t = tickAmount;</span><br><span class="line">    <span class="keyword">if</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;One ticket sold\n&quot;</span>);</span><br><span class="line">        t--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ticket sold out\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tickAmount = t;</span><br><span class="line">    sem_post(&amp;sem);</span><br><span class="line">    pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_init(&amp;sem,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="type">pthread_t</span> arr[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(arr+i,<span class="literal">NULL</span>,ticketAgent,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        pthread_join(arr[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_destroy(&amp;sem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/oprating_system/Snipaste_2023-05-10_16-31-45.png"></p><h2 id="信号量实现同步"><a href="#信号量实现同步" class="headerlink" title="信号量实现同步"></a>信号量实现同步</h2><ul><li>同步问题实质是将异步的并发进程按照某种顺序执行</li><li>解决同步的本质就是要找到并发进程的交互点，利用P操作的等待特点来调节进程的执行速度</li><li>通常初始值为0的信号量可以让进程直接进行等待状态，直到另一个进程唤醒他。</li></ul><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><ul><li>生产者(P)与消费者(C)共用一个缓冲区，生产者不能往 “满”的缓冲区中放产品，消费者不能从“空”的缓冲区中取产品。</li></ul><p><img src="/img/oprating_system/Snipaste_2023-05-10_17-15-28.png"></p><p>使用信号量实现：当开始执行时假定<code>BUFFER</code>为空，那么 P 可以执行 C 不能执行，显然有两个控制流，故需要两个信号量来实现同步，因为 C 在程序开始时要等待，故将控制 C 的信号量初始值设为 0，当<code>BUFFER</code>满时，P将不能工作(进入忙式等待)，等实现等待的只有 P操作 ，所以将控制 P 的信号量初始值设为 BUFFER 的大小，对 P 进程执行 P操作时会使得对应的信号量减1，之后要通知 C进程，使用 V(C进程的信号量)通知C进程，C进程在 P操作后会使信号量减1，之后要通知 P进程，V(P进程的信号量)</p><h4 id="单缓冲解决方案"><a href="#单缓冲解决方案" class="headerlink" title="单缓冲解决方案"></a>单缓冲解决方案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Semaphore empty = <span class="number">1</span>;</span><br><span class="line">Semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Producer&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//product;</span></span><br><span class="line">        P(empty);</span><br><span class="line">        <span class="comment">//pull the product into buffer</span></span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        P(full);</span><br><span class="line">        <span class="comment">//pick product from buffer</span></span><br><span class="line">        V(empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="THE-BOUNDED-BUFFER-有界缓冲区-PROBLEM"><a href="#THE-BOUNDED-BUFFER-有界缓冲区-PROBLEM" class="headerlink" title="THE BOUNDED-BUFFER(有界缓冲区) PROBLEM"></a>THE BOUNDED-BUFFER(有界缓冲区) PROBLEM</h4><p> <img src="/img/oprating_system/Snipaste_2023-05-10_19-07-54.png"></p><p>OUT：指向消费者使用的位置</p><p>IN：    指向生产者使用的位置</p><p>IN 与 OUT 形成了循环队列，IN 相当于队头（生产者生产后IN前移），OUT相对于队尾（消费者消费后OUT前移），保证 IN &gt;&#x3D; OUT 及生产者生产的大于消费者消费的 </p><p>伪代码： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">item B[k];</span><br><span class="line">semaphore empty = k;</span><br><span class="line">semaphore full = 0;</span><br><span class="line">semaphore mutex = 1;</span><br><span class="line">int in = 0 , out = 0;</span><br><span class="line">Process producer_i&#123;</span><br><span class="line">    make a product</span><br><span class="line">    P(empty);</span><br><span class="line">    P(mutex);</span><br><span class="line">    B[in] = product;     //存在共享数据的修改，加锁</span><br><span class="line">    in = (in + 1) % k;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(full);</span><br><span class="line">&#125;</span><br><span class="line">Process consumer_i&#123;</span><br><span class="line">    P(full);</span><br><span class="line">    P(mutex);</span><br><span class="line">    product = B[out];     //存在共享数据的修改，加锁</span><br><span class="line">    out = (out + 1) % k;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(empty);</span><br><span class="line">    consume a product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>empty 和 full 的 PV 操作并不在同一进程中，称为同步信号量</li><li>mutex 的 PV操作在同一进程中，称为互斥信号量</li></ul><h3 id="苹果橘子问题"><a href="#苹果橘子问题" class="headerlink" title="苹果橘子问题"></a>苹果橘子问题</h3><p>问题描述：</p><blockquote><p>桌上有一只盘子，每次只能放入一只水果</p><p>爸爸专向盘子中放苹果，妈妈专向盘子中放桔子</p><p>儿子专等吃盘子中的桔子，女儿专等吃盘子里的苹果</p></blockquote><p>这里爸爸 妈妈 相当于时生产者，儿子 女儿相当于是消费者</p><p>father 和 mother 是竞争关系，竞争盘子</p><p>father 和 daughter 是协作关系</p><p>mother 和 sun 是协作关系</p><p>伪代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">semaphore sp = 1;        //盘子里允许放一个水果，竞争关系</span><br><span class="line">semaphore sg1 = 0;       //盘子里没有橘子</span><br><span class="line">semaphore sg2 = 0;       //盘子里没有苹果</span><br><span class="line"></span><br><span class="line">Process father &#123; </span><br><span class="line">削⼀个苹果；</span><br><span class="line"> P(sp);      //占用盘子</span><br><span class="line"> V(sg2);     //把苹果放⼊plate；通知儿子</span><br><span class="line">&#125; </span><br><span class="line">Process mother &#123; </span><br><span class="line">剥⼀个桔⼦；</span><br><span class="line"> P(sp); </span><br><span class="line"> V(sg1);     //把桔⼦放⼊plate；通知女儿</span><br><span class="line">&#125;</span><br><span class="line">Process daughter &#123; </span><br><span class="line"> P(sg2); </span><br><span class="line"> 从plate中取苹果；</span><br><span class="line"> V(sp); </span><br><span class="line">吃苹果；通知生产者可以继续生产了</span><br><span class="line">&#125;</span><br><span class="line">Process son &#123; </span><br><span class="line"> P(sg1); </span><br><span class="line"> 从plate中取桔⼦；</span><br><span class="line"> V(sp); </span><br><span class="line">吃桔⼦；通知生产者可以继续生产了</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>其本质还是生产者消费者模型</p><p>生产者消费者：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 10</span></span><br><span class="line"><span class="type">sem_t</span> sem_empty;           <span class="comment">//生产者所使用的</span></span><br><span class="line"><span class="type">sem_t</span> sem_full;            <span class="comment">//消费者所使用的</span></span><br><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>;  <span class="comment">//表示队列中生产者生产的内存</span></span><br><span class="line"><span class="type">int</span> out = <span class="number">0</span>; <span class="comment">//表示队列中要消费的内容</span></span><br><span class="line"><span class="type">int</span> arr[BUFSIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">prodecer</span><span class="params">(<span class="type">void</span>* arg)</span>  <span class="comment">//生产者线程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;sem_empty);</span><br><span class="line"></span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        arr[in] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;prodecer : %d\n&quot;</span>, in);</span><br><span class="line">        in = (in + <span class="number">1</span>) % BUFSIZE;</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        sem_post(&amp;sem_full);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span>  <span class="comment">//消费者线程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;consumer -------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;sem_full);</span><br><span class="line"></span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;consumer: %d\n&quot;</span>, out);</span><br><span class="line">        out = (out + <span class="number">1</span>) % BUFSIZE;</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        sem_post(&amp;sem_empty);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_init(&amp;sem_empty,<span class="number">0</span>,BUFSIZE);</span><br><span class="line">    <span class="comment">//初始值是BUFSIZE保证了环形队列不会出现尾指针越过头指针的情况发生</span></span><br><span class="line">    sem_init(&amp;sem_full,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> pro[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pthread_t</span> con[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) &#123;</span><br><span class="line">        pthread_create(pro + i, <span class="literal">NULL</span>, prodecer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(con + i, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        pthread_join(con[i],<span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(pro[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;sem_empty);</span><br><span class="line">    sem_destroy(&amp;sem_full);</span><br><span class="line">    sem_destroy(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>苹果橘子问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">plate</span>&#123;</span>apple = <span class="number">1</span>, origen&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sp;   <span class="comment">//父母竞争盘子</span></span><br><span class="line"><span class="type">sem_t</span> sp1;  <span class="comment">//父亲通知女儿</span></span><br><span class="line"><span class="type">sem_t</span> sp2;   <span class="comment">//母亲通知儿子</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">plate</span> <span class="title">plate</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">father</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;sp);</span><br><span class="line">    plate = apple;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father\n&quot;</span>);</span><br><span class="line">    sem_post(&amp;sp1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mother</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;sp);</span><br><span class="line">    plate = origen;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mother\n&quot;</span>);</span><br><span class="line">    sem_post(&amp;sp2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">son</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;sp1);</span><br><span class="line">    plate = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;son\n&quot;</span>);</span><br><span class="line">    sem_post(&amp;sp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">daughter</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;sp2);</span><br><span class="line">    plate = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;daughrer\n&quot;</span>);</span><br><span class="line">    sem_post(&amp;sp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_init(&amp;sp,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;sp1,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;sp2,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> arr1[<span class="number">10</span>] ;</span><br><span class="line">    <span class="type">pthread_t</span> arr2[<span class="number">10</span>] ;</span><br><span class="line">    <span class="type">pthread_t</span> arr3[<span class="number">10</span>] ;</span><br><span class="line">    <span class="type">pthread_t</span> arr4[<span class="number">10</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        pthread_create(arr1+i,<span class="literal">NULL</span>,father,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(arr2+i,<span class="literal">NULL</span>,mother,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(arr3+i,<span class="literal">NULL</span>,son,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(arr4+i,<span class="literal">NULL</span>,daughter,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        pthread_join(arr1[i],<span class="literal">NULL</span>) ;</span><br><span class="line">        pthread_join(arr2[i],<span class="literal">NULL</span>) ;</span><br><span class="line">        pthread_join(arr3[i],<span class="literal">NULL</span>) ;</span><br><span class="line">        pthread_join(arr4[i],<span class="literal">NULL</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;sp);</span><br><span class="line">    sem_destroy(&amp;sp1);</span><br><span class="line">    sem_destroy(&amp;sp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：信号量上下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Semaphores&quot;&gt;&lt;a href=&quot;#Semaphores&quot; class=&quot;headerlink&quot; title=&quot;Semaphores&quot;&gt;&lt;/a&gt;Semaphores&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/img/oprating_system/Snipast</summary>
      
    
    
    
    
    <category term="oprating system" scheme="http://example.com/tags/oprating-system/"/>
    
  </entry>
  
  <entry>
    <title>决胜网络协议</title>
    <link href="http://example.com/2024/07/20/%E5%86%B3%E8%83%9C%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2024/07/20/%E5%86%B3%E8%83%9C%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</id>
    <published>2024-07-19T16:00:00.000Z</published>
    <updated>2024-07-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序列号回绕"><a href="#序列号回绕" class="headerlink" title="序列号回绕"></a>序列号回绕</h3><p>我们这里假设只有 8位 用来描述<code> tcp</code> 的序列号</p><p>seq1 &#x3D; 255      seq2 &#x3D; 1</p><p>使用减法来判断包的先后顺序 ，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">before</span><span class="params">(__u32 seq1, __u32 seq2)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> (__s32)(seq1-seq2) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> after(seq2, seq1) before(seq1, seq2)</span></span><br></pre></td></tr></table></figure><p>这里就变为了 before(0b1111 , 0b1) -&gt; return 0b1110 &lt; 0 ， 采用了无符号数减法转化为有符号数来粗略的判断，当seq1 和 seq2之间的间距 大于 0xc000 时就无法判断了，就需要使用额外的东西来判断如时间戳</p><h3 id="窗口缩放"><a href="#窗口缩放" class="headerlink" title="窗口缩放"></a>窗口缩放</h3><p>tcp头部中指定了窗口大小，使用了16位，这意味着最大窗口位 64k，由于现代网络传输速度的加快，64k有时不能满足要求，于是在这上面打了补丁也就有了窗口缩放，用窗口大小乘缩放因子得到时机的窗口大小，缩放因子是在三次握手中协商的，如下报文</p><p><img src="/img/Snipaste_2024-07-10_20-12-53.png"></p><p>这里的缩放因子是 256 也就是实际的窗口大小为 516 * 256</p><h4 id="tcp的重要选项"><a href="#tcp的重要选项" class="headerlink" title="tcp的重要选项"></a>tcp的重要选项</h4><p> 在 <code>tcp</code>头部中选项和填充属于可选字段，但也有相当重要的</p><p>MSS: 最大段大小选项 , TCP 允许的从对方接收的最大报文段<br>SACK: 选择确定选项<br>Window Scale: 窗口缩放选项</p><h3 id="临时端口的分配"><a href="#临时端口的分配" class="headerlink" title="临时端口的分配"></a>临时端口的分配</h3><p> 在没有调用 bind 或者 bind 指定的端口号为 0 的时候会采用临时端口号</p><p>tcp协议栈用三个全局的 <code>inet_hash</code> 哈希表</p><ul><li>ehash: 负责有名的 socket，也就是四元组明确的 socket ， key 是源地址 源端口 目的地址 目的端口组成的 ， value 是对应的socket</li><li>bhash: 负责端口分配，key是端口号，value 是使用此端口的所有socket，一个socket 可同时在bhash 和 ehash 中使用</li><li>listening_hash: 负责 listen socket</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_hashinfo</span> &#123;</span></span><br><span class="line"><span class="comment">/* This is for sockets with full identity only.  Sockets here will</span></span><br><span class="line"><span class="comment"> * always be without wildcards and will have the following invariant:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          TCP_ESTABLISHED &lt;= sk-&gt;sk_state &lt; TCP_CLOSE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_ehash_bucket</span>*<span class="title">ehash</span>;</span></span><br><span class="line"><span class="type">spinlock_t</span>*ehash_locks;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>ehash_mask;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>ehash_locks_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ok, let&#x27;s try this, I give up, we do need a local binding</span></span><br><span class="line"><span class="comment"> * TCP hash as well as the others for fast bind/connect.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span>*<span class="title">bind_bucket_cachep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_hashbucket</span>*<span class="title">bhash</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>bhash_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The 2nd listener table hashed by local port and address */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>lhash2_mask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_listen_hashbucket</span>*<span class="title">lhash2</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>inet_ehash_bucket</code> 说是哈希表，实际就是一个数组，数组的每一个元素都是一个 <code>inet_bind_hashbuchet</code> 指针,chain 字段是一个链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_ehash_bucket</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_head</span> <span class="title">chain</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_hashbucket</span> &#123;</span></span><br><span class="line"><span class="type">spinlock_t</span>lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span><span class="title">chain</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_listen_hashbucket</span> &#123;</span></span><br><span class="line"><span class="type">spinlock_t</span>lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_head</span><span class="title">nulls_head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>bind(0) 分配端口：</p><p><img src="/img/Snipaste_2024-07-11_11-50-02.png"></p><p><img src="/img/Snipaste_2024-07-11_14-06-37.png"></p><p>connect 分配端口：</p><p>首先要分配端口，与 bind(0) 不同的是 <code>offset &amp;= ~1</code>，将offset 强制变为偶数之后与low相加检测bhash中是否有相同的 ，之后判断端口是否可用</p><p>对应 bind 端口为 0 时 ，所分配的临时端口是奇数，对应没有 bind 直接 connect ，所分配的端口是偶数</p><blockquote><p>高版本内核临时端口分配策略</p><p>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_local_port_range 文件指定了临时端口号的下界 low 和 上界 high，默认情况下 low 是偶数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@bool:~# cat /proc/sys/net/ipv4/ip_local_port_range </span><br><span class="line">3276860999</span><br></pre></td></tr></table></figure><ul><li>优先给 bind(0) 分配随机的与low奇偶性不同的端口，也就是奇数，如果奇数端口号分配完了才需要尝试分配偶数端口</li><li>优先给 connect 分配随机的与low奇偶性相同的端口，也就是偶数</li></ul></blockquote><p>协议栈端口选择导致的性能衰减：当客户端疯狂 connect 时，1w并发连接和2w并发连接的耗时完全无线性关系，而是呈现一种近指数上升的趋势。例如，1w并发链接建连1w次，耗时不到1s，如果改为2w并发链接，建连2w次，耗时突然变成了10+s。当我们完全占用偶数组的端口后，所有后续的<code>connect</code>调用，所需的源端口应该位于奇数组中，然而该函数依旧会尝试完整遍历偶数组资源，这也就是<code>__inet_check_established</code>耗时占比这么高的原因。简而言之，就是自kernel 4.2开始，端口资源的分配策略改了，目前奇数端口留给<code>bind</code>，偶数端口留给<code>connect</code>为了均衡资源的占用，但是显然，这种策略不适合本文所述的特殊场景，并且对于<code>bind</code>而言，也存在性能衰减的问题。</p><p>为什么 SYN &#x2F; FIN段不携带数据却要消耗一个序列号？</p><ul><li>不占用序列号的段是不需要确认的，比如纯 ACK 包</li><li>SYN 段需要双方确认，需要占用一个序列号，若不进行确认，对端将无法辨别所发出的 SYN 是否已经被收到</li><li>凡是消耗序列号的 TCP 报文段，一定需要对端确认。如果这个段没有收到确认，会一直重传直到达到指定的次数为至</li></ul><h3 id="三次握手冷知识"><a href="#三次握手冷知识" class="headerlink" title="三次握手冷知识"></a>三次握手冷知识</h3><p>通信双方都知道对端开发的端口，同时调用 connect ， 发送 syn 包，双方进入 SYN_SEND 状态，接收到对端传来的 SYN 时进入 SYN_REVD ， 发送 SYN ACK ， 进入 ESTABLISH</p><p><img src="/img/Snipaste_2024-07-12_14-06-24.png"></p><p>TCP 自连接：</p><p>当我们执行这段脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while ture</span><br><span class="line">do </span><br><span class="line">telnet 127.0.0.1 50000</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>过一段时间会出现</p><p><img src="/img/Snipaste_2024-07-12_14-19-31.png"></p><p>原理：</p><p><img src="/img/Snipaste_2024-07-12_14-23-25.png"></p><p>自连接的危害：</p><p>存在业务系统 B会访问本机服务 A ， 服务A监听了 50000 端口</p><ol><li>业务系统B代码中增加了对服务A断开重连的逻辑</li><li>如果有一个服务A挂掉长时间没有启动，业务系统B开始不断的 connect</li><li>系统B经过一段时间的重试就会出现自连接的情况</li><li>这是服务A想要监听50000断开就会出现断开被占用的情况</li></ol><p>自连接的进程占用了端口，导致真正需要监听端口的服务程序无法正常启动，自连接的进程开启了connect成功了，实际上服务是不正常的，无法正常进行数据通信</p><h3 id="四次挥手中的同时关闭"><a href="#四次挥手中的同时关闭" class="headerlink" title="四次挥手中的同时关闭"></a>四次挥手中的同时关闭</h3><p><img src="/img/Snipaste_2024-07-13_00-01-43.png"></p><h3 id="两个队列"><a href="#两个队列" class="headerlink" title="两个队列"></a>两个队列</h3><p>半连接队列(Incomplete connection queue), 又称 SYN 队列<br>全连接队列(Completed connection queue), 又称 Accept 队列</p><p>当客户端发起 SYN 到服务端，服务端收到以后会回 ACK 和⾃⼰的 SYN。这时服务端这边的 TCP 从 listen 状态变为 SYN_RCVD (SYN  Received)，此时会将这个连接信息放⼊半连接队列</p><p><code>int listen(int fd , int backlog)</code></p><p>TCP套接字上的backlog参数的行为在Linux 2.2中发生了变化。现在，它指定等待接受的完全建立的套接字的队列长度，而不是不完整连接请求的数量。不完整套接字队列的最大长度可以使用 <code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code> 设置。当启用同步cookie时，没有逻辑上的最大长度，此设置将被忽略。</p><p>如果backlog参数大于 <code>/proc/sys/net/core/somaxconn</code> 中的值，那么它将被静默地截断为该值。自Linux 5.4以来，此文件中的默认值为4096</p><p>半连接队列的大小和传入的 backlog ， 系统参数 <code>somaxconn</code> ,<code>max_syn_backlog</code> 都有关系，通过其中最小值用于计算，盲目的调大backlog 对最终半连接队列的大小可能不会有影响</p><p>全连接队列包含了服务端所有完成了三次握⼿，但是还未被应⽤取⾛的连接队列。此时的 socket 处于 ESTABLISHED 状态。每次应⽤调⽤ accept() 函数会移除队列头的连接。如果队列为空， accept() 通常会阻塞。全连接队列也被称为 Accept 队列。</p><p>半连接队列满了以后会忽略 SYN<br>全连接队列满了之后会忽略客户端的 ACK，随后重传 SYN + ACK，可以通过 <code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code> 决定</p><ul><li><code>tcp_abort_on_overflow</code> 为 0 表示三次握⼿最后⼀步全连接队列满以后 server 会丢掉 client 发过来的 ACK，服务端随后会进⾏重传 SYN+ACK。</li><li><code>tcp_abort_on_overflow</code> 为 1 表示全连接队列满以后服务端直接 发送 RST 给客户端。</li></ul><p>但是回给客户端 RST 包会带来另外⼀个问题，客户端不知道服务端 响应的 RST 包到底是因为「该端⼝没有进程监听」，还是「该端⼝ 有进程监听，只是它的队列满了」。</p><h3 id="TCP的定时器"><a href="#TCP的定时器" class="headerlink" title="TCP的定时器"></a>TCP的定时器</h3><p><code>tcp</code> 为每条连接建立了 7 个定时器：连接建立定时器，重传定时器，延迟ACK定时器，PERSIST定时器，KEEPALIVE定时器，FINWAIT2定时器，TIME_WAIT定时器 </p><p>Persist 定时器是专⻔为零窗⼝探测⽽准备的。我们都知道 TCP 利⽤滑动窗⼝来实现流量控制，当接收端 B 接收窗⼝为 0 时，发送端 A 此时不 能再发送数据，发送端此时开启 Persist 定时器，超时后发送⼀个特殊的报⽂给接收端看对⽅窗⼝是否已经恢复，这个特殊的报⽂只有⼀个字节。</p><p>四次挥⼿过程中，主动关闭的⼀⽅收到 ACK 以后从 FINWAIT1 进⼊ FINWAIT2 状态等待对端的 FIN 包的到来，FINWAIT2 定时器的作 ⽤是防⽌对⽅⼀直不发送 FIN 包，防⽌⾃⼰⼀直傻等。这个值由 <code>/proc/sys/net/ipv4/tcp_fin_timeout</code> 决定，默认值为 60s</p><p>TIMEWAIT 定时器也称为 2MSL 定时器，可主动关闭连接的⼀⽅在 TIMEWAIT 持续 2 个 MSL 的时间，超时后端⼝号可被安全的重⽤。</p><h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><p>tcp 拥塞控制四大阶段：慢启动 ， 拥塞避免 ， 快速重传 ， 快速恢复</p><p>在连接建⽴之初，你不知道对端有多快，如果有⾜够的带宽，你可以选择⽤最快的速度传输数据，但是如果 是⼀个缓慢的移动⽹络呢？如果发送的数据过多，只是造成更⼤的⽹络延迟。这是基于整 个考虑，每个 TCP 连接都有⼀个拥塞窗⼜的限制，最初这个值很⼩，随着时间的推移， 每次发送的数据量如果在不丢包的情况下，慢慢的递增，这种机制被称为「慢启动」</p><blockquote><p> 第⼀步，三次握⼿以后，双⽅通过 ACK 告诉了对⽅ ⾃⼰的接收窗⼜（rwnd）的⼤⼩，之后就可以互相发 数据了</p><p>第⼆步，通信双⽅各⾃初始化⾃⼰的「拥塞窗⼜」 （Congestion Window，cwnd）⼤⼩</p><p>第三步，cwnd 初始值较⼩时，每收到⼀个 ACK， cwnd + 1，每经过⼀个 RTT，cwnd 变为之前的两 倍。</p></blockquote><p><img src="/img/Snipaste_2024-07-20_14-58-22.png"></p><p>慢启动拥塞窗口（cwnd）肯定不能⽆⽌境的指数级增长下去，否则拥塞控制就变成了「拥塞失控」了，它的阈值称为「慢启动阈值」（Slow Start  Threshold，ssthresh）。<code>ssthresh</code> 就是⼀道刹车，让拥塞窗⼜别涨那么快</p><ul><li>当 cwnd &lt; ssthresh 时，拥塞窗⼜按指数级增长（慢启动）</li><li>当 cwnd &gt; ssthresh 时，拥塞窗⼜按线性增长（拥塞避免），在这个阶段，每⼀ 个往返 RTT，拥塞窗⼜⼤约增加 1 个 MSS ⼤⼩，直到检测到拥塞为⽌</li></ul><p>当收到三次重复 ACK 时，进⼊快速恢复阶段。解释为⽹络轻度拥塞。</p><ul><li>拥塞阈值 ssthresh 降低为 cwnd 的⼀半：ssthresh &#x3D; cwnd &#x2F; 2</li><li>拥塞窗⼜ cwnd 设置为 ssthresh</li><li>拥塞窗⼜线性增加</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;序列号回绕&quot;&gt;&lt;a href=&quot;#序列号回绕&quot; class=&quot;headerlink&quot; title=&quot;序列号回绕&quot;&gt;&lt;/a&gt;序列号回绕&lt;/h3&gt;&lt;p&gt;我们这里假设只有 8位 用来描述&lt;code&gt; tcp&lt;/code&gt; 的序列号&lt;/p&gt;
&lt;p&gt;seq1 &amp;#x3D; </summary>
      
    
    
    
    
    <category term="网络编程" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="read" scheme="http://example.com/tags/read/"/>
    
  </entry>
  
  <entry>
    <title>CAS 与 无锁队列</title>
    <link href="http://example.com/2024/07/02/10.1%20cas/"/>
    <id>http://example.com/2024/07/02/10.1%20cas/</id>
    <published>2024-07-01T16:00:00.000Z</published>
    <updated>2024-07-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAS-与-无锁队列"><a href="#CAS-与-无锁队列" class="headerlink" title="CAS 与 无锁队列"></a>CAS 与 无锁队列</h1><p>假设我们有一全局变量 idx ， 在执行 idx++ 时编译器会翻译为三条汇编指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov [idx] , %eax</span><br><span class="line">inc %eax</span><br><span class="line">mov %eax , [idx]</span><br></pre></td></tr></table></figure><p>当三条汇编语句紧挨着执行时，idx++ 是保证正确的，但是当存在多个线程时 idx++ 的正确性就有待考证了如：</p><table><thead><tr><th>线程一</th><th>线程二</th></tr></thead><tbody><tr><td>mov [idx] , %eax</td><td></td></tr><tr><td>inc  %eax</td><td></td></tr><tr><td></td><td>mov [idx] , %eax</td></tr><tr><td></td><td>inc %eax</td></tr><tr><td></td><td>mov %eax , [idx]</td></tr><tr><td>mov %eax , [idx]</td><td></td></tr></tbody></table><p>当线程一和线程二按照这样的方式执行时，虽然在各自的线程中都执行了 idx++ 但是 idx 的结果只增加了一次 , 解决的方法可以是为临界区代码段添加互斥锁或自旋锁，对于互斥锁：当资源已被加锁时将会切换线程而自旋锁不会，自旋锁将在此线程上一直等待直到资源可用为止，二者的选择需要从资源的竞争程度与线程切换的开销方面考虑，这并不是这篇文章的重点，我们要写一个大多数人未知的东西(至少我是这样的)<strong>原子操作</strong></p><h2 id="汇编实现原子操作："><a href="#汇编实现原子操作：" class="headerlink" title="汇编实现原子操作："></a>汇编实现原子操作：</h2><p>“最轻量级的锁”,通常也叫”原子操作”,之所以加引号是因为他们在汇编级别并不是原子操作,是用多条指令完成的,这些操作大多都是利用CPU支持的汇编指令</p><p>最常见的原子操作有Compare and Exchange,Self Increase&#x2F;Decrease等等</p><p><strong>80486 CPU 相关指令：</strong></p><blockquote><p>LOCK:这是一个指令前缀，在所对应的指令操作期间使此指令的<strong>目标操作数指定的存储区域锁定</strong>，以得到保护。</p><p>XADD:先交换两个操作数的值，再进行算术加法操作。多处理器安全，在80486及以上CPU中支持。</p><p>CMPXCHG:比较交换指令，第一操作数先和AL&#x2F;AX&#x2F;EAX比较，如果相等ZF置1，第二操作数赋给第一操作数，否则ZF清0，第一操作数赋给AL&#x2F;AX&#x2F;EAX。多处理器安全，在80486及以上CPU中支持。</p><p>XCHG:交换两个操作数,其中至少有一个是寄存器寻址.其他寄存器和标志位不受影响.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Dump of assembler code for function _Z3incPii:</span></span><br><span class="line"><span class="comment">   0x0000555555555229 &lt;+0&gt;:     endbr64 </span></span><br><span class="line"><span class="comment">   0x000055555555522d &lt;+4&gt;:     push   %rbp</span></span><br><span class="line"><span class="comment">   0x000055555555522e &lt;+5&gt;:     mov    %rsp,%rbp</span></span><br><span class="line"><span class="comment">   0x0000555555555231 &lt;+8&gt;:     mov    %rdi,-0x18(%rbp)</span></span><br><span class="line"><span class="comment">   0x0000555555555235 &lt;+12&gt;:    mov    %esi,-0x1c(%rbp)</span></span><br><span class="line"><span class="comment">   0x0000555555555238 &lt;+15&gt;:    mov    -0x18(%rbp),%rdx</span></span><br><span class="line"><span class="comment">   0x000055555555523c &lt;+19&gt;:    mov    -0x1c(%rbp),%eax</span></span><br><span class="line"><span class="comment">   0x000055555555523f &lt;+22&gt;:    lock xadd %eax,(%rdx)</span></span><br><span class="line"><span class="comment">   0x0000555555555243 &lt;+26&gt;:    mov    %eax,-0x4(%rbp)</span></span><br><span class="line"><span class="comment">   0x0000555555555246 &lt;+29&gt;:    mov    -0x4(%rbp),%eax</span></span><br><span class="line"><span class="comment">   0x0000555555555249 &lt;+32&gt;:    pop    %rbp</span></span><br><span class="line"><span class="comment">   0x000055555555524a &lt;+33&gt;:    ret </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inc</span><span class="params">(<span class="type">int</span> *value , <span class="type">int</span> add)</span> &#123;</span><br><span class="line">    <span class="type">int</span> old;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;lock; xaddl %2 , %1&quot;</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=a&quot;</span> (old)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;m&quot;</span> (*value) , <span class="string">&quot;a&quot;</span> (add)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;cc&quot;</span> , <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在c++中<code>atomic</code>类提供了 <code>cas</code> 原子操作的方法如比较交互<code>std::atomic&lt;T&gt;::compare_exchange_strong</code></p><h2 id="cpu-亲和性"><a href="#cpu-亲和性" class="headerlink" title="cpu 亲和性"></a>cpu 亲和性</h2><p><strong>硬亲和性（affinity）：</strong>简单来说就是利用 <code>linux</code> 内核提供给用户的 <code>API</code>，强行将进程或者线程绑定到某一个指定的 <code>cpu</code> 核运行。</p><p>在 Linux 内核中，所有的进程都有一个相关的数据结构，称为 <code>task_struct</code> <em>。</em>这个结构非常重要，原因有很多；其中与亲和性（affinity）相关度最高的是 <code>cpus_allowed</code> 位掩码。这个位掩码由<code> n</code> 位组成，与系统中的<code>n</code>个逻辑处理器一一对应。 具有 4 个物理 CPU 的系统可以有 4 位。如果这些 CPU 都启用了超线程，那么这个系统就有一个 8 位的位掩码。</p><p>如果为给定的进程设置了给定的位，那么这个进程就可以在相关的 <code>CPU</code> 上运行。因此，如果一个进程可以在任何 <code>CPU</code> 上运行，并且能够根据需要在处理器之间进行迁移，那么位掩码就全是 1。实际上，这就是 Linux 中进程的缺省状态。</p><p>Linux 内核 API 提供了一些方法，让用户可以修改位掩码或查看当前的位掩码：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">#<span class="keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">sched_setaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> cpusetsize , <span class="type">const</span> <span class="type">cpu_set_t</span> *mask)</span>;</span><br><span class="line"><span class="comment">/*sched_setaffinity（）将ID为pid的线程的CPU关联掩码设置为掩码指定的值。  </span></span><br><span class="line"><span class="comment">如果pid为零，则使用调用线程。  参数cpusetsize是掩码指向的数据的长度（字节）。  通常这个参数会被指定为sizeof（cpu_set_t）。*/</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">sched_getaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> cpusetsize , <span class="type">cpu_set_t</span> *mask)</span>;</span><br><span class="line"><span class="comment">/*sched_getaffinity（）将ID为pid的线程的关联掩码写入掩码指向的cpu_set_t结构中。   cpusetsize参数指定掩码的大小（以字节为单位）。  如果pid为零，则返回调用线程的掩码。*/</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_affinity</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;                <span class="comment">// 设置进程 cpu 亲和性</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> tid = <span class="built_in">syscall</span>(__NR_gettid);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;tid : &quot;</span> &lt;&lt; tid &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">cpu_set_t</span> mask;</span><br><span class="line">    <span class="built_in">CPU_ZERO</span>(&amp;mask);</span><br><span class="line">    <span class="built_in">CPU_SET</span>(tid % num , &amp;mask);</span><br><span class="line">    <span class="built_in">sched_setaffinity</span>(tid , <span class="keyword">sizeof</span> mask , &amp;mask);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置了进程的亲和性并不保证进程中创建的新线程在此cpu上运行，只能保证进程中的主线程在cpu上运行</span></span><br><span class="line"><span class="comment">// 本质就是 gettid，在对应cpu上执行对应 tid 的执行流</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_affinity</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;                <span class="comment">// 设置线程 cpu 亲和性</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;tid : &quot;</span> &lt;&lt; tid &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">cpu_set_t</span> mask;</span><br><span class="line">    <span class="built_in">CPU_ZERO</span>(&amp;mask);</span><br><span class="line">    <span class="built_in">CPU_SET</span>(tid % num , &amp;mask);</span><br><span class="line">    <span class="built_in">pthread_setaffinity_np</span>(<span class="built_in">pthread_self</span>() , <span class="keyword">sizeof</span> mask , &amp;mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process_affinity</span>(num);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">sysconf</span>(_SC_NPROCESSORS_CONF);</span><br><span class="line">    std::cout &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;num/<span class="number">2</span> ; ++i) &#123;</span><br><span class="line">        <span class="function">std::thread <span class="title">t</span><span class="params">(func , num)</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">1000000000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>htop</code> 可以看到在 <code>usleep</code> 结束之前有两个 cpu 的占用率是 100% 而其他线程占用几乎为 0，这说明两个线程分别绑定到了两个逻辑核心上</p><p>补充:</p><blockquote><p><code>main</code> 函数结束后相当于调用 <code>exit</code> ，这将导致整个进程结束，意味着其他线程如 detach 后的线程也跟着结束，由于这里尝试多次没有看到希望的效果，当然也可以使用 <code>posix_exit()</code> 令主线程退出，而不影响其他线程</p></blockquote><h2 id="无锁队列-zeromq"><a href="#无锁队列-zeromq" class="headerlink" title="无锁队列(zeromq)"></a>无锁队列(zeromq)</h2><h3 id="为什么需要无锁队列："><a href="#为什么需要无锁队列：" class="headerlink" title="为什么需要无锁队列："></a>为什么需要无锁队列：</h3><blockquote><p>Cache 损坏<br>拿互斥锁来说，采用休眠等待，线程被频繁抢占产生的Cache损坏将导致应用程序性能下降。</p><p>在同步机制上的争抢队列<br>由于锁机制，当资源争取发生的频率很高时，任务将大量的时间 (睡眠，等待，唤醒)浪费在获得保护队列数据的互斥锁，而不是处理队列中的数据上。</p><p>动态内存分配<br>当一个任务从堆中分配内存时，标准的内存分配机制会 阻塞所有与这个任务共享地址空间的其它任务(进程中的所有线程)</p></blockquote><h3 id="提供的原子操作"><a href="#提供的原子操作" class="headerlink" title="提供的原子操作"></a>提供的原子操作</h3><p><code>atom_op.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CAS(a_ptr, a_oldVal, a_newVal) __sync_bool_compare_and_swap(a_ptr, a_oldVal, a_newVal)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AtomicAdd(a_ptr,a_count) __sync_fetch_and_add (a_ptr, a_count)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AtomicSub(a_ptr,a_count) __sync_fetch_and_sub (a_ptr, a_count)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span> <span class="comment">// sched_yield()</span></span></span><br><span class="line"></span><br><span class="line">对应函数原型：</span><br><span class="line"><span class="type">bool</span> __sync_bool_compare_and_swap (T* __p， U __compVal， V __exchVal， ...);</span><br><span class="line">此函数将 __compVal 的值与 __p 指向的变量的值进行比较。 如果它们相等，那么 __exchVal 的值将存储在 __p指定的地址中; 否则，不会执行任何操作,如果 __compVal 的值与 __p 指向的变量的值相等，那么该函数返回 <span class="literal">true</span>; 否则，返回 <span class="literal">false</span>。</span><br><span class="line">T __sync_fetch_and_add ( T * __p , U __v , ...);</span><br><span class="line">该函数以原子方式将__v的值添加到__p指向的变量中。结果存储在__p指定的地址中，该函数返回__p指向的变量的初始值。</span><br></pre></td></tr></table></figure><p><code>atomic_ptr.hpp</code> 中对模板类型参数T的指针提供了原子操作，那其中一条进行分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> T *<span class="title function_">cas</span> <span class="params">(T *cmp_, T *val_)</span>    <span class="comment">// if(cmp == ptr) 则 ptr=val 返回旧值 ， 不相等直接返回ptr</span></span><br><span class="line">&#123;</span><br><span class="line">T *old;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;lock; cmpxchg %2, %3&quot;</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=a&quot;</span> (old), <span class="string">&quot;=m&quot;</span> (ptr)<span class="comment">// 输出操作数：old绑定到EAX寄存器，ptr绑定到内存位置</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;r&quot;</span> (val_), <span class="string">&quot;m&quot;</span> (ptr), <span class="string">&quot;0&quot;</span> (cmp_) <span class="comment">// 输入操作数：val_可以使用任意寄存器，ptr绑定到内存位置，cmp_绑定到EAX寄存器</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;cc&quot;</span>)</span>;   <span class="comment">// 声明修改条件码寄存器</span></span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line"><span class="keyword">volatile</span> T *ptr;</span><br></pre></td></tr></table></figure><h3 id="无锁队列的实现（单读单写）"><a href="#无锁队列的实现（单读单写）" class="headerlink" title="无锁队列的实现（单读单写）"></a>无锁队列的实现（单读单写）</h3><p><strong>yqueue 数据结构</strong></p><p>yqueue是一种高效的队列实现。 主要目标是最大限度地减少所需的分配&#x2F;解除分配次数。 因此，yqueue以N批为单位分配&#x2F;解除分配元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">yqueue_t</span>;</span><br></pre></td></tr></table></figure><p>yqueue 内部是由一个个 chunk_t 组成的，使用双向链表的数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">chunk_t</span></span><br><span class="line">&#123;</span><br><span class="line">    T values[N]; <span class="comment">//每个chunk_t可以容纳N个T类型的元素，以后就以一个chunk_t为单位申请内存</span></span><br><span class="line">    <span class="type">chunk_t</span> *prev;</span><br><span class="line">    <span class="type">chunk_t</span> *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>chunk_t的组织方式</p><p><img src="/img/%E4%BB%8E0%E5%88%B01/Snipaste_2024-06-30_00-50-29.png"></p><p><strong>ypipe</strong></p><p>ypipe_t在yqueue_t的基础上构建一个单写单读的无锁队列</p><p>ypipe内维护的成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">yqueue_t</span>&lt;T, N&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Points to the first un-flushed item. This variable is used</span></span><br><span class="line">    <span class="comment">//  exclusively by writer thread.</span></span><br><span class="line">    T *w; <span class="comment">//指向第一个未刷新的元素,只被写线程使用  要从哪里刷</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Points to the first un-prefetched item. This variable is used</span></span><br><span class="line">    <span class="comment">//  exclusively by reader thread.</span></span><br><span class="line">    T *r; <span class="comment">//指向第一个还没预提取的元素，只被读线程使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Points to the first item to be flushed in the future.</span></span><br><span class="line">    T *f; <span class="comment">//指向下一轮要被刷新的一批元素中的第一个  要刷到哪里</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  The single point of contention between writer and reader thread.</span></span><br><span class="line">    <span class="comment">//  Points past the last flushed item. If it is NULL,</span></span><br><span class="line">    <span class="comment">//  reader is asleep. This pointer should be always accessed using</span></span><br><span class="line">    <span class="comment">//  atomic operations.</span></span><br><span class="line">    <span class="type">atomic_ptr_t</span>&lt;T&gt; c; <span class="comment">//读写线程共享的指针，指向每一轮刷新的起点。当c为空时，表示读线程睡眠（只会在读线程中被设置为空）</span></span><br></pre></td></tr></table></figure><p>构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ypipe_t</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  Insert terminator element into the queue.</span></span><br><span class="line">    queue.<span class="built_in">push</span>(); <span class="comment">//yqueue_t的尾指针加1，开始back_chunk为空，现在back_chunk指向第一个chunk_t块的第一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Let all the pointers to point to the terminator.</span></span><br><span class="line">    <span class="comment">//  (unless pipe is dead, in which case c is set to NULL).</span></span><br><span class="line">    r = w = f = &amp;queue.<span class="built_in">back</span>(); <span class="comment">//就是让r、w、f、c四个指针都指向这个end迭代器</span></span><br><span class="line">    c.<span class="built_in">set</span>(&amp;queue.<span class="built_in">back</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>write  unwrite:写入可以单独写，也可以批量写。可以看到如果incomplete_ &#x3D; true，则说明在批量写，直到incomplete_ &#x3D; false时，进行写提交刷新 f 指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Write an item to the pipe.  Don&#x27;t flush it yet. If incomplete is</span></span><br><span class="line"><span class="comment">//  set to true the item is assumed to be continued by items</span></span><br><span class="line"><span class="comment">//  subsequently written to the pipe. Incomplete items are neverflushed down the stream.</span></span><br><span class="line"><span class="comment">// 写入数据，incomplete参数表示写入是否还没完成，在没完成的时候不会修改flush指针，即这部分数据不会让读线程看到。    </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> T &amp;value_, <span class="type">bool</span> incomplete_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  Place the value to the queue, add new terminator element.</span></span><br><span class="line">    queue.<span class="built_in">back</span>() = value_;</span><br><span class="line">    queue.<span class="built_in">push</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Move the &quot;flush up to here&quot; poiter.</span></span><br><span class="line">    <span class="keyword">if</span> (!incomplete_)</span><br><span class="line">    &#123;</span><br><span class="line">        f = &amp;queue.<span class="built_in">back</span>(); <span class="comment">// 记录要刷新的位置</span></span><br><span class="line">        <span class="comment">// printf(&quot;1 f:%p, w:%p\n&quot;, f, w);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  printf(&quot;0 f:%p, w:%p\n&quot;, f, w);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Pop an incomplete item from the pipe. Returns true is such</span></span><br><span class="line"><span class="comment">//  item exists, false otherwise.</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="built_in">unwrite</span>(T *value_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == &amp;queue.<span class="built_in">back</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    queue.<span class="built_in">unpush</span>();</span><br><span class="line">    *value_ = queue.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flush</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Flush all the completed items into the pipe. Returns false if</span></span><br><span class="line"><span class="comment">//  the reader thread is sleeping. In that case, caller is obliged to</span></span><br><span class="line"><span class="comment">//  wake the reader up before using the pipe again.</span></span><br><span class="line"><span class="comment">// 刷新所有已经完成的数据到管道，返回false意味着读线程在休眠，在这种情况下调用者需要唤醒读线程。</span></span><br><span class="line"><span class="comment">// 批量刷新的机制， 写入批量后唤醒读线程；</span></span><br><span class="line"><span class="comment">// 反悔机制 unwrite</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  If there are no un-flushed items, do nothing.</span></span><br><span class="line">    <span class="keyword">if</span> (w == f) <span class="comment">// 不需要刷新，即是还没有新元素加入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Try to set &#x27;c&#x27; to &#x27;f&#x27;.</span></span><br><span class="line">    <span class="comment">// read时如果没有数据可以读取则c的值会被置为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (c.<span class="built_in">cas</span>(w, f) != w) <span class="comment">// 尝试将c设置为f，即是准备更新w的位置</span></span><br><span class="line">    &#123;<span class="comment">// 进入此分支：在flush之前进行了 check_read但是失败了，c被置为 NULL</span></span><br><span class="line">        <span class="comment">//  Compare-and-swap was unseccessful because &#x27;c&#x27; is NULL.</span></span><br><span class="line">        <span class="comment">//  This means that the reader is asleep. Therefore we don&#x27;t</span></span><br><span class="line">        <span class="comment">//  care about thread-safeness and update c in non-atomic</span></span><br><span class="line">        <span class="comment">//  manner. We&#x27;ll return false to let the caller know</span></span><br><span class="line">        <span class="comment">//  that reader is sleeping.</span></span><br><span class="line">        c.<span class="built_in">set</span>(f); <span class="comment">// 更新为新的f位置</span></span><br><span class="line">        w = f;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//线程看到flush返回false之后会发送一个消息给读线程，这需要写业务去做处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 读端还有数据可读取</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  Reader is alive. Nothing special to do now. Just move</span></span><br><span class="line">        <span class="comment">//  the &#x27;first un-flushed item&#x27; pointer to &#x27;f&#x27;.</span></span><br><span class="line">        w = f;             <span class="comment">// 更新w的位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下参考文章中提供了多读多写的基于数据的无锁队列实现，以及理论分析</p><p>内联汇编：<a href="https://www.jianshu.com/p/1782e14a0766">https://www.jianshu.com/p/1782e14a0766</a></p><p>cas 单例模式：<a href="https://blog.csdn.net/q5707802/article/details/79251491">https://blog.csdn.net/q5707802/article/details/79251491</a></p><p><a href="https://www.yuque.com/linuxer/xngi03/cegcer#bgHkH">说说无锁(Lock-Free)编程那些事 (yuque.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/33985732">基于数组的无锁队列(译) - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAS-与-无锁队列&quot;&gt;&lt;a href=&quot;#CAS-与-无锁队列&quot; class=&quot;headerlink&quot; title=&quot;CAS 与 无锁队列&quot;&gt;&lt;/a&gt;CAS 与 无锁队列&lt;/h1&gt;&lt;p&gt;假设我们有一全局变量 idx ， 在执行 idx++ 时编译器会翻译为三条汇</summary>
      
    
    
    
    
    <category term="从0到1" scheme="http://example.com/tags/%E4%BB%8E0%E5%88%B01/"/>
    
  </entry>
  
  <entry>
    <title>io_uring</title>
    <link href="http://example.com/2024/02/05/8.1io_uring/"/>
    <id>http://example.com/2024/02/05/8.1io_uring/</id>
    <published>2024-02-04T16:00:00.000Z</published>
    <updated>2024-02-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h1><p>在linux 5.1 版本之后，Linux内核提供了异步IO的框架支持，提供了三个系统调用 <code> io_uring_enter  io_uring_register  io_uring_setup</code> 在liburing.h头文件中对此系统调用进行了封装，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_enter</span><span class="params">(<span class="type">int</span> ring_fd, <span class="type">unsigned</span> <span class="type">int</span> to_submit,</span></span><br><span class="line"><span class="params">                   <span class="type">unsigned</span> <span class="type">int</span> min_complete, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) syscall(__NR_io_uring_enter, ring_fd, to_submit, min_complete,</span><br><span class="line">                         flags, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中系统调用号<code>__NR_io_uring_enter</code> 在<code>unistd_64.h</code>中被定义：<code>#define __NR_io_uring_enter 426</code></p><h2 id="性能："><a href="#性能：" class="headerlink" title="性能："></a>性能：</h2><p>由于调用系统调用时，会从用户态切换到内核态，从而进行上下文切换，而上下文切换会消耗一定的 CPU 时间。<code>io_uring</code> 为了减少或者摒弃系统调用，采用了用户态与内核态共享内存的方式来通信(用户态对共享内存进行读写操作是不需要使用系统调用的，所以不会发生上下文切换的情况)。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_setup</span><span class="params">(u32 entries, <span class="keyword">struct</span> io_uring_params *p)</span>;</span><br></pre></td></tr></table></figure><p>用户通过调用 <code>io_uring_setup </code>初始化一个新的 <code>io_uring</code> 上下文。该函数返回一个 file descriptor，并将 <code>io_uring</code> 支持的功能、以及各个数据结构在 <code>fd</code> 中的偏移量存入 <code>params</code>。用户根据偏移量将 <code>fd</code> 映射到内存 (mmap) 后即可获得一块内核用户共享的内存区域。这块内存区域中，有 <code>io_uring</code> 的上下文信息：提交队列信息 (<code>SQ_RING</code>) 和完成队列信息 (<code>CQ_RING</code>)；还有一块专门用来存放提交队列元素的区域 (SQEs)。<code>SQ_RING</code> 中只存储 SQE 在 SQEs 区域中的序号，<code>CQ_RING</code> 存储完整的任务完成数据。</p><p><img src="/img/v2-ad01522fd88442e9164001926b3d839c_r.png"></p><p><code>io_uring</code> 在创建时有两个选项(flag)，对应着 <code>io_uring</code> 处理任务的不同方式：</p><ul><li>开启 <code>IORING_SETUP_IOPOLL</code> 后，<code>io_uring</code> 会使用轮询的方式执行所有的操作。</li><li>开启 <code>IORING_SETUP_SQPOLL</code> 后，<code>io_uring</code> 会创建一个内核线程专门用来收割用户提交的任务。</li><li>都不开启，通过 <code>io_uring_enter</code> 提交任务，收割任务无需 syscall。</li></ul><p><code>io_uring_setup</code> 设计的巧妙之处在于，内核通过一块和用户共享的内存区域进行消息的传递。在创建上下文后，任务提交、任务收割等操作都通过这块共享的内存区域进行，在 <code>IO_SQPOLL</code> 模式下，可以完全绕过 Linux 的 syscall 机制完成需要内核介入的操作（比如读写文件），大大减少了 syscall 切换上下文、刷 TLB 的开销。</p><h2 id="任务的定义"><a href="#任务的定义" class="headerlink" title="任务的定义"></a>任务的定义</h2><p><code>io_uring</code> 定义的异步 io 请求，对应宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OP_NOP0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OP_READV1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OP_WRITEV2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OP_FSYNC3</span></span><br></pre></td></tr></table></figure><p>内核中定义了<code>io_op_defs</code>数组用与描述对应的异步 io 请求所需要的条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">io_op_def</span> <span class="title">io_op_defs</span>[] =</span> &#123;</span><br><span class="line">[IORING_OP_NOP] = &#123;&#125;,</span><br><span class="line">[IORING_OP_READV] = &#123;</span><br><span class="line">.needs_file= <span class="number">1</span>,<span class="comment">//表示该操作需要文件描述符。</span></span><br><span class="line">.unbound_nonreg_file= <span class="number">1</span>, <span class="comment">//表示该操作需要非正则文件</span></span><br><span class="line">.pollin= <span class="number">1</span>,<span class="comment">//表示该操作需要poll in。</span></span><br><span class="line">.buffer_select= <span class="number">1</span>,<span class="comment">//表示该操作需要buffer_select</span></span><br><span class="line">.needs_async_setup= <span class="number">1</span>,<span class="comment">//表示该操作需要异步设置。</span></span><br><span class="line">.plug= <span class="number">1</span>,   <span class="comment">//表示该操作需要plug。 </span></span><br><span class="line">.async_size= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_async_rw),<span class="comment">//表示该操作的异步结构体大小</span></span><br><span class="line">&#125;,</span><br><span class="line">[IORING_OP_WRITEV] = &#123;</span><br><span class="line">.needs_file= <span class="number">1</span>,</span><br><span class="line">.hash_reg_file= <span class="number">1</span>,</span><br><span class="line">.unbound_nonreg_file= <span class="number">1</span>,</span><br><span class="line">.pollout= <span class="number">1</span>,</span><br><span class="line">.needs_async_setup= <span class="number">1</span>,</span><br><span class="line">.plug= <span class="number">1</span>,</span><br><span class="line">.async_size= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_async_rw),</span><br><span class="line">&#125;,</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>io_uring</code> 中几乎每个操作都有对应的准备和执行函数。比如 <code>read</code> 操作就对应 <code>io_read_prep</code> 和 <code>io_read</code> 函数。除了同步操作，内核还支持异步调用的操作，对于这些操作，<code>io_uring</code>中还会有一个对应的异步准备函数以 <code>_async</code> 结尾</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">io_sendmsg_prep_async</span><span class="params">(<span class="keyword">struct</span> io_kiocb *req)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">io_rw_prep_async</span><span class="params">(<span class="keyword">struct</span> io_kiocb *req, <span class="type">int</span> rw)</span>;</span><br></pre></td></tr></table></figure><h2 id="任务的创建"><a href="#任务的创建" class="headerlink" title="任务的创建"></a>任务的创建</h2><p><strong>用户将需要进行的操作写入 <code>io_uring</code> 的 SQ 中。在 CQ 中，用户可以收割任务的完成情况。</strong></p><p>sqe的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> &#123;</span></span><br><span class="line">__u8opcode;<span class="comment">/* type of operation for this sqe */</span></span><br><span class="line">__u8flags;<span class="comment">/* IOSQE_ flags */</span></span><br><span class="line">__u16ioprio;<span class="comment">/* ioprio for the request */</span></span><br><span class="line">__s32fd;<span class="comment">/* file descriptor to do IO on */</span></span><br><span class="line">__u64off;<span class="comment">/* offset into file */</span></span><br><span class="line">__u64addr;<span class="comment">/* pointer to buffer or iovecs */</span></span><br><span class="line">__u32len;<span class="comment">/* buffer size or number of iovecs */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">__kernel_rwf_t</span>rw_flags;</span><br><span class="line">__u32fsync_flags;</span><br><span class="line">__u16poll_events;</span><br><span class="line">__u32sync_range_flags;</span><br><span class="line">__u32msg_flags;</span><br><span class="line">__u32timeout_flags;</span><br><span class="line">&#125;;</span><br><span class="line">__u64user_data;<span class="comment">/* data to be passed back at completion time */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__u16buf_index;<span class="comment">/* index into fixed buffers, if used */</span></span><br><span class="line">__u64__pad2[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如要进行<code>readv</code> 操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sqe-&gt;fd = filefd;<span class="comment">//需要操作的文件描述符</span></span><br><span class="line">sqe-&gt;flags = <span class="number">0</span>;</span><br><span class="line">sqe-&gt;opcode = IORING_OP_READV; <span class="comment">//readv对应option_code</span></span><br><span class="line">sqe-&gt;addr = &amp;iovecs;  <span class="comment">//存放的起始地址</span></span><br><span class="line">sqe-&gt;len = blocks;<span class="comment">//对应 iovec 数组的长度</span></span><br><span class="line">sqe-&gt;off = <span class="number">0</span>;<span class="comment">//从文件偏移位置为0处开始</span></span><br></pre></td></tr></table></figure><p>通常来说，使用 <code>io_uring</code> 的程序都需要用到 64 位的 <code>user_data</code> 来唯一标识一个操作。<code>user_data</code> 是 SQE 的一部分。<code>io_uring</code> 执行完某个操作后，会将这个操作的 <code>user_data</code> 和操作的返回值一起写入 CQ 中。一般携带指向堆内存的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> &#123;</span></span><br><span class="line">__u64user_data;<span class="comment">/* sqe-&gt;data submission passed back */</span></span><br><span class="line">__s32res;<span class="comment">/* result code for this event */</span></span><br><span class="line">__u32flags;<span class="comment">// 未使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <code>io_ uring</code> 是一个异步接口，<code>errno</code> 将不用于传回错误信息。与此对应，<code>res</code> 将保存在成功的情况下等效的系统调用将要返回的内容，而在出错的情况下 <code>res</code> 将包含<code>-errno</code>。例如，如果正常读取系统调用返回<code>-1</code>并将<code>errno</code>设置为<code>EINVAL</code>，则<code>res</code>将包含<code>-EINVAL</code>。</p><h2 id="任务的提交与收割"><a href="#任务的提交与收割" class="headerlink" title="任务的提交与收割"></a>任务的提交与收割</h2><p><code>io_uring</code> 通过环形队列和用户交互。</p><p><img src="/img/v2-f688ede3a66c848fb4e3333767dfd9cc_r.png"></p><p>我们的先以用户提交任务为例，介绍 <code>io_uring</code> 的内核用户交互方式。用户提交任务的过程如下：</p><ul><li>将 SQE 写入 SQEs 区域，而后将 SQE 编号写入 SQ。（对应图中绿色第一步）</li><li>更新用户态记录的队头。（对应图中绿色第二步）</li><li>如果有多个任务需要同时提交，用户不断重复上面的过程。</li><li>将最终的队头编号写入与内核共享的 <code>io_uring</code> 上下文。（对应图中绿色第三步）</li></ul><p>接下来我们简要介绍内核获取任务、内核完成任务、用户收割任务的过程。</p><ul><li>内核态获取任务的方式是，从队尾读取 SQE，并更新 <code>io_uring</code> 上下文的 SQ tail。</li></ul><p><img src="/img/v2-670198a5e28380ee33809eec41d39e04_r.png"></p><ul><li>内核态完成任务：往 CQ 中写入 CQE，更新上下文 CQ head。</li><li>用户态收割任务：从 CQ 中读取 CQE，更新上下文 CQ tail。</li></ul><p><code>io_uring</code> 在创建时有两个选项，对应着 <code>io_uring</code> 处理任务的不同方式：</p><ul><li>开启 <code>IORING_SETUP_IOPOLL</code> 后，<code>io_uring</code> 会使用轮询的方式执行所有的操作。</li><li>开启 <code>IORING_SETUP_SQPOLL</code> 后，<code>io_uring</code> 会创建一个内核线程专门用来收割用户提交的任务。</li></ul><p>这些选项的设定会影响之后用户与 <code>io_uring</code> 交互的方式：</p><ul><li>都不开启，通过 <code>io_uring_enter</code> 提交任务，收割任务无需 syscall。</li><li>只开启 <code>IORING_SETUP_IOPOLL</code>，通过 <code>io_uring_enter</code> 提交任务和收割任务。</li><li>开启 <code>IORING_SETUP_SQPOLL</code>，无需任何 syscall 即可提交、收割任务。内核线程在一段时间无操作后会休眠，可以通过 <code>io_uring_enter</code> 唤醒。</li></ul><h2 id="liburing"><a href="#liburing" class="headerlink" title="liburing"></a>liburing</h2><p>使用流程：</p><ol><li><p>使用io_uring_queue_init，完成io_uring相关结构的初始化。在这个函数的实现中，会调用多个mmap来初始化一些内存。</p></li><li><p>初始化完成之后，为了提交IO请求，需要获取里面queue的一个项，使用io_uring_get_sqe。</p></li><li><p>获取到了空闲项之后，使用io_uring_prep_readv、io_uring_prep_writev初始化读、写请求。和前文所提preadv、pwritev的思想差不多，这里直接以不同的操作码委托io_uring_prep_rw，io_uring_prep_rw只是简单地初始化io_uring_sqe。</p></li><li><p>准备完成之后，使用io_uring_submit提交请求。</p></li><li><p>提交了IO请求时，可以通过非阻塞式函数io_uring_peek_cqe、阻塞式函数io_uring_wait_cqe获取请求完成的情况。默认情况下，完成的IO请求还会存在内部的队列中，需要通过io_uring_cqe_seen表标记完成操作。</p></li><li><p>使用完成之后要通过io_uring_queue_exit来完成资源清理的工作。</p></li></ol><h3 id="link-operation"><a href="#link-operation" class="headerlink" title="link operation"></a>link operation</h3><p>在io_uring中完成的任务并不是按照提交顺序返回的，有时我们需要按顺序的完成一组任务，这需要设置<code>sqe</code>对应的flag，为<code>flag</code>添加 <code>IOSQE_IO_LINK</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">io_uring_prep_write(sqe, fd, STR, <span class="built_in">strlen</span>(STR), <span class="number">0</span> );</span><br><span class="line">sqe-&gt;flags |= IOSQE_IO_LINK;<span class="comment">//添加link flag</span></span><br><span class="line"></span><br><span class="line">sqe = io_uring_get_sqe(ring);</span><br><span class="line"><span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">io_uring_prep_read(sqe, fd, buff, <span class="built_in">strlen</span>(STR),<span class="number">0</span>);</span><br><span class="line">sqe-&gt;flags |= IOSQE_IO_LINK;<span class="comment">//添加link flag</span></span><br><span class="line"></span><br><span class="line">sqe = io_uring_get_sqe(ring);</span><br><span class="line"><span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">io_uring_prep_close(sqe, fd);</span><br><span class="line">io_uring_submit(ring);</span><br></pre></td></tr></table></figure><p><code>IOSQE_IO_LINK</code>使得本<code>sqe</code>与下一提交的<code>sqe</code>相关联，即两个任务之间有了先后顺序，如上代码就保证了，先读后写最后关闭</p><p>倘若我们操作的文件没有对应的权限，如没有写权限，文件以 O_WRONLY 打开，那么read操作将失败，这将导致后续link的操作全部失败</p><p>当涉及链接操作时，一个操作的失败将导致所有后续链接操作失败，并出现 errno“Operation cancelled”</p><h3 id="regster"><a href="#regster" class="headerlink" title="regster"></a>regster</h3><p>注册文件或用户缓冲区允许内核长期引用内部数据结构或创建应用程序内存的长期映射，从而大大减少每个I&#x2F;O的开销。</p><p>应用程序可以增加或减少已注册缓冲区的大小或数量，方法是首先取消注册现有缓冲区，然后使用新缓冲区发出对io_uring_register（）的新调用。注册缓冲区将等待环空闲。如果应用程序当前有正在处理的请求，注册将等待这些请求完成后再继续。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_register_buffers</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">const</span> <span class="keyword">struct</span> iovec *iovecs, <span class="type">unsigned</span> nr_iovecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">io_uring_prep_write_fixed</span><span class="params">(<span class="keyword">struct</span> io_uring_sqe *sqe,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> fd,</span></span><br><span class="line"><span class="params">                               <span class="type">const</span> <span class="type">void</span> *buf,</span></span><br><span class="line"><span class="params">                               <span class="type">unsigned</span> nbytes,</span></span><br><span class="line"><span class="params">                               __u64 offset,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> buf_index)</span>;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">io_uring_prep_read_fixed</span><span class="params">(<span class="keyword">struct</span> io_uring_sqe *sqe,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> fd,</span></span><br><span class="line"><span class="params">                               <span class="type">void</span> *buf,</span></span><br><span class="line"><span class="params">                               <span class="type">unsigned</span> nbytes,</span></span><br><span class="line"><span class="params">                               __u64 offset,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> buf_index)</span>;</span><br></pre></td></tr></table></figure><p>在register后，对映射后的内存进行read &#x2F; write 操作时，避免一次数据copy，register可以理解为将iovec mmap 到内核中，这样在进行read 或 write 后就少了一次copy</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(FILE_NAME, O_RDWR|O_TRUNC|O_CREAT, <span class="number">0644</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    iov[i].iov_base = <span class="built_in">malloc</span>(BUF_SIZE);</span><br><span class="line">    iov[i].iov_len = BUF_SIZE;</span><br><span class="line">    <span class="built_in">memset</span>(iov[i].iov_base, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ret = io_uring_register_buffers(ring, iov, <span class="number">4</span>);</span><br><span class="line">sqe = io_uring_get_sqe(ring);</span><br><span class="line">io_uring_prep_write_fixed(sqe, fd, iov[<span class="number">0</span>].iov_base, str1_sz, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">io_uring_submit(ring);</span><br><span class="line">io_uring_wait_cqe(ring, &amp;cqe);</span><br><span class="line">io_uring_cqe_seen(ring, cqe);</span><br></pre></td></tr></table></figure><p>注册文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_register_files</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">const</span> <span class="type">int</span> *files , <span class="type">unsigned</span> nr_files)</span>;</span><br></pre></td></tr></table></figure><p>在用于提交的SQE中，您在使用文件描述符数组中的文件描述符索引而不是在像<code> io_uring_prep_readv（）</code>和<code>io_uring_prep_writev（）</code>这样的调用中使用文件描述符本身时设置了<code>IOSQE_FIXED_FILE</code> 标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">   <span class="type">int</span> ret = io_uring_register_files(ring, fds, <span class="number">1</span>);</span><br><span class="line">   sqe = io_uring_get_sqe(ring);</span><br><span class="line">   io_uring_prep_write(sqe, <span class="number">0</span>, buff1, str1_sz, <span class="number">0</span>);</span><br><span class="line">   <span class="comment">//这里的0表示注册的一组文件描述符的索引只有在设置flag |= IOSQE_FIXED_FILE 有效</span></span><br><span class="line">   sqe-&gt;flags |= IOSQE_FIXED_FILE;</span><br><span class="line">io_uring_submit(ring);</span><br></pre></td></tr></table></figure><h3 id="queue-polling"><a href="#queue-polling" class="headerlink" title="queue polling"></a>queue polling</h3><p>减少系统调用的数量是IO的一个主要目标。为此，<code>io_uring</code>允许提交I&#x2F;O请求，而无需进行单个系统调用。这是通过<code>io_uring</code>支持的一个特殊的提交队列轮询特性完成的。在这种模式下，在程序设置轮询模式后，<code>o_uring</code>启动一个特殊的内核线程，该线程轮询共享提交队列中程序可能添加的条目。这样，您只需将条目提交到共享队列中，内核线程应该看到它并拾取提交队列条目，而无需您的程序进行io_uring_enter（）系统调用。这是在用户空间和内核之间共享队列的一个好处。</p><p>通过在io_uring_params结构的flags成员中设置IORING_SETUP_SQPOLL标志，可以告诉io_uring要使用此模式。如果内核线程在一段时间内没有看到任何提交，它将退出，需要再次调用io_uring_enter（）系统调用来唤醒内核线程，这里的时间由 io_uring_param 的成员 <code>sq_thread_idle</code> 所决定</p><p>在使用liburing时，您永远不会直接调用 <code> io_uring_enter（）</code>系统调用。这通常是由<code>liburing</code>的<code> io_uring_submit（）</code>函数来处理的。它会自动判断你是否在使用轮询模式，并处理你的程序何时需要调用<code> io_uring_enter（）</code>，而你不必为此费心。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> <span class="title">params</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;params, <span class="number">0</span>, <span class="keyword">sizeof</span>(params));</span><br><span class="line">params.flags |= IORING_SETUP_SQPOLL;<span class="comment">// 设置poll模式</span></span><br><span class="line">params.sq_thread_idle = <span class="number">2000</span>;</span><br><span class="line">io_uring_queue_init_params(<span class="number">8</span>, &amp;ring, &amp;params);</span><br></pre></td></tr></table></figure><h3 id="eventfd"><a href="#eventfd" class="headerlink" title="eventfd"></a>eventfd</h3><p>首先我们回顾下 eventfd 系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">eventfd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> initval, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>读操作：</p><p>每次成功的 read(2) 操作都会返回一个 8 字节的整数。如果提供的缓冲区大小小于 8 字节，则 read(2) 会失败并返回错误 EINVAL。</p><p>read(2) 返回的值采用主机字节序，即主机上用于整数的本机字节序。</p><p>read(2) 的行为取决于 eventfd 计数器当前是否具有非零值以及创建 eventfd 文件描述符时是否指定了 EFD_SEMAPHORE 标志：</p><ul><li><p>如果未指定 EFD_SEMAPHORE 并且 eventfd 计数器具有非零值，则 read(2) 会返回 8 字节的数据，其中包含该值，并将计数器的值重置为零。</p></li><li><p>如果指定了 EFD_SEMAPHORE 并且 eventfd 计数器具有非零值，则 read(2) 会返回 8 字节的数据，其中包含值 1，并将计数器的值减 1。</p></li><li><p>如果在调用 read(2) 时 eventfd 计数器为零，则调用会阻塞，直到计数器变为非零（此时 read(2) 会按上述方式进行）；如果文件描述符已被设置为非阻塞，则会失败并返回错误 EAGAIN。</p></li></ul><p>写操作：</p><p>write(2) 调用会将其缓冲区中提供的 8 字节整数值<strong>添加</strong>到计数器中。计数器中可以存储的最大值是最大无符号 64 位值减 1（即 0xfffffffffffffffe）。如果加法会导致计数器的值超过最大值，那么 write(2) 会阻塞，直到对文件描述符执行 read(2) 操作，或者如果文件描述符已被设置为非阻塞，则会失败并返回错误 EAGAIN。</p><p>liburing提供了封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_register_eventfd</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p><code>io_uring_register_eventfd</code> 将eventfd的文件描述符fd注册到io_uring环上，当完成队列中有事件时，会对event执行write操作</p><p>如果不再需要通知，可以调用io_uring_unregister_eventfd（3）来删除eventfd注册。  不需要eventfd参数，因为一个环只能注册一个eventfd。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFF_SZ   512</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buff[BUFF_SZ + <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_exit</span><span class="params">(<span class="type">char</span> *message)</span> &#123;</span><br><span class="line">    perror(message);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">listener_thread</span><span class="params">(<span class="type">void</span> *data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="type">int</span> efd = (<span class="type">int</span>) data;</span><br><span class="line">    <span class="type">eventfd_t</span> v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Waiting for completion event...\n&quot;</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = eventfd_read(efd, &amp;v);                <span class="comment">//首次调用会 block , 可读以为这有事件完成了</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) error_exit(<span class="string">&quot;eventfd_read&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Got completion event.\n&quot;</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">    ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error waiting for completion: %s\n&quot;</span>,</span><br><span class="line">                strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Now that we have the CQE, let&#x27;s process it */</span></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in async operation: %s\n&quot;</span>, strerror(-cqe-&gt;res));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result of the operation: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">    io_uring_cqe_seen(&amp;ring, cqe);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Contents read from file:\n%s\n&quot;</span>, buff);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setup_io_uring</span><span class="params">(<span class="type">int</span> efd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = io_uring_queue_init(<span class="number">8</span>, &amp;ring, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to setup io_uring: %s\n&quot;</span>, strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    io_uring_register_eventfd(&amp;ring, efd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_file_with_io_uring</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not get SQE.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">    io_uring_prep_read(sqe, fd, buff, BUFF_SZ, <span class="number">0</span>);</span><br><span class="line">    io_uring_submit(&amp;ring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="type">int</span> efd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create an eventfd instance */</span></span><br><span class="line">    efd = eventfd(<span class="number">0</span>, <span class="number">0</span>);            <span class="comment">//创建eventfd</span></span><br><span class="line">    <span class="keyword">if</span> (efd &lt; <span class="number">0</span>)</span><br><span class="line">        error_exit(<span class="string">&quot;eventfd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create the listener thread */</span></span><br><span class="line">    pthread_create(&amp;t, <span class="literal">NULL</span>, listener_thread, (<span class="type">void</span> *)efd);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup io_uring instance and register the eventfd */</span></span><br><span class="line">    setup_io_uring(efd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initiate a read with io_uring */</span></span><br><span class="line">    read_file_with_io_uring();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for th listener thread to complete */</span></span><br><span class="line">    pthread_join(t, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All done. Clean up and exit. */</span></span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://unixism.net/loti/index.html">https://unixism.net/loti/index.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/361955546">浅析开源项目之io_uring - 知乎 (zhihu.com)</a></p><p><a href="https://mp.weixin.qq.com/s/1wZpFhwJR-LNkQm-QzFxRQ">图解原理｜Linux I&#x2F;O 神器之 io_uring (qq.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/380726590">https://zhuanlan.zhihu.com/p/380726590</a></p><p><a href="https://zhuanlan.zhihu.com/p/334658432">https://zhuanlan.zhihu.com/p/334658432</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;io-uring&quot;&gt;&lt;a href=&quot;#io-uring&quot; class=&quot;headerlink&quot; title=&quot;io_uring&quot;&gt;&lt;/a&gt;io_uring&lt;/h1&gt;&lt;p&gt;在linux 5.1 版本之后，Linux内核提供了异步IO的框架支持，提供了三个系统调用 </summary>
      
    
    
    
    
    <category term="从0到1" scheme="http://example.com/tags/%E4%BB%8E0%E5%88%B01/"/>
    
  </entry>
  
  <entry>
    <title>线程和原子操作</title>
    <link href="http://example.com/2024/01/18/3.2%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2024/01/18/3.2%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</id>
    <published>2024-01-17T16:00:00.000Z</published>
    <updated>2024-01-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程和原子操作"><a href="#线程和原子操作" class="headerlink" title="线程和原子操作"></a>线程和原子操作</h1><h2 id="线程thread基本使用"><a href="#线程thread基本使用" class="headerlink" title="线程thread基本使用"></a>线程thread基本使用</h2><p>动或按值复制线程函数的参数。如果需要传递引用参数给线程函数，那么必须包装它（例如用 <a href="https://zh.cppreference.com/w/cpp/utility/functional/ref">std::ref</a> 或 <a href="https://zh.cppreference.com/w/cpp/utility/functional/ref">std::cref</a>）。</p><p>忽略来自函数的任何返回值。如果函数抛出异常，那么就会调用 <a href="https://zh.cppreference.com/w/cpp/error/terminate">std::terminate</a>。<strong>需要将返回值或异常传递回调用方线程时可以使用 <a href="https://zh.cppreference.com/w/cpp/thread/promise">std::promise</a> 或 <a href="https://zh.cppreference.com/w/cpp/thread/async">std::async</a>。</strong></p><p>传值和传引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; a +b &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> &amp; a)</span> </span>&#123;</span><br><span class="line">a += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func1 , <span class="number">10</span> , <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">10</span></span><br><span class="line">std::thread <span class="built_in">t2</span>(func2 , std::<span class="built_in">ref</span>(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::ref</code> 用于包装按引用传递的值。<br><code>std::cref</code> 用于包装按<code>const</code>引用传递的值。</p><p><img src="/img/%E4%BB%8E0%E5%88%B01/Snipaste_2023-10-11_12-07-38.png"></p><p>创建一个可运行(<strong>创建时传入线程函数</strong>)的线程对象后，必须对该线程对象进行处理，<strong>要么调用join()，要么调用detach()<strong>，否则线程对象析构时</strong>程序</strong>将直接退出。</p><blockquote><p><code>std::thread::~thread</code>销毁 thread 对象。若 *this 拥有关联线程（ joinable() &#x3D;&#x3D; true ），则调用std::terminate。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; cout &lt;&lt; a &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(f,<span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码将收到<code>Abort</code>信号，因为，线程对象t1在作用域中没有调用join或detach，当t1出作用域时，将会抛出异常导致程序退出</p><h3 id="线程遇到重载函数"><a href="#线程遇到重载函数" class="headerlink" title="线程遇到重载函数"></a>线程遇到重载函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; std:: cout &lt;&lt; a &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::string a)</span> </span>&#123; std::cout &lt;&lt;a &lt;&lt; std::endl;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">((<span class="type">void</span>(*)(<span class="type">int</span>))f , <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">((<span class="type">void</span>(*)(std::string))f , <span class="string">&quot;aaa&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h2><p>每个 <code>std::atomic</code> 模板的实例化和全特化定义一个原子类型。如果一个线程写入原子对象，同时另一线程从它读取，那么行为良好定义，<code>std::atomic</code> 既不可复制也不可移动。</p><p><code>std::atomic</code>模板可用于任何满足可复制构造，可复制赋值，可平凡复制类型T的特化，不支持复制初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::is_trivially_copyable&lt;T&gt;::value</span><br><span class="line">std::is_copy_constructible&lt;T&gt;::value</span><br><span class="line">std::is_move_constructible&lt;T&gt;::value</span><br><span class="line">std::is_copy_assignable&lt;T&gt;::value</span><br><span class="line">std::is_move_assignable&lt;T&gt;::value</span><br></pre></td></tr></table></figure><p>上述值为<code>false</code>非良构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">foo</span><span class="params">(<span class="number">0</span>)</span></span>;  <span class="comment">//直接初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    foo.<span class="built_in">store</span>(x , std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        x = foo.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    &#125; <span class="keyword">while</span>(x == <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt;<span class="string">&quot;foo :&quot;</span> &lt;&lt;x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">first</span><span class="params">(print_foo)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">second</span><span class="params">(set_foo , <span class="number">10</span>)</span></span>;</span><br><span class="line">    first.<span class="built_in">join</span>();</span><br><span class="line">    second.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main finish \n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>std::atomic<T>::store</li></ul><p><code>void store(T desired , std::memort_order order = std::memory_order_seq_cst) noexcept</code>以 desired 原子地替换当前值。按照 order 的值影响内存。order必须是 std::memory_order_relaxed .  std::memory_order_release ,  std::memory_order_seq_cst</p><ul><li>std::atomic<T>::load</li></ul><p><code>void load(std::memort_order order = std::memory_order_seq_cst) const noexcept</code>，原子地加载并返回原子变量的当前值。按照 order 的值影响内存。返回原子变量的当前值。</p><ul><li>std::atomic<T>::operator&#x3D;</li></ul><p><code>T operator=( T desired ) noexcept;</code>将 desired 原子地赋给原子变量。等价于 store(desired)。返回 desired</p><h3 id="std-call-once-std-once-flag"><a href="#std-call-once-std-once-flag" class="headerlink" title="std::call_once std::once_flag"></a>std::call_once std::once_flag</h3><p>定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Callable, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">(std::once_flag&amp; flag , Callable&amp;&amp; f , Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>如果在调用 <code>std::call_once</code> 的时刻，flag 指示 f 已经调用过，那么 <code>std::call_once</code> 会立即返回（称这种对 <code>std::call_once</code> 的调用为<em>消极</em>）。</p></li><li><p>否则，std::call_once 会调用 INVOKE(std::forward<Callable>(f), std::forward<Args>(args)…)。与 std::thread 的构造函数或 std::async 不同，不会移动或复制参数，因为不需要转移它们到另一执行线程（称这种对 std::call_once 的调用为积极）。</p><ul><li>如果该调用抛出了异常，那么将异常传播给 <code>std::call_once</code> 的调用方，并且不翻转 flag，这样还可以尝试后续调用（称这种对 <code>std::call_once</code> 的调用为<em>异常</em>）。</li><li>如果该调用正常返回（称这种对 <code>std::call_once</code> 的调用为<em>返回</em>），那么翻转 flag，并保证以同一 flag 对 <code>std::call_once</code> 的其他调用为<em>消极</em>。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::once_flag flag1, flag2;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simple_do_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(flag1, []()&#123; std::cout &lt;&lt; <span class="string">&quot;简单样例：调用一次\n&quot;</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">may_throw_function</span><span class="params">(<span class="type">bool</span> do_throw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (do_throw)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;抛出：call_once 会重试\n&quot;</span>; <span class="comment">// 这会出现不止一次</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;没有抛出，call_once 不会再重试\n&quot;</span>; <span class="comment">// 保证一次</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_once</span><span class="params">(<span class="type">bool</span> do_throw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag2, may_throw_function, do_throw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">st1</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st2</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st3</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st4</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    st1.<span class="built_in">join</span>();</span><br><span class="line">    st2.<span class="built_in">join</span>();</span><br><span class="line">    st3.<span class="built_in">join</span>();</span><br><span class="line">    st4.<span class="built_in">join</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(do_once, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t4</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">简单样例：调用一次   </span></span><br><span class="line"><span class="comment">抛出：call_once 会重试</span></span><br><span class="line"><span class="comment">抛出：call_once 会重试</span></span><br><span class="line"><span class="comment">抛出：call_once 会重试</span></span><br><span class="line"><span class="comment">没有抛出，call_once 不会再重试</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><h3 id="future"><a href="#future" class="headerlink" title="future"></a>future</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt; <span class="keyword">class</span> <span class="title class_">future</span>;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt; <span class="keyword">class</span> <span class="title class_">future</span>&lt;T&amp;&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;          <span class="keyword">class</span> <span class="title class_">future</span>&lt;<span class="type">void</span>&gt;;</span><br><span class="line"><span class="comment">//asynchronous 异步</span></span><br><span class="line"><span class="comment">//future   未来</span></span><br><span class="line"><span class="comment">//promise   承诺</span></span><br></pre></td></tr></table></figure><p>类模板 <code>std::future</code> 提供访问异步操作<strong>结果</strong>的机制</p><p>通过<code>std::async  std::packaged_task  std::promise</code>创建的异步操作能提供一个<code>std::future</code>对象给该异步操作的创建者，然后，异步操作的创建者能用各种方法查询 等待 或从<code>std::future</code>中提取值。若异步操作认为提供值，则这些方法可能阻塞。异步操作准备好发送结果给创建者时，它能通过修改链接到创建者的 <code>std::future</code> 的共享状态，<code>std::future</code> 所引用的共享状态不与另一异步返回对象共享</p><ul><li>get()：<code>get</code> 方法等待直至 <code>future</code> 拥有合法结果并（依赖于使用哪个模板）获取它。它等效地调用 <a href="https://zh.cppreference.com/w/cpp/thread/future/wait">wait()</a> 等待结果，泛型模板和二个模板特化各含单个 <code>get</code> 版本。 <code>get</code> 的三个版本仅在返回类型有别。若调用此函数前 <a href="https://zh.cppreference.com/w/cpp/thread/future/valid">valid()</a> 为 false 则行为未定义。</li></ul><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args &gt;</span><br><span class="line">std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="keyword">typename</span> std::decay&lt;Function&gt;::<span class="built_in">type</span>(</span><br><span class="line">        <span class="keyword">typename</span> std::decay&lt;Args&gt;::type...)&gt;::type&gt;</span><br><span class="line">    <span class="built_in">async</span>( Function&amp;&amp; f, Args&amp;&amp;... args );</span><br></pre></td></tr></table></figure><p><strong>函数模板</strong> <code>std::async</code> 异步地运行函数 f（有可能在可能是线程池一部分的分离线程中），并返回最终将保有该函数调用结果的<code>std::future</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_result_to_add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 用来测试异步延迟的影响</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;find_result_to_add&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(find_result_to_add);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;valid:&quot;</span>&lt;&lt; result.<span class="built_in">valid</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//    std::future&lt;decltype (find_result_to_add())&gt; result = std::async(find_result_to_add);</span></span><br><span class="line"><span class="comment">//    auto result = std::async(find_result_to_add);  // 推荐的写法</span></span><br><span class="line">    <span class="built_in">do_other_things</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;  <span class="comment">// 延迟是否有影响？</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;valid:&quot;</span>&lt;&lt; result.<span class="built_in">valid</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">R</span>, <span class="keyword">class</span> ...Args &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">packaged_task</span>&lt;<span class="built_in">R</span>(Args...)&gt;;</span><br></pre></td></tr></table></figure><p><strong>类模板</strong> std::packaged_task 包装任何可调用 (Callable) 目标（函数、 lambda 表达式、 bind 表达式或其他函数对象），使得能异步调用它。<strong>其返回值或所抛异常被存储于能通过 std::future 对象访问的共享状态中</strong>。</p><p><code>std::function</code> <code>std::packaged_task</code> 是多态、具分配器的容器：可在堆上或以提供的分配器分配存储的可调用对象。</p><ul><li><p>operator()：如果以<code>INVOKE&lt;R&gt;(f ,args...)</code>调用存储的任务 f。任务返回值或任何抛出的异常被存储于共享状态。令共享状态就绪，并解除阻塞任何等待此操作的线程。</p></li><li><p>get_future()：返回与 *this 共享同一共享状态的 <code>future</code> 。<code>get_future</code> 只能对每个 <code>packaged_task</code> 调用一次。</p></li><li><p>reset()：重置状态，抛弃先前执行的结果。构造共享状态。等价于 *this &#x3D; packaged_task(std::move(f)) ，其中 <code>f</code> 是存储的任务。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;call add\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_other_things</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;do_other_things&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(add)</span></span>; <span class="comment">// 封装任务，不运行</span></span><br><span class="line"><span class="built_in">do_other_things</span>();</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();<span class="comment">//将result与task的future关联，不运行</span></span><br><span class="line"><span class="built_in">task</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">//任务执行，否则在get()获取future的值时会一直阻塞</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;result:&quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>传统的线程返回值：传递一个指针给线程，表示该线程将会把返回值写入指针指向的内存空间。此时主线程将用条件变量等待值被写入，当线程把值写入指针指定的内存后，将唤醒(signal)条件变量，然后主线程将被唤醒，然后从指针指向的内存中获取返回值。</p><p>为了实现获取一个返回值的需求，使用传统的方法，我们需要条件变量(condition variable), 互斥量(mutex)，和指针三个对象。</p><p>C++11的方法：使用<strong>std::future</strong>和<strong>std::promise</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">R</span> &gt; <span class="keyword">class</span> <span class="title class_">promise</span>;</span><br></pre></td></tr></table></figure><p>类模板 <code>std::promise</code> 提供存储值或异常的设施，之后通过 <code>std::promise</code> 对象所创建的 <code>std::future</code>对象异步获得结果。注意 <code>std::promise</code> 只应当使用一次。</p><ul><li><p>std::future<T> get_future：返回与 *this 关联同一状态的 future 对象。若 *this 无共享状态，或已调用 <code>get_future</code> 则抛出异常</p></li><li><p>set_value(const R&amp; value)：原子地存储 <code>value</code> 到共享状态，并令状态就绪。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::promise&lt;std::string&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">set_value</span>(<span class="string">&quot;There is the result whitch you want.&quot;</span>);<span class="comment">//设置线程返回值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::promise&lt;std::string&gt; promise;</span><br><span class="line">std::future&lt;std::string&gt; result = promise.<span class="built_in">get_future</span>();<span class="comment">//将promise中的future与result相关联</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(print, std::ref(promise))</span></span>;  </span><br><span class="line">    <span class="comment">//新建线程，并传入 promise 的 引用，promise 无法复制故要传入引用</span></span><br><span class="line"><span class="built_in">do_some_other_things</span>();</span><br><span class="line">std::cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;<span class="comment">//从result中获取结果</span></span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程和原子操作&quot;&gt;&lt;a href=&quot;#线程和原子操作&quot; class=&quot;headerlink&quot; title=&quot;线程和原子操作&quot;&gt;&lt;/a&gt;线程和原子操作&lt;/h1&gt;&lt;h2 id=&quot;线程thread基本使用&quot;&gt;&lt;a href=&quot;#线程thread基本使用&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="从0到1" scheme="http://example.com/tags/%E4%BB%8E0%E5%88%B01/"/>
    
  </entry>
  
  <entry>
    <title>网络编程实战</title>
    <link href="http://example.com/2024/01/16/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    <id>http://example.com/2024/01/16/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</id>
    <published>2024-01-15T16:00:00.000Z</published>
    <updated>2024-01-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络编程实战"><a href="#网络编程实战" class="headerlink" title="网络编程实战"></a>网络编程实战</h1><h2 id="第四讲"><a href="#第四讲" class="headerlink" title="第四讲"></a>第四讲</h2><p>调用 connect 函数将激发 TCP 的三次握手过程，而且仅在连接建立成功或出错时才返回。其中出错返回可能有以下几种情况：</p><ol><li>三次握手无法建立，客户端发出的 SYN 包没有任何响应，于是返回 TIMEOUT 错误。这种情况比较常见的原因是对应的服务端 IP 写错。</li><li>客户端收到了 RST（复位）回答，这时候客户端会立即返回 CONNECTION REFUSED 错误。这种情况比较常见于客户端发送连接请求时的请求端口写错，因为 RST 是 TCP 在发生错误时发送的一种 TCP 分节。关闭时也会产出<code>RST</code>报文与<code>SO_LINGER</code>选项有关<br>产生 RST 的三个条件是：<br>目的地为某端口的 SYN 到达，然而该端口上没有正在监听的服务器（如前所述）；<br>TCP 想取消一个已有连接；<br>TCP 接收到一个根本不存在的连接上的分节。</li><li>客户发出的 SYN 包在网络上引起了”destination unreachable”，即目的不可达的错误。这种情况比较常见的原因是客户端和服务器端路由不通。</li></ol><p>为什么tcp建立连接需要三次握手解释如下<br>tcp连接的双方要确保各自的<strong>收发消息</strong>的能力都是正常的。 客户端第一次发送握手消息到服务端， 服务端接收到握手消息后把<code>ack</code>和自己的<code>syn</code>一同发送给客户端，这是第二次握手， 当客户端接收到服务端发送来的第二次握手消息后，客户端可以确认“服务端的收发能力OK，客户端的收发能力OK”，但是服务端只能确认 “客户端的发送OK，服务端的接收OK” ， 所以还需要第三次握手，客户端收到服务端的第二次握手消息后，发起第三次握手消息，服务端收到客户端发送的第三次握手消息后，就能够确定“服务端的发送OK，客户端的接收OK”， 至此，客户端和服务端都能够确认自己和对方的收发能力OK，，<code>tcp</code>连接建立完成。</p><h2 id="第五讲"><a href="#第五讲" class="headerlink" title="第五讲"></a>第五讲</h2><p>阻塞式套接字最终发送返回的实际写入字节数和请求字节数是相等的即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = write(sockfd , <span class="type">void</span>* buffer , <span class="type">int</span> len);</span><br></pre></td></tr></table></figure><p>当<code>sockfd</code>是<strong>阻塞状态</strong>时，只有将buffer中len字节数据放入输出缓冲区后write函数才返回。</p><p>既然缓冲区如此重要，我们可不可以把缓冲区搞得大大的，这样不就可以提高应用程序的吞吐量了么？你可以想一想这个方法可行吗？另外你可以自己总结一下，一段数据流从应用程序发送端，一直到应用程序接收端，总共经过了多少次拷贝？<br>无限大肯定是不行的，这要从为什么使用缓存这个角度考虑。内核协议栈不确定用户一次要发多少数据，如果用户来一次就发一次，如果数据多还好说，如果少了，那网络I&#x2F;O很频繁，而真正发送出去的数据也不多，所以为了减少网络I&#x2F;O使用了缓存的策略。但为啥不呢无限大呢，网卡一次发出去的数据报它是有一个最大长度的，所以你不管累积再多数据最后还是要分片发送的，这样一来缓冲区太大也没什么意义，而且数据传输也是有延时要求的，不可能总是在缓冲区里待着等数据，这样就总会有空出来的缓冲区存放新数据，所以无限大缓冲区也没意义，反而还浪费资源。<br>发送端，假设数据能一次性复制完，那么从用户态内存拷贝到内核态内存是一次（这里应该直接拷贝到发送换冲区了），传输层组TCP包是第二次拷贝，因为要加包头，而发送缓冲区的都是紧凑内存全是应用层数据，那么分装包就需要一次拷贝，第三次，一个TCP包封装为IP报文这里可能也会需要一次拷贝，毕竟这里走到协议栈的下一层了。</p><h2 id="第六讲"><a href="#第六讲" class="headerlink" title="第六讲"></a>第六讲</h2><p>实际上不存在<code>UDP</code>发送缓冲区，因为发往<code>UDP</code>发送缓冲区的包只要超过一定阈值(值很小)就可以发往对端。所以我们一般认为<code>UDP</code>是没有发送缓冲区的。</p><p><code>UDP</code> 报文的大小</p><p>主要影响 <code>UDP</code> 报文大小的三大因素：</p><ul><li><code>UDP</code> 协议规定报文长度为 16 位，所以 <code>UDP</code> 的报文长度不能超过 2^16 &#x3D; 65536 字节</li><li>以太网(Ethernet)数据帧的长度，这是由以太网的物理特性决定，也叫数据链路层的 <code>MTU</code>(最大传输单元)</li><li>socket 的 <code>UDP</code> 发送缓冲区大小</li></ul><p><code>UDP </code>最大数据包长度</p><p>根据 <code>UDP</code> 协议，从 <code>UDP</code> 数据包的包头可以看出，<code>UDP</code> 的最大包长度是 2^16-1 个字节。用<code>sendto</code>函数最大能发送数据的长度为：<code>65535- IP头(20) - UDP头(8)＝65507字节</code>。用<code>sendto</code>函数发送数据时，如果发送数据长度大于该值，则函数会返回错误。</p><p>由于 <code>UDP</code> 包头占 8 个字节，而在 <code>IP</code>层进行封装后的 <code>IP</code> 包头占去 20 字节，所以这个是 <code>UDP</code> 数据包的最大理论长度是 2^16 - 1 - 8 - 20 &#x3D; 65507 字节。</p><p>同时 <code>UDP</code> 发送缓冲区大小（<code>linux</code>下<code>UDP</code>发送缓冲区大小为：<code>cat /proc/sys/net/core/wmem_default</code>）相关，肯定不能超过缓冲区大小。</p><p><code>UDP</code> 理想数据包长度</p><p>每个以太网帧都有最小的大小 46 字节，最大不能超过 1500 字节。</p><p>除去链路层的首部和尾部的 18 个字节，链路层的数据区范围是 46-1500 字节，</p><p>那么链路层的数据区，即 <code>MTU</code>(最大传输单元)为 1500 字节。</p><p>事实上这个 1500 字节就是网络层 <code>IP</code> 数据报的长度限制。</p><p>因为 <code>IP</code> 数据报的首部为 20 字节，所以 <code>IP</code> 数据报的数据区长度最大为 1480 字节。而这个 1480 字节就是用来放 TCP 传来的 <code>TCP</code> 报文段或 <code>UDP</code> 传来的 <code>UDP</code> 数据报的。</p><p>除去 <code>UDP</code> 包头占 8 个 字节，那么 <code>UDP</code> 数据报的数据区最大长度为 1472 字节。</p><p><strong>结论1：局域网环境下，建议将 <code>UDP</code> 数据控制在 1472 字节以下</strong></p><p>Unix 网络编程第一卷里说：<code>ipv4</code> 协议规定 <code>ip</code> 层的最小重组缓冲区大小为 576 字节，所以将 <code>UDP</code> 数据报的数据区最大长度控制在 548 字节(576-8-20)以内。</p><p><strong>结论2：<code>Internet </code>编程时，建议将 <code>UDP</code> 数据控制在 548 字节以下</strong></p><h2 id="第十讲"><a href="#第十讲" class="headerlink" title="第十讲"></a>第十讲</h2><p>TIME_WAIT的作用： 1. 确保主动断开方的最后一个ACK成功发到对方 2. 确保残留的TCP包自然消亡</p><p>优化<code>TIME_WAIT</code>，可以通过设置套接字选项来设置调用close或shutdown关闭连接时的行为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval,<span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span>            <span class="comment">//linger 英文停留</span></span><br><span class="line">　<span class="type">int</span>　 l_onoff;　　　　<span class="comment">/* 0=off, nonzero=on */</span></span><br><span class="line">　<span class="type">int</span>　 l_linger;　　　 <span class="comment">/* linger time, POSIX specifies units as seconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>设置 linger 参数有几种可能：</p><ul><li><p>如果<code>l_onoff</code>为 0，那么关闭本选项。l_linger的值被忽略，这对应了默认行为，<code>close</code> 或 <code>shutdown</code> 立即返回。如果在套接字发送缓冲区中有数据残留，系统会将试着把这些数据发送出去。</p></li><li><p>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值也为 0，那么调用 <code>close</code> 后，会立该发送一个 <code>RST</code> 标志给对端，该 <code>TCP</code> 连接将跳过四次挥手，也就<strong>跳过了 <code>TIME_WAIT</code> 状态，直接关闭</strong>。这种关闭的方式称为“强行关闭”。 在这种情况下，排队数据不会被发送，被动关闭方也不知道对端已经彻底断开。只有当被动关闭方正阻塞在<code>recv()</code>调用上时，接受到 <code>RST</code> 时，会立刻得到一个<code>“connet reset by peer”</code>的异常。</p></li><li><p>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>的值也非 0，那么调用 <code>close</code> 后，调用 <code>close</code> 的线程就将阻塞，直到数据被发送出去，或者设置的<code>l_linger</code>计时时间到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">so_linger</span>;</span></span><br><span class="line">so_linger.l_onoff = <span class="number">1</span>;</span><br><span class="line">so_linger.l_linger = <span class="number">1</span>;</span><br><span class="line">setsockopt(s,SOL_SOCKET,SO_LINGER, &amp;so_linger,<span class="keyword">sizeof</span>(so_linger));</span><br></pre></td></tr></table></figure></li></ul><p>对于设置端口重用选项 SO_REUSEADDR 并不是用于解决 TIME_WAIT 状态，而是告诉内核即使是TIME_WAIT状态的套接字，也可以将它继续使用作为新的套接字使用</p><h2 id="第十一讲"><a href="#第十一讲" class="headerlink" title="第十一讲"></a>第十一讲</h2><p>close 函数具体是如何关闭两个方向的数据流呢？<br>在输入方向，系统内核会将该套接字设置为<strong>不可读</strong>，任何读操作都会返回异常。<br>在输出方向，系统内核尝试将发送缓冲区的数据发送给对端，并最后向对端发送一个 FIN 报文，接下来如果再对该套接字进行写操作会返回异常。<br>如果对端没有检测到套接字已关闭，还继续发送报文，就会收到一个 RST 报文</p><p>由于close将输入设置为不可读，当服务端要做耗时任务时，由于客户端调用close()导致输入方向不可读，此时服务端运算完成返回tcp报文，但是客户端socket不可读，故内核协议栈回复RST报文</p><p>关于signal函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure><ul><li>如果处理方式设置为 <code>SIG_IGN</code>，则信号被忽略。        </li><li>如果处理方式设置为 <code>SIG_DFL</code>，则与信号相关的默认操作（参考 signal(7)）发生。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    SIG_DFL     ((__sighandler_t)  0)    <span class="comment">/* Default action.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    SIG_IGN     ((__sighandler_t)  1)    <span class="comment">/* Ignore signal.  */</span></span></span><br></pre></td></tr></table></figure><blockquote><p>你可以看到在今天的服务器端程序中，直接调用exit(0)完成了 FIN 报文的发送，这是为什么呢？为什么不调用 close 函数或 shutdown 函数呢？</p></blockquote><p>因为在调用exit之后进程会退出，而进程相关的所有的资源，文件，内存，信号等内核分配的资源都会被释放，在<code>linux</code>中，一切皆文件，本身socket就是一种文件类型，内核会为每一个打开的文件创建<code>file</code>结构并维护指向改结构的引用计数，每一个进程结构中都会维护本进程打开的文件数组，数组下标就是<code>fd</code>，内容就指向上面的<code>file</code>结构，<code>close</code>本身就可以用来操作所有的文件，做的事就是，删除本进程打开的文件数组中指定的<code>fd</code>项，并把指向的<code>file</code>结构中的引用计数减一，等引用计数为 0 的时候，就会调用内部包含的文件操作<code>close</code>，针对于<code>socket</code>，它内部的实现就是调用<code>shutdown</code>，只是参数是关闭读写端，从而比较粗暴的关闭连接。</p><h2 id="第十二讲"><a href="#第十二讲" class="headerlink" title="第十二讲"></a>第十二讲</h2><p>socket设置保活选项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Socket::setKeepAlive</span><span class="params">(<span class="type">bool</span> on)</span> <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ::setsockopt(sockfd_, SOL_SOCKET, SO_KEEPALIVE,</span><br><span class="line">                 &amp;optval, static_cast&lt;<span class="type">socklen_t</span>&gt;(<span class="keyword">sizeof</span> optval));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p><p>上述的可定义变量，分别被称为保活时间、保活时间间隔和保活探测次数。在 <code>Linux</code> 系统中，这些变量分别对应 <code>sysctl</code> 变量<code>net.ipv4.tcp_keepalive_time</code>、<code>net.ipv4.tcp_keepalive_intvl</code>、 <code>net.ipv4.tcp_keepalve_probes</code>，默认设置是 7200 秒（2 小时）、75 秒和 9 次探测。</p><p>由于TCP自身的<code>KeepAlive</code>机制所需的时间太长，对很多对时延要求敏感的系统中，这个时间间隔是不可接受的。所以通常自实现心跳机制</p><h2 id="第十三讲"><a href="#第十三讲" class="headerlink" title="第十三讲"></a>第十三讲</h2><p>Nagle算法 和 延迟ACK 的组合：</p><p>客户端分两次将一个请求发送出去，由于请求的第一部分的报文未被确认，Nagle 算法开始起作用；同时延时 ACK 在服务器端起作用，假设延时时间为 200ms，服务器等待 200ms 后，对请求的第一部分进行确认；接下来客户端收到了确认后，Nagle 算法解除请求第二部分的阻止，让第二部分得以发送出去，服务器端在收到之后，进行处理应答，同时将第二部分的确认捎带发送出去。</p><p><img src="/%5Cimg%5CSnipaste_2023-12-18_22-51-37.png"></p><p>Nagle 算法和延时确认组合在一起，增大了处理时延，实际上，两个优化彼此在阻止对方。从上面的例子可以看到，在有些情况下 Nagle 算法并不适用， 比如对时延敏感的应用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> on = <span class="number">1</span>;             <span class="comment">//关闭 Nagle 算法</span></span><br><span class="line">setsockopt(sock , IPPROTO_TCP , TCP_NODELAY , (vodi*)&amp;on , <span class="keyword">sizeof</span>(on));</span><br></pre></td></tr></table></figure><p>值得注意的是，除非我们对此有十足的把握，否则不要轻易改变默认的 TCP Nagle 算法。因为在现代操作系统中，针对 Nagle 算法和延时 ACK 的优化已经非常成熟了，有可能在禁用 Nagle 算法之后，性能问题反而更加严重。</p><h2 id="第十五讲"><a href="#第十五讲" class="headerlink" title="第十五讲"></a>第十五讲</h2><p>重用套接字选项，通过给套接字配置可重用属性，告诉操作系统内核，这样的 TCP 连接完全可以复用 TIME_WAIT 状态的连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br></pre></td></tr></table></figure><p><code>SO_REUSEADDR</code> 套接字选项还有一个作用，那就是本机服务器如果有多个地址(ip地址)，可以在不同地址上使用相同的端口提供服务。</p><p>要在创建socket和bind之间设置 <code>SO_REUSEADDR</code> 套接字选项 因为<code>SO_REUSEADDR</code> 是针对新建立的连接才起作用，对已建立的连接设置是无效的。</p><h2 id="第十七讲"><a href="#第十七讲" class="headerlink" title="第十七讲"></a>第十七讲</h2><p><img src="/.%5Cimg%5CSnipaste_2023-12-27_23-10-09.png"></p><ul><li>网络中断造成的对端无 FIN 包</li></ul><p>很多原因都会造成网络中断，在这种情况下，TCP 程序并不能及时感知到异常信息。除非网络中的其他设备，如路由器发出一条 ICMP 报文，说明目的网络或主机不可达，这个时候通过 read 或 write 调用就会返回 Unreachable 的错误。</p><p>大多数时候并不是如此，在没有 ICMP 报文的情况下，TCP 程序并不能理解感应到连接异常。如果程序是阻塞在 read 调用上，那么很不幸，程序无法从异常中恢复。</p><p>如果程序先调用了 write 操作发送了一段数据流，接下来阻塞在 read 调用上，结果会非常不同。Linux 系统的 TCP 协议栈会不断尝试将发送缓冲区的数据发送出去，大概在重传 12 次、合计时间约为 9 分钟之后，协议栈会标识该连接异常，这时，阻塞的 read 调用会返回一条 TIMEOUT 的错误信息。如果此时程序还执着地往这条连接写数据，写操作会立即失败，返回一个 SIGPIPE 信号给应用程序。</p><ul><li>系统崩溃造成的对端无 FIN 包</li></ul><p>当系统突然崩溃，如断电时，网络连接上来不及发出任何东西。这里和通过系统调用杀死应用程序非常不同的是，没有任何 FIN 包被发送出来。</p><p>在没有 ICMP 报文的情况下，TCP 程序只能通过 read 和 write 调用得到网络连接异常的信息，超时错误是一个常见的结果。</p><p>系统在崩溃之后又重启，当重传的 TCP 分组到达重启后的系统，由于系统中没有该 TCP 分组对应的连接数据，系统会返回一个 RST 重置分节，TCP 程序通过 read 或 write 调用可以分别对 RST 进行错误处理。</p><p>如果是阻塞的 read 调用，会立即返回一个错误，错误信息为连接重置（Connection Reset）。</p><p>如果是一次 write 操作，也会立即失败，应用程序会被返回一个 SIGPIPE 信号。</p><ul><li>对端有FIN包发出</li></ul><p>对端如果有 FIN 包发出，可能的场景是对端调用了 close 或 shutdown 显式地关闭了连接，也可能是对端应用程序崩溃，操作系统内核代为清理所发出的。<strong>从应用程序角度上看，无法区分是哪种情形</strong>。</p><h2 id="第十八讲"><a href="#第十八讲" class="headerlink" title="第十八讲"></a>第十八讲</h2><p>当服务器完全崩溃或网络故障，如果采用阻塞读，将无法感知到套接字异常，将会一直阻塞，可以为<code>read</code>设置超时,果超过了一段时间就认为连接已经不存在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">setsockopt(connfd, SOL_SOCKET, SO_RCVTIMEO, (<span class="type">const</span> <span class="type">char</span> *) &amp;tv, <span class="keyword">sizeof</span> tv);</span><br><span class="line"><span class="type">int</span> nBytes = recv(connfd, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (nBytes == <span class="number">-1</span>) </span><br><span class="line"> <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123; ... &#125;    <span class="comment">//执行超时处理，如断开连接</span></span><br></pre></td></tr></table></figure><h2 id="第十九讲"><a href="#第十九讲" class="headerlink" title="第十九讲"></a>第十九讲</h2><p>一个进程无论是正常退出（exit 或者 main 函数返回），还是非正常退出（比如，收到 SIGKILL 信号关闭，就是我们常常干的 kill -9），所有该进程打开的描述符都会被系统关闭，这也导致 TCP 描述符对应的连接上发出一个 FIN 包。</p><h2 id="第二十讲"><a href="#第二十讲" class="headerlink" title="第二十讲"></a>第二十讲</h2><p>我们可以使用 fgets 方法等待标准输入，但是一旦这样做，就没有办法在套接字有数据的时候读出数据；我们也可以使用 read 方法等待套接字有数据返回，但是这样做，也没有办法在标准输入有数据的情况下，读入数据并发送给对方。I&#x2F;O 多路复用的设计初衷就是解决这样的场景。我们可以把标准输入、套接字等都看做 I&#x2F;O 的一路，多路复用的意思，就是在任何一路 I&#x2F;O 有“事件”发生的情况下，通知应用程序去处理相应的 I&#x2F;O 事件，这样我们的程序就变成了“多面手”，在同一时刻仿佛可以处理多个 I&#x2F;O 事件。select所支持的文件描述符上线只有1024个</p><blockquote><p>你认为 select 函数里一定需要传入描述字基数这个值么？</p></blockquote><p>需要设置。<code>int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);</code> 函数select检测相当于遍历三个 fd_set，需要知道数组的上限</p><h2 id="第二十一讲"><a href="#第二十一讲" class="headerlink" title="第二十一讲"></a>第二十一讲</h2><p>poll 突破了select对文件描述符的限制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">unsigned</span> <span class="type">long</span> nfds, <span class="type">int</span> timeout)</span>; </span><br></pre></td></tr></table></figure><ul><li><p>pollfd 数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">     <span class="type">short</span> events; <span class="comment">/* events to look for POLLIN POOLOUT*/</span></span><br><span class="line">     <span class="type">short</span> revents; <span class="comment">/* events returned */</span></span><br><span class="line"> &#125;;</span><br><span class="line">其中对应的事件：</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLIN 0x0001 <span class="comment">/* any readable data available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLPRI 0x0002 <span class="comment">/* OOB/Urgent readable data */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDNORM 0x0040 <span class="comment">/* non-OOB/URG data available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDBAND 0x0080 <span class="comment">/* OOB/Urgent readable data */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLOUT 0x0004 <span class="comment">/* file descriptor is writeable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLWRNORM POLLOUT <span class="comment">/* no write type differentiation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLWRBAND 0x0100 <span class="comment">/* OOB/Urgent data can be written */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLERR 0x0008 <span class="comment">/* 一些错误发送 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLHUP 0x0010 <span class="comment">/* 描述符挂起*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLNVAL 0x0020 <span class="comment">/* 请求的事件无效*/</span></span></span><br></pre></td></tr></table></figure></li></ul><p>如果我们<strong>不想对某个 pollfd 结构进行事件检测，</strong>可以把它对应的 pollfd 结构的 fd 成员设置成一个负值。这样，poll 函数将忽略这样的 events 事件，检测完成以后，所对应的“returned events”的成员值也将设置为 0。在 poll 函数里，我们可以控制 pollfd 结构的数组大小，这意味着我们可以突破原来 select 函数最大描述符的限制，在这种情况下，应用程序调用者需要分配 pollfd 数组并通知 poll 函数该数组的大小。</p><h2 id="第二十二讲"><a href="#第二十二讲" class="headerlink" title="第二十二讲"></a>第二十二讲</h2><p>read &#x2F; write：</p><p>非阻塞读操作：如果套接字对应的接收缓冲区没有数据可读，在非阻塞情况下 read 调用会立即返回，一般返回 EWOULDBLOCK 或 EAGAIN 出错信息</p><p>非阻塞写操作：在非阻塞 I&#x2F;O 的情况下，如果套接字的发送缓冲区已达到了极限，不能容纳更多的字节，那么操作系统内核会<strong>尽最大可能</strong>从应用程序拷贝数据到发送缓冲区中，并立即从 write 等函数调用中返回已拷贝的字节数</p><p>accept：</p><p>当 accept 和 I&#x2F;O 多路复用 select、poll 等一起配合使用时，如果在监听套接字上触发事件，说明有连接建立完成，此时调用 accept 肯定可以返回已连接套接字。但是总有例外</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line">connect();                <span class="comment">//在收到服务端回的ack时返回，进入establish状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">ling</span>;</span></span><br><span class="line">ling.l_onoff = <span class="number">1</span>; </span><br><span class="line">ling.l_linger = <span class="number">0</span>;</span><br><span class="line">setsockopt(socket_fd, SOL_SOCKET, SO_LINGER, &amp;ling, <span class="keyword">sizeof</span>(ling));</span><br><span class="line">close(socket_fd);        <span class="comment">//此时服务端没有调用accept，就受到了RST报文</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(listen_fd, &amp;readset)) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;listening socket readable\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">5</span>);                <span class="comment">//时延            </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span></span><br><span class="line"> <span class="type">socklen_t</span> slen = <span class="keyword">sizeof</span>(ss);</span><br><span class="line"> <span class="type">int</span> fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr *) &amp;ss, &amp;slen);</span><br></pre></td></tr></table></figure><p>这里的休眠时间非常关键，这样，在监听套接字上有可读事件发生时，并没有马上调用 accept。由于客户端发生了 RST 分节，该连接被接收端内核从自己的已完成队列中删除了，此时再调用 accept，由于没有已完成连接（假设没有其他已完成连接），accept 一直阻塞，更为严重的是，该线程再也没有机会对其他 I&#x2F;O 事件进行分发，相当于该服务器无法对其他 I&#x2F;O 进行服务。如果我们将监听套接字设为非阻塞，上述的情形就不会再发生。只不过对于 accept 的返回值，需要正确地处理各种看似异常的错误，例如忽略 EWOULDBLOCK、EAGAIN 等。</p><p>connect：</p><p>非阻塞调用时会立即返回 EINPROGRESS 错误，连接后会返回 EISCONN 错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(connect() == EISCONN)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二十三讲"><a href="#第二十三讲" class="headerlink" title="第二十三讲"></a>第二十三讲</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line"> <span class="type">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line"> <span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line"> &#125;;</span><br><span class="line">* EPOLLIN：表示对应的文件描述字可以读；</span><br><span class="line"></span><br><span class="line">* EPOLLOUT：表示对应的文件描述字可以写；</span><br><span class="line"></span><br><span class="line">* EPOLLRDHUP：表示套接字的一端已经关闭，或者半关闭；</span><br><span class="line"></span><br><span class="line">* EPOLLHUP：表示对应的文件描述字被挂起；</span><br><span class="line"></span><br><span class="line">* EPOLLET：设置为 edge-triggered，默认为 level-triggered。</span><br></pre></td></tr></table></figure><p>水平触发(level-trggered)</p><ul><li>只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知，</li><li>当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知</li></ul><p>边缘触发(edge-triggered)</p><ul><li>当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知，</li><li>当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知</li></ul><p>在linux下，如果用边缘触发同时注册了读和写，当读触发的时候，内核向用户返回fd的时候同时会检查fd是否符合可写的条件（有空间容纳待写入的数据），如果满足可写的条件，同时会加上EPOLLOUT标记。</p><h2 id="第三十讲"><a href="#第三十讲" class="headerlink" title="第三十讲"></a>第三十讲</h2><p>无论是阻塞 I&#x2F;O，还是阻塞 I&#x2F;O，和基于非阻塞 I&#x2F;O 的多路复用都是<strong>同步调用技术。为什么这么说呢？因为同步调用、异步调用的说法，是对于获取数据的过程而言的，前面几种最后获取数据的 read 操作调用，都是同步的，在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，这个过程是在 read 函数中同步进行的，如果内核实现的拷贝效率很差，read 调用就会在这个同步过程中消耗比较长的时间</strong></p><p>而真正的异步调用则不用担心这个问题，我们接下来就来介绍第四种 I&#x2F;O 技术，当我们发起 io_uring之后，就立即返回，内核自动将数据从内核空间拷贝到应用程序空间，这个拷贝过程是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。</p><p><a href="https://juejin.cn/post/6844903879688060942">https://juejin.cn/post/6844903879688060942</a>  重置报文</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络编程实战&quot;&gt;&lt;a href=&quot;#网络编程实战&quot; class=&quot;headerlink&quot; title=&quot;网络编程实战&quot;&gt;&lt;/a&gt;网络编程实战&lt;/h1&gt;&lt;h2 id=&quot;第四讲&quot;&gt;&lt;a href=&quot;#第四讲&quot; class=&quot;headerlink&quot; title=&quot;第四讲</summary>
      
    
    
    
    
    <category term="网络编程" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
